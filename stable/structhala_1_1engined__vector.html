<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HALA: Handy Accelerated Linear Algebra v1.0: hala::engined_vector&lt; cengine, vec &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hala.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"/>
                </a> 1.8.13
    </div>
   <div id="projectname">HALA: Handy Accelerated Linear Algebra v1.0
   <!--         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 -->
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structhala_1_1engined__vector.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structhala_1_1engined__vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">hala::engined_vector&lt; cengine, vec &gt; Struct Template Reference<div class="ingroups"><a class="el" href="group__HALAWAXEXT.html">HALA Wrapped Accelerated Extensions</a> &raquo; <a class="el" href="group__HALAWAXENGINED.html">Engined vectors</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A struct that binds an engine and a vector so both can be carried in one context.  
 <a href="structhala_1_1engined__vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="hala__noengine__structs_8hpp_source.html">hala_noengine_structs.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for hala::engined_vector&lt; cengine, vec &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structhala_1_1engined__vector__coll__graph.png" border="0" usemap="#hala_1_1engined__vector_3_01cengine_00_01vec_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="hala_1_1engined__vector_3_01cengine_00_01vec_01_4_coll__map" id="hala_1_1engined__vector_3_01cengine_00_01vec_01_4_coll__map">
<area shape="rect" id="node2" href="structhala_1_1engined__vector__binding.html" title="hala::engined_vector\l_binding\&lt; vec \&gt;" alt="" coords="5,5,148,47"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:affbbc912cf70ea142a5b5ac9bf226496"><td class="memItemLeft" align="right" valign="top"><a id="affbbc912cf70ea142a5b5ac9bf226496"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1engined__vector.html#affbbc912cf70ea142a5b5ac9bf226496">vtype</a> = typename <a class="el" href="structhala_1_1engined__vector__binding.html">engined_vector_binding</a>&lt; vec &gt;::type</td></tr>
<tr class="memdesc:affbbc912cf70ea142a5b5ac9bf226496"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the vector used in the binding, removes any reference qualifies but leaves const. <br /></td></tr>
<tr class="separator:affbbc912cf70ea142a5b5ac9bf226496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa349e0736aa601fb0a2fd95e0688c151"><td class="memItemLeft" align="right" valign="top"><a id="aa349e0736aa601fb0a2fd95e0688c151"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1engined__vector.html#aa349e0736aa601fb0a2fd95e0688c151">value_type</a> = <a class="el" href="group__HALACUSTOM.html#gaeb090a328015649aed8ed8bb9b5e4980">get_standard_type</a>&lt; <a class="el" href="structhala_1_1engined__vector.html#affbbc912cf70ea142a5b5ac9bf226496">vtype</a> &gt;</td></tr>
<tr class="memdesc:aa349e0736aa601fb0a2fd95e0688c151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the scalar type of the underlying vector, mostly used for the precision of the stopping criteria. <br /></td></tr>
<tr class="separator:aa349e0736aa601fb0a2fd95e0688c151"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ade6cf181af90d5a9ffacd39f3ee789b0"><td class="memItemLeft" align="right" valign="top"><a id="ade6cf181af90d5a9ffacd39f3ee789b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1engined__vector.html#ade6cf181af90d5a9ffacd39f3ee789b0">engined_vector</a> (cengine const &amp;<a class="el" href="structhala_1_1engined__vector.html#a59f76dfde03dbe02e7d8f11937d68e0e">engine</a>, <a class="el" href="structhala_1_1engined__vector.html#affbbc912cf70ea142a5b5ac9bf226496">vtype</a> &amp;x)</td></tr>
<tr class="memdesc:ade6cf181af90d5a9ffacd39f3ee789b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="structhala_1_1engined__vector.html" title="A struct that binds an engine and a vector so both can be carried in one context. ...">engined_vector</a> with non-owning references to the engine and <b>x</b>. <br /></td></tr>
<tr class="separator:ade6cf181af90d5a9ffacd39f3ee789b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53084f7a44b8e346f185dcb0f7a0a754"><td class="memItemLeft" align="right" valign="top"><a id="a53084f7a44b8e346f185dcb0f7a0a754"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1engined__vector.html#a53084f7a44b8e346f185dcb0f7a0a754">engined_vector</a> (cengine const &amp;<a class="el" href="structhala_1_1engined__vector.html#a59f76dfde03dbe02e7d8f11937d68e0e">engine</a>)</td></tr>
<tr class="memdesc:a53084f7a44b8e346f185dcb0f7a0a754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="structhala_1_1engined__vector.html" title="A struct that binds an engine and a vector so both can be carried in one context. ...">engined_vector</a> with ownership to an internal vector. <br /></td></tr>
<tr class="separator:a53084f7a44b8e346f185dcb0f7a0a754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15510243cb2df416872c64d58230d0b6"><td class="memTemplParams" colspan="2">template&lt;class oengine , class vec2 &gt; </td></tr>
<tr class="memitem:a15510243cb2df416872c64d58230d0b6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structhala_1_1engined__vector.html#a15510243cb2df416872c64d58230d0b6">engine_match</a> (<a class="el" href="structhala_1_1engined__vector.html">engined_vector</a>&lt; oengine, vec2 &gt; const &amp;) const</td></tr>
<tr class="memdesc:a15510243cb2df416872c64d58230d0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if the other <a class="el" href="structhala_1_1engined__vector.html" title="A struct that binds an engine and a vector so both can be carried in one context. ...">engined_vector</a> has a compatible engine.  <a href="#a15510243cb2df416872c64d58230d0b6">More...</a><br /></td></tr>
<tr class="separator:a15510243cb2df416872c64d58230d0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f76dfde03dbe02e7d8f11937d68e0e"><td class="memItemLeft" align="right" valign="top"><a id="a59f76dfde03dbe02e7d8f11937d68e0e"></a>
cengine const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1engined__vector.html#a59f76dfde03dbe02e7d8f11937d68e0e">engine</a> () const</td></tr>
<tr class="memdesc:a59f76dfde03dbe02e7d8f11937d68e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the engine. <br /></td></tr>
<tr class="separator:a59f76dfde03dbe02e7d8f11937d68e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab7aa228a7eadef7b7ca3154f5745a6b"><td class="memItemLeft" align="right" valign="top"><a id="aab7aa228a7eadef7b7ca3154f5745a6b"></a>
<a class="el" href="structhala_1_1engined__vector.html#affbbc912cf70ea142a5b5ac9bf226496">vtype</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1engined__vector.html#aab7aa228a7eadef7b7ca3154f5745a6b">vector</a> () const</td></tr>
<tr class="memdesc:aab7aa228a7eadef7b7ca3154f5745a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the vector. <br /></td></tr>
<tr class="separator:aab7aa228a7eadef7b7ca3154f5745a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8557bf4c06158f1a592e44e2e6b78e77"><td class="memItemLeft" align="right" valign="top"><a id="a8557bf4c06158f1a592e44e2e6b78e77"></a>
<a class="el" href="structhala_1_1engined__vector.html#affbbc912cf70ea142a5b5ac9bf226496">vtype</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1engined__vector.html#a8557bf4c06158f1a592e44e2e6b78e77">vector</a> ()</td></tr>
<tr class="memdesc:a8557bf4c06158f1a592e44e2e6b78e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the vector. <br /></td></tr>
<tr class="separator:a8557bf4c06158f1a592e44e2e6b78e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f0b050e7cbfa1bd26ded753707fcdc"><td class="memItemLeft" align="right" valign="top"><a id="af5f0b050e7cbfa1bd26ded753707fcdc"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1engined__vector.html#af5f0b050e7cbfa1bd26ded753707fcdc">size</a> () const</td></tr>
<tr class="memdesc:af5f0b050e7cbfa1bd26ded753707fcdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the vector. <br /></td></tr>
<tr class="separator:af5f0b050e7cbfa1bd26ded753707fcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af904036654593fba8b4a07d34760ba21"><td class="memItemLeft" align="right" valign="top"><a id="af904036654593fba8b4a07d34760ba21"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1engined__vector.html#af904036654593fba8b4a07d34760ba21">resize</a> (size_t new_size)</td></tr>
<tr class="memdesc:af904036654593fba8b4a07d34760ba21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the vector. <br /></td></tr>
<tr class="separator:af904036654593fba8b4a07d34760ba21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9b73793281a825d33ba2612ee5109289"><td class="memItemLeft" align="right" valign="top"><a id="a9b73793281a825d33ba2612ee5109289"></a>
std::reference_wrapper&lt; cengine const  &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1engined__vector.html#a9b73793281a825d33ba2612ee5109289">e</a></td></tr>
<tr class="memdesc:a9b73793281a825d33ba2612ee5109289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the engine, it is recommended to use the <a class="el" href="structhala_1_1engined__vector.html#a59f76dfde03dbe02e7d8f11937d68e0e" title="Return a reference to the engine. ">engine()</a> method in place of direct access. <br /></td></tr>
<tr class="separator:a9b73793281a825d33ba2612ee5109289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051d17548b32a19edcf98018da884c80"><td class="memItemLeft" align="right" valign="top"><a id="a051d17548b32a19edcf98018da884c80"></a>
<a class="el" href="structhala_1_1engined__vector__binding.html">engined_vector_binding</a>&lt; vec &gt;::variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1engined__vector.html#a051d17548b32a19edcf98018da884c80">v</a></td></tr>
<tr class="memdesc:a051d17548b32a19edcf98018da884c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either owning a vector variable or non-owning reference to a vector variable. <br /></td></tr>
<tr class="separator:a051d17548b32a19edcf98018da884c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class cengine, class vec&gt;<br />
struct hala::engined_vector&lt; cengine, vec &gt;</h3>

<p>A struct that binds an engine and a vector so both can be carried in one context. </p>
<p>The purpose of the construct is to create a new entity that carries both a vector and an engine in one context. That way long algorithms do not have to constantly repeat the engine variable into each call to HALA. Instead the engine will be bounded to all input/output vectors and be carried out through the computations.</p>
<p>Do not call the constructor directly, use the factory methods <a class="el" href="group__HALAWAXENGINED.html#gaf4ae7eba405e49b271e1279c2ec3f170" title="Creates a bind between the engine and the vector. ">hala::bind_engine_vector</a> and <a class="el" href="group__HALACPUENGINE.html#ga830472d103ac598f3ca1c5204a5c0991" title="Returns a default vector with the default constructor. ">hala::new_vector</a>.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> VectorLikeA, <span class="keyword">class</span> VectorLikeB, , <span class="keyword">class</span> VectorLikeX&gt;</div><div class="line"><span class="keywordtype">void</span> advanced_solver(VectorLikeA <span class="keyword">const</span> &amp;A, VectorLikeB <span class="keyword">const</span> &amp;b, VectorLikeX &amp;x){</div><div class="line">    <span class="keyword">auto</span> t = <a class="code" href="group__HALACPUENGINE.html#ga830472d103ac598f3ca1c5204a5c0991">hala::new_vector</a>(x);</div><div class="line">    <a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(x, t);</div><div class="line">    <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(-1.0, b, x);</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="comment">// imagine many more HALA calls used to solve Ax = b</span></div><div class="line">    <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><p> The advanced solver works by default on the CPU, but what if we want to perform the solve on the GPU. If we use the engine mechanics, we would have to add another variable to the template indicating the engine type and then pass the variable to every HALA call: </p><div class="fragment"><div class="line">...</div><div class="line">auto t = <a class="code" href="group__HALACPUENGINE.html#ga830472d103ac598f3ca1c5204a5c0991">hala::new_vector</a>(engine, x);</div><div class="line"><a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(engine, x, t);</div><div class="line">...</div></div><!-- fragment --><p> If the advanced solver has many lines of code, the above will change a lot of code and can easily lead to an error if one of the calls misses the engine. In contrast, the <a class="el" href="structhala_1_1engined__vector.html" title="A struct that binds an engine and a vector so both can be carried in one context. ...">hala::engined_vector</a> allows to instantiate the solver with the GPU backend and without making any changes to the solver code: </p><div class="fragment"><div class="line"> <span class="keyword">template</span>&lt;<span class="keyword">class</span> cengine, <span class="keyword">class</span> VectorLikeA, <span class="keyword">class</span> VectorLikeB, , <span class="keyword">class</span> VectorLikeX&gt;</div><div class="line"> <span class="keywordtype">void</span> advanced_solver(cengine <span class="keyword">const</span>&amp;engine, VectorLikeA <span class="keyword">const</span> &amp;A, VectorLikeB <span class="keyword">const</span> &amp;b, VectorLikeX &amp;x){</div><div class="line">     <span class="keyword">auto</span> bindA = <a class="code" href="group__HALAWAXENGINED.html#gaf4ae7eba405e49b271e1279c2ec3f170">hala::bind_engine_vector</a>(engine, A);</div><div class="line">     <span class="keyword">auto</span> bindb = <a class="code" href="group__HALAWAXENGINED.html#gaf4ae7eba405e49b271e1279c2ec3f170">hala::bind_engine_vector</a>(engine, b);</div><div class="line">     <span class="keyword">auto</span> bindx = <a class="code" href="group__HALAWAXENGINED.html#gaf4ae7eba405e49b271e1279c2ec3f170">hala::bind_engine_vector</a>(engine, x);</div><div class="line">     advanced_solver(bindA, bindb, bindx);</div><div class="line">}</div></div><!-- fragment --><p> The above small piece of code will overload the advanced solver and allow for calls with any engine type while making no changes to the solver itself. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a15510243cb2df416872c64d58230d0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15510243cb2df416872c64d58230d0b6">&#9670;&nbsp;</a></span>engine_match()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class cengine, class vec&gt; </div>
<div class="memtemplate">
template&lt;class oengine , class vec2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structhala_1_1engined__vector.html">hala::engined_vector</a>&lt; cengine, vec &gt;::engine_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhala_1_1engined__vector.html">engined_vector</a>&lt; oengine, vec2 &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <b>true</b> if the other <a class="el" href="structhala_1_1engined__vector.html" title="A struct that binds an engine and a vector so both can be carried in one context. ...">engined_vector</a> has a compatible engine. </p>
<p>Engines are compatible if</p><ol type="1">
<li>they have the same type, e.g., both <a class="el" href="structhala_1_1cpu__engine.html" title="The CPU Engine. ">cpu_engine</a></li>
<li>if using <a class="el" href="structhala_1_1gpu__engine.html" title="Core engine class, deals with handles and data transfer. ">hala::gpu_engine</a> or hala::mixed_engine, then the device ids of the engines should also match.</li>
</ol>
<p>Overloads are provided to handle all possible pairs of engine types. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>wax/<a class="el" href="hala__noengine__structs_8hpp_source.html">hala_noengine_structs.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="navelem"><a class="el" href="namespacehala.html">hala</a></li><li class="navelem"><a class="el" href="structhala_1_1engined__vector.html">engined_vector</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div> -->
</body>
</html>
