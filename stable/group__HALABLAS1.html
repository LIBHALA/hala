<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HALA: Handy Accelerated Linear Algebra v1.0: BLAS level 1 templates</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hala.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"/>
                </a> 1.8.13
    </div>
   <div id="projectname">HALA: Handy Accelerated Linear Algebra v1.0
   <!--         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 -->
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__HALABLAS1.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">BLAS level 1 templates<div class="ingroups"><a class="el" href="group__HALABLAS.html">HALA BLAS Wrapper Templates</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for BLAS level 1 templates:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__HALABLAS1.png" border="0" alt="" usemap="#group____HALABLAS1"/>
<map name="group____HALABLAS1" id="group____HALABLAS1">
<area shape="rect" id="node2" href="group__HALABLAS.html" title="HALA BLAS Wrapper Templates" alt="" coords="5,5,219,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga199fd708ca4ff8b2c65b6ee47491b37d"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga199fd708ca4ff8b2c65b6ee47491b37d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a> (int N, VectorLikeX const &amp;x, int incx, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga199fd708ca4ff8b2c65b6ee47491b37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS xcopy() methods.  <a href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">More...</a><br /></td></tr>
<tr class="separator:ga199fd708ca4ff8b2c65b6ee47491b37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2809dfc1c6ae1f53eb9f59d68f23c7b0"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga2809dfc1c6ae1f53eb9f59d68f23c7b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga2809dfc1c6ae1f53eb9f59d68f23c7b0">hala::vswap</a> (int N, VectorLikeX &amp;&amp;x, int incx, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga2809dfc1c6ae1f53eb9f59d68f23c7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS xswap() methods.  <a href="group__HALABLAS1.html#ga2809dfc1c6ae1f53eb9f59d68f23c7b0">More...</a><br /></td></tr>
<tr class="separator:ga2809dfc1c6ae1f53eb9f59d68f23c7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48f8d9b686ef4a9cdb69897e3f22bbe5"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga48f8d9b686ef4a9cdb69897e3f22bbe5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga48f8d9b686ef4a9cdb69897e3f22bbe5">hala::norm2</a> (int N, VectorLikeX const &amp;x, int incx)</td></tr>
<tr class="memdesc:ga48f8d9b686ef4a9cdb69897e3f22bbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS vector 2-norm.  <a href="group__HALABLAS1.html#ga48f8d9b686ef4a9cdb69897e3f22bbe5">More...</a><br /></td></tr>
<tr class="separator:ga48f8d9b686ef4a9cdb69897e3f22bbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2690240bc40fc865a64a9acc7cce06b5"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga2690240bc40fc865a64a9acc7cce06b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga2690240bc40fc865a64a9acc7cce06b5">hala::asum</a> (int N, VectorLikeX const &amp;x, int incx)</td></tr>
<tr class="memdesc:ga2690240bc40fc865a64a9acc7cce06b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS vector sum of absolute values of the entry components.  <a href="group__HALABLAS1.html#ga2690240bc40fc865a64a9acc7cce06b5">More...</a><br /></td></tr>
<tr class="separator:ga2690240bc40fc865a64a9acc7cce06b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2f0c0b1c17c7a8ee5fe664fe0d652c"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga4f2f0c0b1c17c7a8ee5fe664fe0d652c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga4f2f0c0b1c17c7a8ee5fe664fe0d652c">hala::iamax</a> (int N, VectorLikeX const &amp;x, int incx)</td></tr>
<tr class="memdesc:ga4f2f0c0b1c17c7a8ee5fe664fe0d652c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS find index of largest vector entry, ixamax().  <a href="group__HALABLAS1.html#ga4f2f0c0b1c17c7a8ee5fe664fe0d652c">More...</a><br /></td></tr>
<tr class="separator:ga4f2f0c0b1c17c7a8ee5fe664fe0d652c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dff938a94c75c58427ede241c05429b"><td class="memTemplParams" colspan="2">template&lt;typename FS , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga0dff938a94c75c58427ede241c05429b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a> (int N, FS alpha, VectorLikeX const &amp;x, int incx, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga0dff938a94c75c58427ede241c05429b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS vector scaled addition xaxpy().  <a href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">More...</a><br /></td></tr>
<tr class="separator:ga0dff938a94c75c58427ede241c05429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55b878e5a1a05ef1c181a879edaa6528"><td class="memTemplParams" colspan="2">template&lt;bool conjugate = true, class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga55b878e5a1a05ef1c181a879edaa6528"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga55b878e5a1a05ef1c181a879edaa6528">hala::dot</a> (int N, VectorLikeX const &amp;x, int incx, VectorLikeY const &amp;y, int incy)</td></tr>
<tr class="memdesc:ga55b878e5a1a05ef1c181a879edaa6528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS vector dot-product xdot().  <a href="group__HALABLAS1.html#ga55b878e5a1a05ef1c181a879edaa6528">More...</a><br /></td></tr>
<tr class="separator:ga55b878e5a1a05ef1c181a879edaa6528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d8f14a164c86b89abbb4e7bfbdca660"><td class="memTemplParams" colspan="2">template&lt;typename FS , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga3d8f14a164c86b89abbb4e7bfbdca660"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga3d8f14a164c86b89abbb4e7bfbdca660">hala::scal</a> (int N, FS alpha, VectorLikeX &amp;&amp;x, int incx)</td></tr>
<tr class="memdesc:ga3d8f14a164c86b89abbb4e7bfbdca660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS vector scale by constant xscal().  <a href="group__HALABLAS1.html#ga3d8f14a164c86b89abbb4e7bfbdca660">More...</a><br /></td></tr>
<tr class="separator:ga3d8f14a164c86b89abbb4e7bfbdca660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d16bf7ce27762641f5a019b7cbd8495"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6d16bf7ce27762641f5a019b7cbd8495"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga6d16bf7ce27762641f5a019b7cbd8495">hala::rotg</a> (T &amp;SA, T &amp;SB, typename <a class="el" href="structhala_1_1define__standard__precision.html">define_standard_precision</a>&lt; T &gt;::value_type &amp;C, T &amp;S)</td></tr>
<tr class="memdesc:ga6d16bf7ce27762641f5a019b7cbd8495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS generate Givens rotation, xrotg().  <a href="group__HALABLAS1.html#ga6d16bf7ce27762641f5a019b7cbd8495">More...</a><br /></td></tr>
<tr class="separator:ga6d16bf7ce27762641f5a019b7cbd8495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc25006cc0ab0a6befa1b7af6ab18e91"><td class="memTemplParams" colspan="2">template&lt;typename FC , typename FS , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:gafc25006cc0ab0a6befa1b7af6ab18e91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#gafc25006cc0ab0a6befa1b7af6ab18e91">hala::rot</a> (int N, VectorLikeX &amp;&amp;x, int incx, VectorLikeY &amp;&amp;y, int incy, FC C, FS S)</td></tr>
<tr class="memdesc:gafc25006cc0ab0a6befa1b7af6ab18e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS apply the Givens rotation, xrot().  <a href="group__HALABLAS1.html#gafc25006cc0ab0a6befa1b7af6ab18e91">More...</a><br /></td></tr>
<tr class="separator:gafc25006cc0ab0a6befa1b7af6ab18e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d34e87ad9216f7838bb02ea978d5f64"><td class="memTemplParams" colspan="2">template&lt;typename T , class VectorLike &gt; </td></tr>
<tr class="memitem:ga7d34e87ad9216f7838bb02ea978d5f64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga7d34e87ad9216f7838bb02ea978d5f64">hala::rotmg</a> (T &amp;D1, T &amp;D2, T &amp;X, T const &amp;Y, VectorLike &amp;&amp;param)</td></tr>
<tr class="memdesc:ga7d34e87ad9216f7838bb02ea978d5f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS generate modified Givens rotation.  <a href="group__HALABLAS1.html#ga7d34e87ad9216f7838bb02ea978d5f64">More...</a><br /></td></tr>
<tr class="separator:ga7d34e87ad9216f7838bb02ea978d5f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67aa0d17df77921cd1e3d4b59fafb6ab"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX , class VectorLikeY , class VectorLikeP &gt; </td></tr>
<tr class="memitem:ga67aa0d17df77921cd1e3d4b59fafb6ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga67aa0d17df77921cd1e3d4b59fafb6ab">hala::rotm</a> (int N, VectorLikeX &amp;&amp;x, int incx, VectorLikeY &amp;&amp;y, int incy, VectorLikeP const &amp;param)</td></tr>
<tr class="memdesc:ga67aa0d17df77921cd1e3d4b59fafb6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS apply the Givens rotation, xrotm().  <a href="group__HALABLAS1.html#ga67aa0d17df77921cd1e3d4b59fafb6ab">More...</a><br /></td></tr>
<tr class="separator:ga67aa0d17df77921cd1e3d4b59fafb6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff1d8d3e51d4858a50e4859f3770e78"><td class="memTemplParams" colspan="2"><a id="ga7ff1d8d3e51d4858a50e4859f3770e78"></a>
template&lt;class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga7ff1d8d3e51d4858a50e4859f3770e78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga7ff1d8d3e51d4858a50e4859f3770e78">hala::vswap</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, int N, VectorLikeX &amp;&amp;x, int incx, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga7ff1d8d3e51d4858a50e4859f3770e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU Xswap() methods. <br /></td></tr>
<tr class="separator:ga7ff1d8d3e51d4858a50e4859f3770e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>BLAS Level 1</dt><dd>Level 1 operations are defines as those that act on vectors, i.e., without matrices. Examples of such operations are norm, scale, and vector addition. </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga199fd708ca4ff8b2c65b6ee47491b37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga199fd708ca4ff8b2c65b6ee47491b37d">&#9670;&nbsp;</a></span>vcopy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeX , class VectorLikeY &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::vcopy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeX const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeY &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to BLAS xcopy() methods. </p>
<p>Copies <b>N</b> entries of <b>x</b> into <b>y</b> using strides <b>incx</b> and <b>incy</b>. The name is chosen to be distinct from standard copy().</p>
<p>Overloads: </p><div class="fragment"><div class="line"><a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(x, y, incx = 1, incy = 1, N = -1);</div><div class="line"><a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(engine, N, x, incx, y, incy);</div><div class="line"><a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(engine, x, y, incx = 1, incy = 1, N = -1);</div><div class="line">default_vector_type y = <a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(engine, x);</div></div><!-- fragment --><p> The increments default to 1 and the correct value of <b>N</b> is inferred from the size of <b>x</b> and <b>incx</b>. </p>

</div>
</div>
<a id="ga2809dfc1c6ae1f53eb9f59d68f23c7b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2809dfc1c6ae1f53eb9f59d68f23c7b0">&#9670;&nbsp;</a></span>vswap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeX , class VectorLikeY &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::vswap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeX &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeY &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to BLAS xswap() methods. </p>
<p>Swaps <b>N</b> entries between <b>x</b> and <b>y</b> using strides <b>incx</b> and <b>incy</b>. The name is chosen to be distinct from standard swap().</p>
<p>Overloads: </p><div class="fragment"><div class="line"><a class="code" href="group__HALABLAS1.html#ga2809dfc1c6ae1f53eb9f59d68f23c7b0">hala::vswap</a>(x, y, incx = 1, incy = 1, N = -1);</div><div class="line"><a class="code" href="group__HALABLAS1.html#ga2809dfc1c6ae1f53eb9f59d68f23c7b0">hala::vswap</a>(engine, N, x, incx, y, incy);</div><div class="line"><a class="code" href="group__HALABLAS1.html#ga2809dfc1c6ae1f53eb9f59d68f23c7b0">hala::vswap</a>(engine, x, y, incx = 1, incy = 1, N = -1);</div></div><!-- fragment --><p> The increments default to 1 and the correct value of <b>N</b> is inferred from the size of <b>x</b> and <b>incx</b>. </p>

</div>
</div>
<a id="ga48f8d9b686ef4a9cdb69897e3f22bbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48f8d9b686ef4a9cdb69897e3f22bbe5">&#9670;&nbsp;</a></span>norm2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hala::norm2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeX const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to BLAS vector 2-norm. </p>
<p>Computes the vector 2-norm, i.e., \( \left( \sum_{i=1}^N |x_i|^2 \right)^{1/2} \).</p><ul>
<li><b>N</b> is the total number of entries</li>
<li><b>incx</b> is the distance between vector entries</li>
<li><b>returns</b> a real number with the same precision as <b>x</b>, i.e., float for complex&lt;float&gt;</li>
</ul>
<p>Overloads: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> x_norm = <a class="code" href="group__HALABLAS1.html#ga48f8d9b686ef4a9cdb69897e3f22bbe5">hala::norm2</a>(x, incx = 1, N = -1);</div><div class="line"><span class="keyword">auto</span> x_norm = <a class="code" href="group__HALABLAS1.html#ga48f8d9b686ef4a9cdb69897e3f22bbe5">hala::norm2</a>(engine, N, x, incx);</div><div class="line"><span class="keyword">auto</span> x_norm = <a class="code" href="group__HALABLAS1.html#ga48f8d9b686ef4a9cdb69897e3f22bbe5">hala::norm2</a>(engine, x, incx = 1, N = -1);</div></div><!-- fragment --><p> The increment defaults to 1 and the correct value of <b>N</b> is inferred from the size of <b>x</b> and <b>incx</b>. </p>

</div>
</div>
<a id="ga2690240bc40fc865a64a9acc7cce06b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2690240bc40fc865a64a9acc7cce06b5">&#9670;&nbsp;</a></span>asum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hala::asum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeX const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to BLAS vector sum of absolute values of the entry components. </p>
<p>Computes the sum of absolute value of the entry components, i.e., \( \sum_{i=1}^N |real(x_i)| + |imag(x_i)| \).</p><ul>
<li><b>N</b> is the total number of entries</li>
<li><b>incx</b> is the distance between vector entries</li>
<li><b>returns</b> a real number with the same precision as <b>x</b>, i.e., float for complex&lt;float&gt;</li>
</ul>
<p>Overloads: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> x_sum = <a class="code" href="group__HALABLAS1.html#ga2690240bc40fc865a64a9acc7cce06b5">hala::asum</a>(x, incx = 1, N = -1);</div><div class="line"><span class="keyword">auto</span> x_sum = <a class="code" href="group__HALABLAS1.html#ga2690240bc40fc865a64a9acc7cce06b5">hala::asum</a>(engine, N, x, incx);</div><div class="line"><span class="keyword">auto</span> x_sum = <a class="code" href="group__HALABLAS1.html#ga2690240bc40fc865a64a9acc7cce06b5">hala::asum</a>(engine, x, incx = 1, N = -1);</div></div><!-- fragment --><p> The increment defaults to 1 and the correct value of <b>N</b> is inferred from the size of <b>x</b> and <b>incx</b>. </p>

</div>
</div>
<a id="ga4f2f0c0b1c17c7a8ee5fe664fe0d652c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f2f0c0b1c17c7a8ee5fe664fe0d652c">&#9670;&nbsp;</a></span>iamax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int hala::iamax </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeX const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to BLAS find index of largest vector entry, ixamax(). </p>
<p>Returns the index of the vector entry with the largest sum of absolute value of the components \( |real(x_i)| + |imag(x_i)| \).</p><ul>
<li><b>N</b> is the total number of entries</li>
<li><b>incx</b> is the distance between vector entries</li>
<li><b>returns</b> a zero-index (unlike standard BLAS) of the largest entry, the index is between 0 and N-1</li>
</ul>
<p>Overloads: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> max = <a class="code" href="group__HALABLAS1.html#ga4f2f0c0b1c17c7a8ee5fe664fe0d652c">hala::iamax</a>(x, incx = 1, N = -1);</div><div class="line"><span class="keywordtype">int</span> max = <a class="code" href="group__HALABLAS1.html#ga4f2f0c0b1c17c7a8ee5fe664fe0d652c">hala::iamax</a>(engine, N, x, incx);</div><div class="line"><span class="keywordtype">int</span> max = <a class="code" href="group__HALABLAS1.html#ga4f2f0c0b1c17c7a8ee5fe664fe0d652c">hala::iamax</a>(engine, x, incx = 1, N = -1);</div></div><!-- fragment --><p> The increment defaults to 1 and the correct value of <b>N</b> is inferred from the size of <b>x</b> and <b>incx</b>. </p>

</div>
</div>
<a id="ga0dff938a94c75c58427ede241c05429b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dff938a94c75c58427ede241c05429b">&#9670;&nbsp;</a></span>axpy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FS , class VectorLikeX , class VectorLikeY &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::axpy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FS&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeX const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeY &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to BLAS vector scaled addition xaxpy(). </p>
<p>Computes \( y = \alpha x + y \), i.e., scale <b>x</b> and add to <b>y</b>.</p><ul>
<li><b>N</b> is the total number of entries</li>
<li><b>incx</b> and <b>incy</b> are the distances between vector entries</li>
</ul>
<p>Overloads: </p><div class="fragment"><div class="line"><a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(x, y, incx = 1, incy = 1, N = -1);</div><div class="line"><a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(engine, N, x, incx, y, incy);</div><div class="line"><a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(engine, x, y, incx = 1, incy = 1, N = -1);</div></div><!-- fragment --><p> The increments default to 1 and the correct value of <b>N</b> is inferred from the effective size of <b>x</b>. </p>

</div>
</div>
<a id="ga55b878e5a1a05ef1c181a879edaa6528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55b878e5a1a05ef1c181a879edaa6528">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool conjugate = true, class VectorLikeX , class VectorLikeY &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hala::dot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeX const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeY const &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to BLAS vector dot-product xdot(). </p>
<p>Computes the dot product between two real or complex valued vectors: \( \sum_{i=1}^N op(x_i) y_i \), where <b>op</b> is either the identity or the conjugate operation.</p>
<ul>
<li><b>conjugate</b> indicates whether to use the conjugate (<b>true</b>) or identity (<b>false</b>)</li>
<li><b>N</b> is the total number of entries to use</li>
<li><b>incx</b> and <b>incy</b> are the positive strides between entries</li>
<li><b>returns</b> a complex number that matches the entreis in <b>x</b> </li>
</ul>
<p>Overloads: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> dot_product = <a class="code" href="group__HALABLAS1.html#ga55b878e5a1a05ef1c181a879edaa6528">hala::dot</a>(x, y, incx = 1, incy = 1, N = -1);</div><div class="line"><span class="keyword">auto</span> dot_product = <a class="code" href="group__HALABLAS1.html#ga55b878e5a1a05ef1c181a879edaa6528">hala::dot</a>(engine, N, x, incx, y, incy);</div><div class="line"><span class="keyword">auto</span> dot_product = <a class="code" href="group__HALABLAS1.html#ga55b878e5a1a05ef1c181a879edaa6528">hala::dot</a>(engine, x, y, incx = 1, incy = 1, N = -1);</div><div class="line"><span class="keyword">auto</span> dot_product = hala::dotu(x, y, incx = 1, incy = 1, N = -1);</div><div class="line"><span class="keyword">auto</span> dot_product = hala::dotu(engine, N, x, incx, y, incy);</div><div class="line"><span class="keyword">auto</span> dot_product = hala::dotu(engine, x, y, incx = 1, incy = 1, N = -1);</div></div><!-- fragment --><p> The increments default to 1 and the correct value of <b>N</b> is inferred from the effective size of <b>x</b>. The dotu() variant defaults to <b>conjugate</b> being <b>non_conj</b>.</p>
<p><b>Note:</b> The BLAS functions that implement complex dot-product return complex numbers which are incompatible with C++ "return" statement. Instantiation with complex numbers (single or double precision) will call "manual" implementation with a simple for-loop, and will (probably) be slower than BLAS. </p>

</div>
</div>
<a id="ga3d8f14a164c86b89abbb4e7bfbdca660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d8f14a164c86b89abbb4e7bfbdca660">&#9670;&nbsp;</a></span>scal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FS , class VectorLikeX &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::scal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FS&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeX &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to BLAS vector scale by constant xscal(). </p>
<p>Scales the vector by a constant <b>alpha</b>.</p><ul>
<li>real valued vectors can only be scaled by a real <b>alpha</b> </li>
<li>complex valued vectors can be scaled by either real or complex scalar using an appropriately optimized algorithm at the back-end.</li>
</ul>
<p>Overloads: </p><div class="fragment"><div class="line"><a class="code" href="group__HALABLAS1.html#ga3d8f14a164c86b89abbb4e7bfbdca660">hala::scal</a>(alpha, x, incx = 1, N = -1);</div><div class="line"><a class="code" href="group__HALABLAS1.html#ga3d8f14a164c86b89abbb4e7bfbdca660">hala::scal</a>(engine, N, alpha, x, incx);</div><div class="line"><a class="code" href="group__HALABLAS1.html#ga3d8f14a164c86b89abbb4e7bfbdca660">hala::scal</a>(engine, alpha, x, incx = 1, N = -1);</div></div><!-- fragment --><p> The increments default to 1 and the correct value of <b>N</b> is inferred from the effective size of <b>x</b>. </p>

</div>
</div>
<a id="ga6d16bf7ce27762641f5a019b7cbd8495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d16bf7ce27762641f5a019b7cbd8495">&#9670;&nbsp;</a></span>rotg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::rotg </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>SA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>SB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structhala_1_1define__standard__precision.html">define_standard_precision</a>&lt; T &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper to BLAS generate Givens rotation, xrotg(). </p>
<p>Computes the sine and cosine of a Givens rotation so that \( \left( \begin{array}{cc} c &amp; s \\ - \bar s &amp; c \end{array} \right) \left( \begin{array}{cc} a \\ b \end{array} \right) = \left( \begin{array}{cc} n \\ 0 \end{array} \right) \)</p><ul>
<li><b>SA</b> and <b>SB</b> are the starting vector entries <b>a</b> and <b>b</b> </li>
<li><b>SA</b> will be overwritten with the value of <b>n</b> </li>
<li>some BLAS implementations (e.g., MKL) will also overwrite <b>SB</b> with additional flags thus all values are considered inputs and outputs by HALA</li>
<li><b>C</b> and <b>S</b> are the cos() and sin() of the rotation</li>
<li><b>C</b> is always a real numbers, the other three can be real or complex</li>
</ul>
<p>Overloads: </p><div class="fragment"><div class="line"><a class="code" href="group__HALABLAS1.html#ga6d16bf7ce27762641f5a019b7cbd8495">hala::rotg</a>(engine, SA, SB, C, S);</div></div><!-- fragment --><p> The cuda_engine overload will work with pointers only so that the values can be given on the GPU, if the four constants are bound to the CPU then this method is preferable since the GPU cannot really accelerate this very simple computation. </p>

</div>
</div>
<a id="gafc25006cc0ab0a6befa1b7af6ab18e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc25006cc0ab0a6befa1b7af6ab18e91">&#9670;&nbsp;</a></span>rot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FC , typename FS , class VectorLikeX , class VectorLikeY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::rot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeX &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeY &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FC&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FS&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper to BLAS apply the Givens rotation, xrot(). </p>
<p>Applies the Givens rotation to the vectors <b>x</b> and <b>y</b>.</p><ul>
<li>the vectors have <b>N</b> entries in strides <b>incx</b> and <b>incy</b> </li>
<li><b>C</b> is always a real number, defines the cosine of the rotation</li>
<li><b>S</b> can be either real or complex (if <b>x</b> and <b>y</b> are complex) and defines the sine of the rotation</li>
<li>the <b>C</b> and <b>S</b> are best computed by <a class="el" href="group__HALABLAS1.html#ga6d16bf7ce27762641f5a019b7cbd8495" title="Wrapper to BLAS generate Givens rotation, xrotg(). ">hala::rotg()</a></li>
</ul>
<p>Overloads: </p><div class="fragment"><div class="line"><a class="code" href="group__HALABLAS1.html#gafc25006cc0ab0a6befa1b7af6ab18e91">hala::rot</a>(x, y, C, S, incx = 1, incy = 1, N = -1);</div><div class="line"><a class="code" href="group__HALABLAS1.html#gafc25006cc0ab0a6befa1b7af6ab18e91">hala::rot</a>(engine, N, x, incx, y, incy, C, S);</div><div class="line"><a class="code" href="group__HALABLAS1.html#gafc25006cc0ab0a6befa1b7af6ab18e91">hala::rot</a>(engine, x, y, C, S, incx = 1, incy = 1, N = -1);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga7d34e87ad9216f7838bb02ea978d5f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d34e87ad9216f7838bb02ea978d5f64">&#9670;&nbsp;</a></span>rotmg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , class VectorLike &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::rotmg </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>D1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>D2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLike &amp;&amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper to BLAS generate modified Givens rotation. </p>
<p>Only works with real numbers.</p>
<p>The modified Givens matrix is a 2 by 2 matrix that zeros out the second component of the vector \( (\sqrt(d_1) x, \sqrt(d_2) y) \).</p><ul>
<li><b>D1</b>, <b>D2</b>, <b>X</b>, and <b>Y</b> are the scalars</li>
<li><b>param</b> is a vector with 5 entries, first is a flag the rest are overwritten with the Givens matrix.</li>
<li>since pretty much all parameters are both input and output, this works only if the types match</li>
</ul>
<p>Overloads: </p><div class="fragment"><div class="line"><a class="code" href="group__HALABLAS1.html#ga7d34e87ad9216f7838bb02ea978d5f64">hala::rotmg</a>(engine, SA, SB, C, S);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga67aa0d17df77921cd1e3d4b59fafb6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67aa0d17df77921cd1e3d4b59fafb6ab">&#9670;&nbsp;</a></span>rotm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeX , class VectorLikeY , class VectorLikeP &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::rotm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeX &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeY &amp;&amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeP const &amp;&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper to BLAS apply the Givens rotation, xrotm(). </p>
<p>Only works with real numbers.</p><ul>
<li>applies the modified Givens rotation to the vectors <b>x</b> and <b>y</b> </li>
<li>the vectors have <b>N</b> entries in strides <b>incx</b> and <b>incy</b> </li>
<li><b>param</b> must have size at least 5 and was generated by <a class="el" href="group__HALABLAS1.html#ga7d34e87ad9216f7838bb02ea978d5f64" title="Wrapper to BLAS generate modified Givens rotation. ">hala::rotmg()</a></li>
</ul>
<p>Overloads: </p><div class="fragment"><div class="line"><a class="code" href="group__HALABLAS1.html#ga67aa0d17df77921cd1e3d4b59fafb6ab">hala::rotm</a>(x, y, param, incx = 1, incy = 1, N = -1);</div><div class="line"><a class="code" href="group__HALABLAS1.html#ga67aa0d17df77921cd1e3d4b59fafb6ab">hala::rotm</a>(engine, N, x, incx, y, incy, param);</div><div class="line"><a class="code" href="group__HALABLAS1.html#ga67aa0d17df77921cd1e3d4b59fafb6ab">hala::rotm</a>(engine, x, y, param, incx = 1, incy = 1, N = -1);</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div> -->
</body>
</html>
