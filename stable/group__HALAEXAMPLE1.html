<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HALA: Handy Accelerated Linear Algebra v1.0: Example of BLAS usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hala.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"/>
                </a> 1.8.13
    </div>
   <div id="projectname">HALA: Handy Accelerated Linear Algebra v1.0
   <!--         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 -->
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__HALAEXAMPLE1.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Example of BLAS usage<div class="ingroups"><a class="el" href="group__HALAEXAMPLE.html">HALA Examples</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Example of BLAS usage:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__HALAEXAMPLE1.png" border="0" alt="" usemap="#group____HALAEXAMPLE1"/>
<map name="group____HALAEXAMPLE1" id="group____HALAEXAMPLE1">
<area shape="rect" id="node2" href="group__HALAEXAMPLE.html" title="HALA Examples" alt="" coords="5,5,124,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:example__gauss__seidel_8cpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="example__gauss__seidel_8cpp.html">example_gauss_seidel.cpp</a></td></tr>
<tr class="memdesc:example__gauss__seidel_8cpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Example of using the BLAS module of HALA. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad5ce415f7599fc854279583c857ec2fa"><td class="memTemplParams" colspan="2">template&lt;typename precision &gt; </td></tr>
<tr class="memitem:gad5ce415f7599fc854279583c857ec2fa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAEXAMPLE1.html#gad5ce415f7599fc854279583c857ec2fa">make_domain</a> (int N)</td></tr>
<tr class="memdesc:gad5ce415f7599fc854279583c857ec2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector that represents the domain.  <a href="#gad5ce415f7599fc854279583c857ec2fa">More...</a><br /></td></tr>
<tr class="separator:gad5ce415f7599fc854279583c857ec2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab51390b4d9d88a835db941041dfbb486"><td class="memTemplParams" colspan="2">template&lt;typename precision &gt; </td></tr>
<tr class="memitem:gab51390b4d9d88a835db941041dfbb486"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAEXAMPLE1.html#gab51390b4d9d88a835db941041dfbb486">make_flaplace</a> (int N)</td></tr>
<tr class="memdesc:gab51390b4d9d88a835db941041dfbb486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a simple discrete approximation to the fractional Laplacian operator.  <a href="#gab51390b4d9d88a835db941041dfbb486">More...</a><br /></td></tr>
<tr class="separator:gab51390b4d9d88a835db941041dfbb486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47f44a6aa66f9055710bb136ed35bb57"><td class="memTemplParams" colspan="2"><a id="ga47f44a6aa66f9055710bb136ed35bb57"></a>
template&lt;typename precision &gt; </td></tr>
<tr class="memitem:ga47f44a6aa66f9055710bb136ed35bb57"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAEXAMPLE1.html#ga47f44a6aa66f9055710bb136ed35bb57">make_initial</a> (int N)</td></tr>
<tr class="memdesc:ga47f44a6aa66f9055710bb136ed35bb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives a quadratic initial profile over the domain. <br /></td></tr>
<tr class="separator:ga47f44a6aa66f9055710bb136ed35bb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>Example 1</dt><dd>This example presents three implementations of an implicit time-stepping scheme using the Gauss-Seidel method for systems of linear equations using dense matrices. The example makes no claims regarding the overall best strategy to address such problem, it only serves as a demonstration of how to combine different components of HALA to build more complex methods while preserving the flexibility and exploiting the optimized linear algebra libraries.</dd></dl>
<dl class="section user"><dt></dt><dd>The example is divided into several sections:<ul>
<li><a class="el" href="group__HALAEXAMPLE1.html#Example1Problem">Problem Setup</a></li>
<li><a class="el" href="group__HALAEXAMPLE1.html#Example1VarA">Variant A using BLAS level 2</a></li>
<li><a class="el" href="group__HALAEXAMPLE1.html#Example1VarB">Variant B using BLAS level 3</a></li>
<li><a class="el" href="group__HALAEXAMPLE1.html#Example1VarC">Variant C tuned to use different levels of BLAS</a></li>
<li><a class="el" href="group__HALAEXAMPLE1.html#Example1Remarks">Remarks and Results</a></li>
</ul>
</dd></dl>
<p><a class="anchor" id="Example1Problem"></a></p><dl class="section user"><dt>Problem Setup</dt><dd>Consider the integro-differential equation with fractional Laplacian operator \( \frac{\partial u}{\partial t} = - \left( - \Delta \right)^s u \) over the domain [0, 1] integrated from 0 to t = 1 with a quadratic profile as initial condition. The specific problem and discretization scheme are not of focus, it is sufficient to say that the problem reduces to the system of ordinary differential equations \( \frac{d}{dx} f(t) = A f(t) \) where the matrix is dense. The time-stepping method used here is Crank-Nicholson implicit scheme \( \left( I - \frac{\Delta t}{2} A \right) f^{n+1} = \left( I + \frac{\Delta t}{2} A \right) f^n \) where \( f^n \approx f(n \Delta t) \), \( I \) denotes the identity matrix, and finding each successive f requires the solution of a (dense) linear system of equations. The linear solver used here is the Gauss-Seidel iteration, namely \( f_{k+1} = L^{-1} \left( b + I f_k - U f_k \right) \) where L is the lower triangular portion of the left-hand matrix, U is the upper triangular portion with unit diagonal, b is the right-hand side of the equation, the k=0 iterate is the n-th time step and as k increases the k-th iterate converges to the n+1-th time step. The stopping criteria uses the difference between two successive Gauss-Seidel iterates.</dd></dl>
<dl class="section user"><dt></dt><dd>The two components of interest are the time-stepping scheme and the iterative solver.</dd></dl>
<p><a class="anchor" id="Example1VarA"></a></p><dl class="section user"><dt>Gauss-Seidel variant A, using BLAS level 2</dt><dd>See below the implementation of the Gauss-Seidel solver and note the templated interface.</dd></dl>
<dl class="section user"><dt></dt><dd>Implementation overview:<ul>
<li>The assert() statements check for input size consistency, which is an important feature for C++ containers that "know" their own size and cannot be implemented with raw-arrays.</li>
<li>The algorithm uses one temporary vector <b>xnew</b> which will be filled with the next iterate, the temporary vector does not have to be manually resized, this will be done automatically by <a class="el" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d" title="Wrapper to BLAS xcopy() methods. ">hala::vcopy()</a>.</li>
<li>The most performance critical steps are the BLAS level 2 operations, triangular multiply and solve using <a class="el" href="group__HALABLAS2.html#gaeecc553d9de2eb43ab61941581af918a" title="Wrapper to BLAS triangular matrix-vector multiply xtrmv(). ">hala::trmv()</a> and <a class="el" href="group__HALABLAS2.html#ga5277f0adc6762b3cd4adebe1b637b7f9" title="Wrapper to BLAS triangular matrix-vector solve xtrsv(). ">hala::trsv()</a>.</li>
<li>One scale operation is needed to flip the direction of <b>xnew</b>, i.e., using <a class="el" href="group__HALABLAS1.html#ga3d8f14a164c86b89abbb4e7bfbdca660" title="Wrapper to BLAS vector scale by constant xscal(). ">hala::scal()</a>.</li>
<li>The values of <b>x</b> and <b>xnew</b> are swapped using std::swap() which will exchange only the internal pointers and thus has complexity independent of the size of the vectors.</li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Other variants exist, e.g., the forward substitution variant of the Gauss-Seidel solver can yield convergence in fewer iterations by using the newly computed values immediately, e.g., in the triangular solve stage, and this variant does not need a temporary vector. However, the approach is sequential and most BLAS implementations are parallel using all available CPU cores; sequential algorithms are at a massive disadvantage when executed on modern multi-core processors and unlike the forward substitution, our implementation requires only a few calls to HALA without the need of complicated for-loops or indexing.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> precision&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="example__gauss__seidel_8cpp.html#aaff538ec4cd7467ff7860fa6192b7b2b">solve_gauss_seidel_a</a>(<span class="keywordtype">int</span> max_iter,</div><div class="line">                          <span class="keyword">typename</span> std::vector&lt;precision&gt;::value_type stop_tolerance,</div><div class="line">                          std::vector&lt;precision&gt; <span class="keyword">const</span> &amp;A,</div><div class="line">                          std::vector&lt;precision&gt; <span class="keyword">const</span> &amp;b,</div><div class="line">                          std::vector&lt;precision&gt; &amp;x){</div><div class="line">    <span class="comment">// solves A x = b</span></div><div class="line">    assert( b.size() == x.size() );</div><div class="line">    assert( A.size() == x.size() * x.size() );</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> N = (int) x.size();</div><div class="line">    precision error = 0.0;</div><div class="line">    <span class="keywordtype">int</span> iterations = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span>{</div><div class="line">        std::vector&lt;precision&gt; xnew;</div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(x, xnew);</div><div class="line"></div><div class="line">        <a class="code" href="group__HALABLAS2.html#gaeecc553d9de2eb43ab61941581af918a">hala::trmv</a>(<span class="charliteral">&#39;U&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, <span class="charliteral">&#39;U&#39;</span>, N, A, xnew); <span class="comment">// xnew = U x</span></div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga3d8f14a164c86b89abbb4e7bfbdca660">hala::scal</a>(-1.0, xnew);   <span class="comment">// xnew = - U x</span></div><div class="line"></div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(1.0, x, xnew);</div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(1.0, b, xnew); <span class="comment">// xnew = b + I x - U x</span></div><div class="line"></div><div class="line">        <a class="code" href="group__HALABLAS2.html#ga5277f0adc6762b3cd4adebe1b637b7f9">hala::trsv</a>(<span class="charliteral">&#39;L&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, N, A, xnew); <span class="comment">// xnew = L^{-1} ( b + I x - U x )</span></div><div class="line"></div><div class="line">        std::swap(x, xnew);</div><div class="line"></div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(-1.0, x, xnew); <span class="comment">// xnew = x - xnew</span></div><div class="line">        error = <a class="code" href="group__HALABLAS1.html#ga48f8d9b686ef4a9cdb69897e3f22bbe5">hala::norm2</a>(xnew); <span class="comment">// error = \| xnew - x \|</span></div><div class="line"></div><div class="line">        iterations++;</div><div class="line">    }<span class="keywordflow">while</span>(error &gt; stop_tolerance and iterations &lt; max_iter);</div><div class="line">}</div></div><!-- fragment --> <dl class="section user"><dt>Crank-Nicholson variant A</dt><dd>The first variant of the integration scheme is very similar to the solver, the left-hand matrix is constructed explicitly in the <b>update</b> variable and the right-hand operator is treated implicitly, i.e., the application of that onto the state is computed with two calls to HALA. The <a class="el" href="group__HALABLAS2.html#ga925bf0c14261ed419bb931e85658f6eb" title="Wrapper to BLAS general matrix-vector multiply xgemv(). ">hala::gemv()</a> operation could in this case be replaced by <a class="el" href="group__HALABLAS2.html#ga6455a4464f0792f0b8e79d904ccea5c7" title="Wrapper to BLAS symmetric or Hermitian matrix-vector multiply xsymv(). ">hala::symv()</a> since the specific operator is symmetric, but the savings would be negligible compared to the cost of the Gauss-Seidel solver and the <a class="el" href="group__HALABLAS2.html#ga925bf0c14261ed419bb931e85658f6eb" title="Wrapper to BLAS general matrix-vector multiply xgemv(). ">hala::gemv()</a> variant can handle a broader class of problems.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> precision&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="example__gauss__seidel_8cpp.html#a1d04ad7c3d52154908466f2dea0997a8">integrate_a</a>(<span class="keywordtype">int</span> num_steps,</div><div class="line">                 <span class="keywordtype">int</span> max_iter,</div><div class="line">                 <span class="keyword">typename</span> std::vector&lt;precision&gt;::value_type stop_tolerance,</div><div class="line">                 std::vector&lt;precision&gt; <span class="keyword">const</span> &amp;op,</div><div class="line">                 std::vector&lt;precision&gt; &amp;state){</div><div class="line">    <span class="comment">// integrate state from t = 0 till t = 1 using dt = 1.0 / num_steps and</span></div><div class="line">    <span class="comment">// Crank-Nicholson scheme (I - dt/2 * op) f^{n+1} = (I + dt/2 * op) f^n</span></div><div class="line">    <span class="keywordtype">int</span> size = (int) state.size();</div><div class="line">    assert( op.size() == (size_t) size * size );</div><div class="line"></div><div class="line">    precision dt = 1.0 / num_steps;</div><div class="line"></div><div class="line">    <span class="comment">// set update = ( I - dt/2 * op )</span></div><div class="line">    std::vector&lt;precision&gt; update;</div><div class="line">    <a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(op, update);</div><div class="line">    <a class="code" href="group__HALABLAS1.html#ga3d8f14a164c86b89abbb4e7bfbdca660">hala::scal</a>(-0.5 * dt, update); <span class="comment">// update = -0.5 * dt * op</span></div><div class="line"></div><div class="line">    std::vector&lt;precision&gt; ones(size, 1.0);</div><div class="line">    <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(size, 1.0, ones, 1, update, size+1); <span class="comment">// update += I</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> t=0; t&lt;num_steps/10; t++){</div><div class="line"></div><div class="line">        std::vector&lt;precision&gt; rhs;</div><div class="line">        <a class="code" href="group__HALABLAS2.html#ga925bf0c14261ed419bb931e85658f6eb">hala::gemv</a>(<span class="charliteral">&#39;N&#39;</span>, size, size, 0.5 * dt, op, state, 0.0, rhs);</div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(1.0, state, rhs);</div><div class="line"></div><div class="line">        <a class="code" href="example__gauss__seidel_8cpp.html#aaff538ec4cd7467ff7860fa6192b7b2b">solve_gauss_seidel_a</a>(max_iter, stop_tolerance, update, rhs, state);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Example1VarB"></a></p><dl class="section user"><dt>Gauss-Seidel variant B, using BLAS level 3</dt><dd>Suppose that we are interested in observing how noise in the initial data propagates though the solution to the integro-differential equation. In such scenario, we would be performing multiple simulations with different initial conditions and collecting statistical data from the final solutions. Multiple simulations can be performed by wrapping the existing integrator in a for-loop solving one problems at a time, but a much better approach is to rewrite the solver using BLAS level 3 methods. The level 3 methods require the largest amount of computations vs. data-size and can achieve highest performance with the aid of very advanced caching algorithms.</dd></dl>
<dl class="section user"><dt></dt><dd>Implementation overview:<ul>
<li>The level 3 implementation accepts an additional variable indicating the number of simulations equations and the size asset statements are modified accordingly.</li>
<li>The level 2 operations are replaced by level 3 <a class="el" href="group__HALABLAS3.html#ga76b9027b698b804e16553c0ad6f8f952" title="Wrapper to BLAS triangular matrix-matrix multiply xtrmm(). ">hala::trmm()</a> and <a class="el" href="group__HALABLAS3.html#gaafa45d25006e2c87ad9138fda8347b5a" title="Wrapper to BLAS triangular matrix-matrix solve xtrsm(). ">hala::trsm()</a> and the scale operation is assimilated into the product.</li>
<li>The norm is replaced by <a class="el" href="group__HALAWAXBLAS.html#ga329f68a7f474c1502564d9afe5c6c729" title="Returns the norm of the largest vector in a batch. ">hala::batch_max_norm2()</a>, which is a HALA extension that uses a simple for-loop.</li>
<li>The rest of the algorithm remains unchanged, largely due to the HALA overloads that automatically infer vector dimensions and thus save us from counting N times the number of right-hand-sides.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> precision&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="example__gauss__seidel_8cpp.html#aed3df986e5c6c52f6c3715d7383973b0">solve_gauss_seidel_b</a>(<span class="keywordtype">int</span> max_iter,</div><div class="line">                          <span class="keyword">typename</span> std::vector&lt;precision&gt;::value_type stop_tolerance,</div><div class="line">                          <span class="keywordtype">int</span> num_rhs,</div><div class="line">                          std::vector&lt;precision&gt; <span class="keyword">const</span> &amp;A,</div><div class="line">                          std::vector&lt;precision&gt; <span class="keyword">const</span> &amp;b,</div><div class="line">                          std::vector&lt;precision&gt; &amp;x){</div><div class="line">    <span class="comment">// solves A x_i = b_i, for i = 0, 1, ..., num_rhs - 1</span></div><div class="line">    assert( num_rhs &gt; 0 );</div><div class="line">    assert( b.size() == x.size() );</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> N = (int) x.size() / num_rhs;</div><div class="line">    assert( A.size() == (size_t) (N * N) );</div><div class="line"></div><div class="line">    precision error = 0.0;</div><div class="line">    <span class="keywordtype">int</span> iterations = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span>{</div><div class="line">        std::vector&lt;precision&gt; xnew;</div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(x, xnew);</div><div class="line"></div><div class="line">        <a class="code" href="group__HALABLAS3.html#ga76b9027b698b804e16553c0ad6f8f952">hala::trmm</a>(<span class="charliteral">&#39;L&#39;</span>, <span class="charliteral">&#39;U&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, <span class="charliteral">&#39;U&#39;</span>, N, num_rhs, -1.0, A, xnew); <span class="comment">// xnew = - U x</span></div><div class="line"></div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(1.0, x, xnew);</div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(1.0, b, xnew); <span class="comment">// xnew = b - U x + I x</span></div><div class="line"></div><div class="line">        <a class="code" href="group__HALABLAS3.html#gaafa45d25006e2c87ad9138fda8347b5a">hala::trsm</a>(<span class="charliteral">&#39;L&#39;</span>, <span class="charliteral">&#39;L&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, N, num_rhs, 1.0, A, xnew); <span class="comment">// xnew = L^{-1} ( b - U x + I x )</span></div><div class="line"></div><div class="line">        std::swap(x, xnew);</div><div class="line"></div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(-1.0, x, xnew);</div><div class="line">        error = <a class="code" href="group__HALAWAXBLAS.html#ga329f68a7f474c1502564d9afe5c6c729">hala::batch_max_norm2</a>(num_rhs, xnew); <span class="comment">// error = max \| xnew - x \|</span></div><div class="line"></div><div class="line">        iterations++;</div><div class="line">    }<span class="keywordflow">while</span>(error &gt; stop_tolerance and iterations &lt; max_iter);</div><div class="line">}</div></div><!-- fragment --> <dl class="section user"><dt>Crank-Nicholson variant B</dt><dd>The corresponding time-integrator is just as easy to update replacing only the size assertions and the update that now uses <a class="el" href="group__HALABLAS3.html#gae98fae51e118dc3682284a5d001cd946" title="Wrapper to BLAS general matrix multiply xgemm(). ">hala::gemm()</a>.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> precision&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="example__gauss__seidel_8cpp.html#a455b62e03dd477dd002f461d34b97f49">integrate_b</a>(<span class="keywordtype">int</span> num_steps,</div><div class="line">                 <span class="keywordtype">int</span> max_iter,</div><div class="line">                 <span class="keyword">typename</span> std::vector&lt;precision&gt;::value_type stop_tolerance,</div><div class="line">                 std::vector&lt;precision&gt; <span class="keyword">const</span> &amp;op,</div><div class="line">                 std::vector&lt;precision&gt; &amp;state,</div><div class="line">                 <span class="keywordtype">int</span> num_states = 1){</div><div class="line">    <span class="comment">// Crank-Nicholson scheme (I - dt/2 * op) f^{n+1} = (I + dt/2 * op) f^n</span></div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> size = (int) state.size() / num_states;</div><div class="line">    assert( op.size() == (size_t) size * size );</div><div class="line">    assert( state.size() == (size_t) size * num_states );</div><div class="line"></div><div class="line">    precision dt = 1.0 / num_steps;</div><div class="line"></div><div class="line">    <span class="comment">// set update = ( I - dt/2 * op )</span></div><div class="line">    std::vector&lt;precision&gt; update;</div><div class="line">    <a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(op, update);</div><div class="line">    <a class="code" href="group__HALABLAS1.html#ga3d8f14a164c86b89abbb4e7bfbdca660">hala::scal</a>(-0.5 * dt, update); <span class="comment">// update = -0.5 * dt * op</span></div><div class="line"></div><div class="line">    std::vector&lt;precision&gt; ones(size, 1.0);</div><div class="line">    <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(size, 1.0, ones, 1, update, size+1); <span class="comment">// update += I</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> t=0; t&lt;num_steps/10; t++){</div><div class="line"></div><div class="line">        std::vector&lt;precision&gt; rhs;</div><div class="line">        <a class="code" href="group__HALABLAS3.html#gae98fae51e118dc3682284a5d001cd946">hala::gemm</a>(<span class="charliteral">&#39;N&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, size, num_states, size, 0.5 * dt, op, state, 0.0, rhs);</div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(1.0, state, rhs);</div><div class="line"></div><div class="line">        <a class="code" href="example__gauss__seidel_8cpp.html#aed3df986e5c6c52f6c3715d7383973b0">solve_gauss_seidel_b</a>(max_iter, stop_tolerance, num_states, update, rhs, state);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Example1VarC"></a></p><dl class="section user"><dt>Gauss-Seidel variant C, tuning a mix of level 2 and level 3</dt><dd>BLAS implementations use a wide range of algorithms for different cases and situations and it is hard to predict the exact point where to switch between multiple simulations of using the level 2 implementation and using the level 3. For a single state the level 2 method is the clear winner, and using many simulations (e.g., 100) the level 3 would be the clear choice. But what about the case of just 2 right hand sides, or 7, or 50? The <em>best</em> approach is empirical and tied to a specific machine and BLAS implementation, but here we present several techniques that can be successfully utilized and also demonstrate different aspects of the HALA API.</dd></dl>
<dl class="section user"><dt></dt><dd>We consider three use cases:<ul>
<li>when the number of right-hand-sides is no more than 5, we apply BLAS level 2 operations in a for loop</li>
<li>when the number of right-hand-sides is 6 to 10, we pad the problem to size 10</li>
<li>when the problem has more than 10 right-hand-sides we use the BLAS level 3 directly</li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>See the <a class="el" href="group__HALAEXAMPLE1.html#Example1Results">Results</a> section.</dd></dl>
<dl class="section user"><dt></dt><dd>The Gauss-Seidel variant C now implements a flexible algorithm that can use both level 2 and level 3 operations and work with flexible vector-like classes that can be slices of larger vectors (e.g., the columns of a larger matrix).</dd></dl>
<dl class="section user"><dt></dt><dd>Implementation overview:<ul>
<li>The first thing to note is the replacement of std::vector classes for b and x with a generic <b>VectorLike</b> class that can be any class with the appropriate HALA template specialization, e.g., std::vector, std::valarray, <a class="el" href="classhala_1_1wrapped__array.html" title="Wrapper around C-style arrays that can be passed to HALA templates. ">hala::wrapped_array</a>, etc.</li>
<li>The assert() statement now has to use the generic <a class="el" href="group__HALACUSTOM.html#gacb23ab0a92ecead8007cf9aa8dc972db" title="Returns the number of entries in the vector, if VectorLike does not have .size() method, then the template must be specialized. ">hala::get_size()</a> method instead of relying on <b>x.size()</b>.</li>
<li>If-statements select between level 2 and level 3 methods on the fly.</li>
<li>Note that even though <b>x</b> and <b>b</b> have the generic <b>VectorLike</b> types, the calls to HALA have not changed, it is up to the compiler to instantiate the corresponding templates with the correct types and handle all the necessary book-keeping.</li>
<li>The only other change is the switch from std::swap() to <a class="el" href="group__HALABLAS1.html#ga2809dfc1c6ae1f53eb9f59d68f23c7b0" title="Wrapper to BLAS xswap() methods. ">hala::vswap()</a> which makes a physical swap of the vector entries, since std::swap() cannot be called with different containers.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> precision, <span class="keyword">class</span> VectorLikeB, <span class="keyword">class</span> VectorLikeX&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="example__gauss__seidel_8cpp.html#aafcd9df6d4f5a468c02cfd2f8eebc6e5">solve_gauss_seidel_c</a>(<span class="keywordtype">int</span> max_iter,</div><div class="line">                          <span class="keyword">typename</span> std::vector&lt;precision&gt;::value_type stop_tolerance,</div><div class="line">                          <span class="keywordtype">int</span> num_rhs,</div><div class="line">                          std::vector&lt;precision&gt; <span class="keyword">const</span> &amp;A,</div><div class="line">                          VectorLikeB <span class="keyword">const</span> &amp;b,</div><div class="line">                          VectorLikeX &amp;&amp;x){</div><div class="line"></div><div class="line">    assert( num_rhs &gt; 0 );</div><div class="line">    assert( <a class="code" href="group__HALACUSTOM.html#gacb23ab0a92ecead8007cf9aa8dc972db">hala::get_size</a>(x) == <a class="code" href="group__HALACUSTOM.html#gacb23ab0a92ecead8007cf9aa8dc972db">hala::get_size</a>(b) );</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> N = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(<a class="code" href="group__HALACUSTOM.html#gacb23ab0a92ecead8007cf9aa8dc972db">hala::get_size</a>(x)) / num_rhs;</div><div class="line">    assert( A.size() == <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(N * N) );</div><div class="line"></div><div class="line">    precision error = 0.0;</div><div class="line">    <span class="keywordtype">int</span> iterations = 0;</div><div class="line"></div><div class="line">    <span class="keywordflow">do</span>{</div><div class="line">        std::vector&lt;precision&gt; xnew;</div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(x, xnew);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (num_rhs == 1){</div><div class="line">            <a class="code" href="group__HALABLAS2.html#gaeecc553d9de2eb43ab61941581af918a">hala::trmv</a>(<span class="charliteral">&#39;U&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, <span class="charliteral">&#39;U&#39;</span>, N, A, xnew);</div><div class="line">            <a class="code" href="group__HALABLAS1.html#ga3d8f14a164c86b89abbb4e7bfbdca660">hala::scal</a>(-1.0, xnew);</div><div class="line">        }<span class="keywordflow">else</span>{</div><div class="line">            <a class="code" href="group__HALABLAS3.html#ga76b9027b698b804e16553c0ad6f8f952">hala::trmm</a>(<span class="charliteral">&#39;L&#39;</span>, <span class="charliteral">&#39;U&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, <span class="charliteral">&#39;U&#39;</span>, N, num_rhs, -1.0, A, xnew);</div><div class="line">        }</div><div class="line"></div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(1.0, x, xnew);</div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(1.0, b, xnew);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (num_rhs == 1)</div><div class="line">            <a class="code" href="group__HALABLAS2.html#ga5277f0adc6762b3cd4adebe1b637b7f9">hala::trsv</a>(<span class="charliteral">&#39;L&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, N, A, xnew);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            <a class="code" href="group__HALABLAS3.html#gaafa45d25006e2c87ad9138fda8347b5a">hala::trsm</a>(<span class="charliteral">&#39;L&#39;</span>, <span class="charliteral">&#39;L&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, N, num_rhs, 1.0, A, xnew);</div><div class="line"></div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga2809dfc1c6ae1f53eb9f59d68f23c7b0">hala::vswap</a>(x, xnew);</div><div class="line"></div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(-1.0, x, xnew);</div><div class="line">        error = <a class="code" href="group__HALAWAXBLAS.html#ga329f68a7f474c1502564d9afe5c6c729">hala::batch_max_norm2</a>(num_rhs, xnew);</div><div class="line"></div><div class="line">        iterations++;</div><div class="line">    }<span class="keywordflow">while</span>(error &gt; stop_tolerance and iterations &lt; max_iter);</div><div class="line">}</div></div><!-- fragment --> <dl class="section user"><dt>Crank-Nicholson variant C</dt><dd>The variant C simulator now handles the padding and switches between different modes of the solver.<ul>
<li>Fewer than 6 states would trigger the use of level 2 solver with <a class="el" href="classhala_1_1wrapped__array.html" title="Wrapper around C-style arrays that can be passed to HALA templates. ">hala::wrapped_array</a> inputs for <b>x</b> and <b>b</b>.</li>
<li>Between 6 and 9 samples, the state and <b>rhs</b> will be padded; note that the extra padding does not interfere with the <a class="el" href="group__HALABLAS2.html#ga925bf0c14261ed419bb931e85658f6eb" title="Wrapper to BLAS general matrix-vector multiply xgemv(). ">hala::gemv()</a> and <a class="el" href="group__HALABLAS3.html#gae98fae51e118dc3682284a5d001cd946" title="Wrapper to BLAS general matrix multiply xgemm(). ">hala::gemm()</a> calls.</li>
<li>For 10 or more stages, the solver will use no padding and level 3 mode.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> precision&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="example__gauss__seidel_8cpp.html#a64b57a0011925129f3301deddbd705a5">integrate_c</a>(<span class="keywordtype">int</span> num_steps,</div><div class="line">                 <span class="keywordtype">int</span> max_iter,</div><div class="line">                 <span class="keyword">typename</span> std::vector&lt;precision&gt;::value_type stop_tolerance,</div><div class="line">                 std::vector&lt;precision&gt; <span class="keyword">const</span> &amp;op,</div><div class="line">                 std::vector&lt;precision&gt; &amp;state,</div><div class="line">                 <span class="keywordtype">int</span> num_states = 1){</div><div class="line">    <span class="comment">// Crank-Nicholson scheme (I - dt/2 * op) f^{n+1} = (I + dt/2 * op) f^n</span></div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> size = (int) state.size() / num_states;</div><div class="line">    assert( op.size() == (size_t) size * size );</div><div class="line">    assert( state.size() == (size_t) size * num_states );</div><div class="line"></div><div class="line">    precision dt = 1.0 / num_steps;</div><div class="line"></div><div class="line">    <span class="comment">// set update = ( I - dt/2 * op )</span></div><div class="line">    std::vector&lt;precision&gt; update;</div><div class="line">    <a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(op, update);</div><div class="line">    <a class="code" href="group__HALABLAS1.html#ga3d8f14a164c86b89abbb4e7bfbdca660">hala::scal</a>(-0.5 * dt, update); <span class="comment">// update = -0.5 * dt * op</span></div><div class="line"></div><div class="line">    std::vector&lt;precision&gt; ones(size, 1.0);</div><div class="line">    <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(size, 1.0, ones, 1, update, size+1); <span class="comment">// update += I</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> t=0; t&lt;num_steps/10; t++){</div><div class="line">        <span class="comment">// pad rhs (if necessary)</span></div><div class="line">        std::vector&lt;precision&gt; rhs = (num_states &gt; 5 and num_states &lt; 10) ?</div><div class="line">                                      std::vector&lt;precision&gt;(10 * size) :</div><div class="line">                                      std::vector&lt;precision&gt;();</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (num_states == 1)</div><div class="line">            <a class="code" href="group__HALABLAS2.html#ga925bf0c14261ed419bb931e85658f6eb">hala::gemv</a>(<span class="charliteral">&#39;N&#39;</span>, size, size, 0.5 * dt, op, state, 0.0, rhs);</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">            <a class="code" href="group__HALABLAS3.html#gae98fae51e118dc3682284a5d001cd946">hala::gemm</a>(<span class="charliteral">&#39;N&#39;</span>, <span class="charliteral">&#39;N&#39;</span>, size, num_states, size, 0.5 * dt, op, state, 0.0, rhs);</div><div class="line">        <a class="code" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">hala::axpy</a>(1.0, state, rhs);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (num_states &lt;= 5){</div><div class="line">            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_states; i++)</div><div class="line">                <a class="code" href="example__gauss__seidel_8cpp.html#aafcd9df6d4f5a468c02cfd2f8eebc6e5">solve_gauss_seidel_c</a>(max_iter, stop_tolerance, 1, update,</div><div class="line">                                     <a class="code" href="group__HALACPUENGINE.html#ga1754bbdc7b056afb54044fc35bd4d015">hala::wrap_array</a>(&amp;rhs[i * size], size),</div><div class="line">                                     <a class="code" href="group__HALACPUENGINE.html#ga1754bbdc7b056afb54044fc35bd4d015">hala::wrap_array</a>(&amp;state[i * size], size));</div><div class="line">        }<span class="keywordflow">else</span> <span class="keywordflow">if</span> (num_states &lt;10){</div><div class="line">            std::vector&lt;precision&gt; padded_state(10 * size);</div><div class="line">            <a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(state, padded_state); <span class="comment">// state determines the number of entries to copy</span></div><div class="line">            <a class="code" href="example__gauss__seidel_8cpp.html#aafcd9df6d4f5a468c02cfd2f8eebc6e5">solve_gauss_seidel_c</a>(max_iter, stop_tolerance, 10, update, rhs, padded_state);</div><div class="line">            <a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(num_states * size, padded_state, 1, state, 1);</div><div class="line">        }<span class="keywordflow">else</span>{</div><div class="line">            <a class="code" href="example__gauss__seidel_8cpp.html#aafcd9df6d4f5a468c02cfd2f8eebc6e5">solve_gauss_seidel_c</a>(max_iter, stop_tolerance, num_states, update, rhs, state);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Example1Remarks"></a></p><dl class="section user"><dt>Remarks</dt><dd>The specific tuning parameters would be very different between different systems; however, the general principles apply. The example serves to demonstrate the flexibility of the HALA interface that allows for a very general algorithm to be implemented and coupled with very specific tuning criteria with only a few well placed if-statements.</dd></dl>
<p><a class="anchor" id="Example1Results"></a></p><dl class="section user"><dt>Results</dt><dd>Experiments were performed on an Intel i9-9920X CPU with 12-cores and using the OpenBLAS library, on Ubuntu 18.04. The tuned implementation showed the greatest performance, although the specific tuning parameters would be heavily dependent on the system. Also note the inconsistencies in execution time when using different problem sizes, this is due to OpenBLAS switching between algorithms with different caching and parallel strategies. However, in each case, the implementation would most certainly outperform any manual implementation of the corresponding operations, even the forward substitution strategy often used in serial implementations of the Gauss-Seidel algorithm.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="example__gauss__seidel_8cpp.html#a78a394181a2ec486cda247b5ab57ed40">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>**){</div><div class="line">    <span class="keywordflow">if</span> (argc &gt; 1) <span class="keywordflow">return</span> 0; <span class="comment">// used to test the linker, ignore for the example</span></div><div class="line">    <span class="keywordtype">int</span> num_nodes = 1000;   <span class="comment">// number of discrete nodes</span></div><div class="line"></div><div class="line">    <span class="keyword">using</span> precision = double;</div><div class="line">    precision stop_tolerance = 1.E-3;</div><div class="line">    <span class="keywordtype">int</span> max_iter = 1000000;</div><div class="line"></div><div class="line">    <span class="comment">// initialize the state and the fractional-Laplacian operator</span></div><div class="line">    <span class="keyword">auto</span> laplacian = make_flaplace&lt;precision&gt;(num_nodes);</div><div class="line">    <span class="keyword">auto</span> state     = make_initial&lt;precision&gt;(num_nodes);</div><div class="line"></div><div class="line">    <a class="code" href="structhala_1_1chronometer.html">hala::chronometer</a> meter; <span class="comment">// used for benchmarking</span></div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Using BLAS level 2\n&quot;</span>;</div><div class="line">    meter.<a class="code" href="structhala_1_1chronometer.html#a4d8fa412a520e583eb0ecbb492d9fb3a">set_start</a>();</div><div class="line">    <a class="code" href="example__gauss__seidel_8cpp.html#a1d04ad7c3d52154908466f2dea0997a8">integrate_a</a>(1000, max_iter, stop_tolerance, laplacian, state);</div><div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> duration = meter.get_end();</div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot; Integrated&quot;</span> &lt;&lt; setw(4) &lt;&lt; <span class="stringliteral">&quot;one&quot;</span> &lt;&lt; <span class="stringliteral">&quot; in&quot;</span> &lt;&lt; setw(6) &lt;&lt; duration &lt;&lt; <span class="stringliteral">&quot; milliseconds.&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Using BLAS level 3\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> num_states : std::vector&lt;int&gt;{1, 5, 10, 100}){</div><div class="line">        <span class="comment">// the multi-state is just multiple identical states lumped together</span></div><div class="line">        <span class="comment">// normally each state would be different, but that is beyond the scope here</span></div><div class="line">        state = make_initial&lt;precision&gt;(num_nodes);</div><div class="line">        std::vector&lt;precision&gt; multistate(num_nodes * num_states);</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_states; i++) <a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(state, &amp;multistate[i * num_nodes]);</div><div class="line"></div><div class="line">        meter.set_start();</div><div class="line">        <a class="code" href="example__gauss__seidel_8cpp.html#a455b62e03dd477dd002f461d34b97f49">integrate_b</a>(1000, max_iter, stop_tolerance, laplacian, multistate, num_states);</div><div class="line">        duration = meter.get_end();</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot; Integrated&quot;</span> &lt;&lt; setw(4) &lt;&lt; num_states &lt;&lt; <span class="stringliteral">&quot; in&quot;</span> &lt;&lt; setw(6) &lt;&lt; duration &lt;&lt; <span class="stringliteral">&quot; milliseconds.&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line"></div><div class="line">    cout &lt;&lt; <span class="stringliteral">&quot;Using BLAS dynamic\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> num_states : std::vector&lt;int&gt;{1, 5, 10, 100}){</div><div class="line">        state = make_initial&lt;precision&gt;(num_nodes);</div><div class="line">        std::vector&lt;precision&gt; multistate(num_nodes * num_states);</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;num_states; i++) <a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(state, &amp;multistate[i * num_nodes]);</div><div class="line"></div><div class="line">        meter.set_start();</div><div class="line">        <a class="code" href="example__gauss__seidel_8cpp.html#a64b57a0011925129f3301deddbd705a5">integrate_c</a>(1000, max_iter, stop_tolerance, laplacian, multistate, num_states);</div><div class="line">        duration = meter.get_end();</div><div class="line">        cout &lt;&lt; <span class="stringliteral">&quot; Integrated&quot;</span> &lt;&lt; setw(4) &lt;&lt; num_states &lt;&lt; <span class="stringliteral">&quot; in&quot;</span> &lt;&lt; setw(6) &lt;&lt; duration &lt;&lt; <span class="stringliteral">&quot; milliseconds.&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div></div><!-- fragment --> <div class="fragment"><div class="line">Using BLAS level 2</div><div class="line"> Integrated one in  2163 milliseconds.</div><div class="line">Using BLAS level 3</div><div class="line"> Integrated   1 in 10745 milliseconds.</div><div class="line"> Integrated   5 in 15074 milliseconds.</div><div class="line"> Integrated  10 in 15019 milliseconds.</div><div class="line"> Integrated 100 in 21984 milliseconds.</div><div class="line">Using BLAS dynamic</div><div class="line"> Integrated   1 in  2189 milliseconds.</div><div class="line"> Integrated   5 in 11076 milliseconds.</div><div class="line"> Integrated  10 in 14948 milliseconds.</div><div class="line"> Integrated 100 in 24128 milliseconds.</div></div><!-- fragment --> <h2 class="groupheader">Function Documentation</h2>
<a id="gad5ce415f7599fc854279583c857ec2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5ce415f7599fc854279583c857ec2fa">&#9670;&nbsp;</a></span>make_domain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename precision &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; precision &gt; make_domain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a vector that represents the domain. </p>
<p>Divides the domain [0, 1] into N intervals and returns a vector with the mid-points of all intervals. </p>

</div>
</div>
<a id="gab51390b4d9d88a835db941041dfbb486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab51390b4d9d88a835db941041dfbb486">&#9670;&nbsp;</a></span>make_flaplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename precision &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; precision &gt; make_flaplace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a simple discrete approximation to the fractional Laplacian operator. </p>
<p>The numerical properties of the discretization scheme is not in scope of this example, the point is that the resulting approximation uses a dense matrix of size N by N. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div> -->
</body>
</html>
