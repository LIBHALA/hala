<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HALA: Handy Accelerated Linear Algebra v1.0: Example of VEX usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hala.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"/>
                </a> 1.8.13
    </div>
   <div id="projectname">HALA: Handy Accelerated Linear Algebra v1.0
   <!--         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 -->
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__HALAEXAMPLE3.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">Example of VEX usage<div class="ingroups"><a class="el" href="group__HALAEXAMPLE.html">HALA Examples</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Example of VEX usage:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__HALAEXAMPLE3.png" border="0" alt="" usemap="#group____HALAEXAMPLE3"/>
<map name="group____HALAEXAMPLE3" id="group____HALAEXAMPLE3">
<area shape="rect" id="node2" href="group__HALAEXAMPLE.html" title="HALA Examples" alt="" coords="5,5,124,32"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:example__vex_8cpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="example__vex_8cpp.html">example_vex.cpp</a></td></tr>
<tr class="memdesc:example__vex_8cpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Example of using the BLAS module of HALA. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>Example 3</dt><dd>Example 3 demonstrates the usage of the <a class="el" href="group__HALAVEX.html">HALA Advanced Vector Extensions</a> module that utilizes intrinsic functions to perform multiple floating point operations in a single instruction. The data for each operation has to be stored in packed structures using either <a class="el" href="structhala_1_1mmpack.html" title="Wrapper for the aligned memory used by intrinsic methods. ">hala::mmpack</a> or <a class="el" href="structhala_1_1bind__pack.html" title="Binds a memory slice to an address, constructor reads from the address, destructor writes back...">hala::bind_pack</a>, and the standard arithmetic operations are supported. The example uses ordinary differential equations with different random parameters, multiple equations need to be integrated and statistics is collected from the data. The vectorization operations are a natural way to lump several equations together and significantly increase the performance.</dd></dl>
<dl class="section user"><dt></dt><dd>The example is divided into several sections:<ul>
<li><a class="el" href="group__HALAEXAMPLE3.html#Example3Problem">Problem Setup</a></li>
<li><a class="el" href="group__HALAEXAMPLE3.html#Example3Basic">Basic Implementation</a></li>
<li><a class="el" href="group__HALAEXAMPLE3.html#Example3Vector">Vectorized Implementation</a></li>
<li><a class="el" href="group__HALAEXAMPLE3.html#Example3Perform">Performance Boost Comments</a></li>
</ul>
</dd></dl>
<p><a class="anchor" id="Example3Problem"></a></p><dl class="section user"><dt>Problem Setup</dt><dd>Consider the SIR model defined by the following system of differential equations: <p class="formulaDsp">
\begin{eqnarray*} \frac{dS}{dt} &amp;=&amp; - \beta I S \\ \frac{dI}{dt} &amp;=&amp; \beta I S - \gamma I \\ \frac{dR}{dt} &amp;=&amp; \gamma I \end{eqnarray*}
</p>
 We use the initial conditions \( S = 0.99, I = 0.01, R = 0 \) all defined at \( t = 0\). The parameters \( \beta, \gamma \) are uniformly distributed over \( (0.1, 0.3) \).</dd></dl>
<dl class="section user"><dt></dt><dd>Given a large sample of random values for \( \beta, \gamma \) we seek to compute the percentage of samples that will result in \( I &lt; 0.01 \) at \( t = 100 \).</dd></dl>
<dl class="section user"><dt></dt><dd>The integration is done using Rungeâ€“Kutta order 4 method. For an autonomous equation \( \frac{dx}{dt} = f(x) \), the method advances from \( x(t) \to x(t + \Delta t) \) using the 4 steps: <p class="formulaDsp">
\begin{eqnarray*} k_1 &amp;=&amp; f(x) \\ k_2 &amp;=&amp; f(x + 0.5 \Delta t k_1) \\ k_3 &amp;=&amp; f(x + 0.5 \Delta t k_2) \\ k_4 &amp;=&amp; f(x + \Delta t k_4) \\ x(t + \Delta t) &amp;\approx &amp; x + \frac{\Delta t}{6} \left( k_1 + 2 k_2 + 2 k_3 + k_4 \right) \end{eqnarray*}
</p>
 The specific interpretation of the equations and the properties of the integration scheme are not of focus. This example demonstrates an efficient way to integrate the equations.</dd></dl>
<p><a class="anchor" id="Example3Basic"></a></p><dl class="section user"><dt>Basic Implementation</dt><dd>Vectors with random values for the parameters are generated in <a class="el" href="example__vex_8cpp.html#a2c3f6775325c30275d11c6abee2db6a0" title="[Example_03 vector] ">main()</a> and passed into the compute function. Two nested for-loops compute the result, the outer loop goes over all entries of the parameter vectors, while the inner loop implements the Runge-Kutta methods. At the end of the outer loop, the state for <b>I</b> is compared to the threshold and if lower the corresponding count is incremented.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> <a class="code" href="example__vex_8cpp.html#a0b4dd43e09f07ed657c4983c176350f1">integrate_sir_basic</a>(std::vector&lt;double&gt; <span class="keyword">const</span> &amp;beta, std::vector&lt;double&gt; <span class="keyword">const</span> &amp;gamma){</div><div class="line">    <span class="keywordtype">size_t</span> <span class="keyword">const</span> num_samples = beta.size();</div><div class="line">    <span class="keywordtype">size_t</span> num_lower = 0;</div><div class="line">    assert(beta.size() == gamma.size());</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> j=0; j&lt;num_samples; j++){</div><div class="line">        <span class="comment">// set the initial conditions</span></div><div class="line">        <span class="keywordtype">double</span> r = 0.0, i = 0.01, s = 0.99;</div><div class="line">        <span class="comment">// load the current rates</span></div><div class="line">        <span class="keywordtype">double</span> b = beta[j], g = gamma[j];</div><div class="line"></div><div class="line">        <span class="keywordtype">double</span> dt = 1.E-2, dt2 = 0.5 * dt;</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> t = 0; t &lt; 10000; t++){</div><div class="line">            <span class="keywordtype">double</span> k1_s = - b * i * s;</div><div class="line">            <span class="keywordtype">double</span> k1_i = b * i * s - g * i;</div><div class="line">            <span class="keywordtype">double</span> k1_r = g * i;</div><div class="line"></div><div class="line">            <span class="keywordtype">double</span> k2_s = - b * (i + dt2 * k1_i) * (s + dt2 * k1_s);</div><div class="line">            <span class="keywordtype">double</span> k2_i = b * (i + dt2 * k1_i) * (s + dt2 * k1_s) - g * (i + dt2 * k1_i);</div><div class="line">            <span class="keywordtype">double</span> k2_r = g * (i + dt2 * k1_i);</div><div class="line"></div><div class="line">            <span class="keywordtype">double</span> k3_s = - b * (i + dt2 * k2_i) * (s + dt2 * k2_s);</div><div class="line">            <span class="keywordtype">double</span> k3_i = b * (i + dt2 * k2_i) * (s + dt2 * k2_s) - g * (i + dt2 * k2_i);</div><div class="line">            <span class="keywordtype">double</span> k3_r = g * (i + dt2 * k2_i);</div><div class="line"></div><div class="line">            <span class="keywordtype">double</span> k4_s = - b * (i + dt * k3_i) * (s + dt * k3_s);</div><div class="line">            <span class="keywordtype">double</span> k4_i = b * (i + dt * k3_i) * (s + dt * k3_s) - g * (i + dt * k3_i);</div><div class="line">            <span class="keywordtype">double</span> k4_r = g * (i + dt * k3_i);</div><div class="line"></div><div class="line">            s = s + dt * (k1_s + 2.0 * k2_s + 2.0 * k3_s + k4_s) / 6.0;</div><div class="line">            i = i + dt * (k1_i + 2.0 * k2_i + 2.0 * k3_i + k4_i) / 6.0;</div><div class="line">            r = r + dt * (k1_r + 2.0 * k2_r + 2.0 * k3_r + k4_r) / 6.0;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (i &lt; 0.01) num_lower++;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(num_lower) / static_cast&lt;double&gt;(num_samples);</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Example3Vector"></a></p><dl class="section user"><dt>Vectorized Implementation</dt><dd>The vectorized implementation differs in only a few ways:<ul>
<li>The <a class="el" href="hala__vex_8hpp_source.html">hala_vex.hpp</a> header needs to be included in the code.</li>
<li>The method is templated on the register type, although the <b>reg</b> parameter can be omitted from all calls and HALA will default to the largest register that has been enabled by the current set of flags.</li>
<li>The size of the <b>beta</b> and <b>gamma</b> vectors is restricted to a multiple of the vector stride, i.e., the number of doubles that can fit in the selected register. The restriction can be removed if we have a second loop that can handle the remainder, in which case the body of the loop can be moved to a separate template to avoid repeating the Runge-Kutta code.</li>
<li>The rest of the code is changed only slightly, the <b>s</b>, <b>i</b> and <b>r</b> variables are replaced by packs of doubles, the hala::load method is used to load multiple entries from the <b>beta</b> and <b>gamma</b> vectors, and all the <b>k</b> variables are defined as <b>auto</b> type which will be resolved as instances of <a class="el" href="structhala_1_1mmpack.html" title="Wrapper for the aligned memory used by intrinsic methods. ">hala::mmpack</a>.</li>
<li>The if-condition to count the number of lower results has to loop over the entries in the vector variables. The direct indexing of the entries in a <a class="el" href="structhala_1_1mmpack.html" title="Wrapper for the aligned memory used by intrinsic methods. ">hala::mmpack</a> is relatively slow, but the one time access is negligible in the overall cost.</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;hala::regtype reg = hala::default_regtype&gt;</div><div class="line"><span class="keywordtype">double</span> <a class="code" href="example__vex_8cpp.html#a021ff36a8d95a89dd4cb8f5edefe7da4">integrate_sir_vex</a>(std::vector&lt;double&gt; <span class="keyword">const</span> &amp;beta, std::vector&lt;double&gt; <span class="keyword">const</span> &amp;gamma){</div><div class="line">    <span class="keyword">using</span> mmpack = <a class="code" href="structhala_1_1mmpack.html">hala::mmpack&lt;double, reg&gt;</a>;</div><div class="line">    <span class="keywordtype">size_t</span> <span class="keyword">const</span> num_samples = beta.size();</div><div class="line">    <span class="keywordtype">size_t</span> num_lower = 0;</div><div class="line">    assert(beta.size() == gamma.size());</div><div class="line">    <a class="code" href="group__HALACORE.html#gae23b85f0bdb359210cfcb187b5b66080">hala::runtime_assert</a>(num_samples % mmpack::stride == 0,</div><div class="line">                         <span class="stringliteral">&quot;the size of beta and gamma must be divisible by the pack stride&quot;</span>);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> j=0; j&lt;num_samples; j += mmpack::stride){</div><div class="line">        mmpack s = 0.99;</div><div class="line">        mmpack i = 0.01;</div><div class="line">        mmpack r = 0.0;</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> b = hala::mmload&lt;reg&gt;(&amp;beta[j]);</div><div class="line">        <span class="keyword">auto</span> g = hala::mmload&lt;reg&gt;(&amp;gamma[j]);</div><div class="line"></div><div class="line">        mmpack dt = 1.E-2;</div><div class="line">        mmpack dt2 = 0.5 * dt;</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> t = 0; t &lt; 10000; t++){</div><div class="line">            <span class="keyword">auto</span> k1_s = -1.0 * b * i * s;</div><div class="line">            <span class="keyword">auto</span> k1_i = b * i * s - g * i;</div><div class="line">            <span class="keyword">auto</span> k1_r = g * i;</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> k2_s = -1.0 * b * (i + dt2 * k1_i) * (s + dt2 * k1_s);</div><div class="line">            <span class="keyword">auto</span> k2_i = b * (i + dt2 * k1_i) * (s + dt2 * k1_s) - g * (i + dt2 * k1_i);</div><div class="line">            <span class="keyword">auto</span> k2_r = g * (i + dt2 * k1_i);</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> k3_s = -1.0 * b * (i + dt2 * k2_i) * (s + dt2 * k2_s);</div><div class="line">            <span class="keyword">auto</span> k3_i = b * (i + dt2 * k2_i) * (s + dt2 * k2_s) - g * (i + dt2 * k2_i);</div><div class="line">            <span class="keyword">auto</span> k3_r = g * (i + dt2 * k2_i);</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> k4_s = -1.0 * b * (i + dt * k3_i) * (s + dt * k3_s);</div><div class="line">            <span class="keyword">auto</span> k4_i = b * (i + dt * k3_i) * (s + dt * k3_s) - g * (i + dt * k3_i);</div><div class="line">            <span class="keyword">auto</span> k4_r = g * (i + dt * k3_i);</div><div class="line"></div><div class="line">            s += dt * (k1_s + 2.0 * k2_s + 2.0 * k3_s + k4_s) / 6.0;</div><div class="line">            i += dt * (k1_i + 2.0 * k2_i + 2.0 * k3_i + k4_i) / 6.0;</div><div class="line">            r += dt * (k1_r + 2.0 * k2_r + 2.0 * k3_r + k4_r) / 6.0;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> t = 0; t &lt; i.stride; t++)</div><div class="line">            <span class="keywordflow">if</span> (i[t] &lt; 0.01) num_lower++;</div><div class="line"></div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(num_lower) / static_cast&lt;double&gt;(num_samples);</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Example3Perform"></a></p><dl class="section user"><dt>Performance Boost Comments</dt><dd>Running the test on an AMD Ryzen 3900X CPU yields the following results: <div class="fragment"><div class="line">    Mode              Result        Milliseconds</div><div class="line">  basic:        8.837891e-01                 186</div><div class="line">    def:        8.837891e-01                  46</div><div class="line">   <a class="code" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea334c4a4c42fdb79d7ebc3e73b517e6f8">none</a>:        8.837891e-01                 181</div><div class="line">128-bit:        8.837891e-01                  90</div><div class="line">256-bit:        8.837891e-01                  46</div></div><!-- fragment --> The specific results will be affected by the CPU type and frequency, memory speed, and other factors; however, the observed behavior is what we expect.</dd></dl>
<ul>
<li>The basic and vectorized implementations yield identical result, in some cases rounding error may be different but it should not be significant for a given application.</li>
<li>Compared the basis implementation, the 128-bit and 256-bit registers yield respective speedup of 2 and 4 which is proportional to the register size (note that double has 64-bits).</li>
<li>The default register (<b>def</b>) is selected as the largest 256-bit one.</li>
<li>The implementation using <a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea334c4a4c42fdb79d7ebc3e73b517e6f8" title="No vectorization, i.e., generate code equivalent to the serial code. ">hala::regtype::none</a> is equivalent to the basic implementation, thus only one implementation is needed even if extended registers are not available.</li>
</ul>
<dl class="section user"><dt></dt><dd>The timing is very sensitive to the optimization flags, make sure to use <b>-O3</b> optimization which will strip away all the fluff brought by the HALA templates and will leave only the direct calls to the intrinsic functions. Without the <b>-O3</b> optimization, the vectorized implementation will be significantly slower.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="example__gauss__seidel_8cpp.html#a78a394181a2ec486cda247b5ab57ed40">main</a>(<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**){</div><div class="line">    cout &lt;&lt; std::scientific; cout.precision(6);</div><div class="line"></div><div class="line">    <span class="comment">// generate random distribution for beta and gamma</span></div><div class="line">    std::minstd_rand park_miller(42);</div><div class="line">    std::uniform_real_distribution&lt;double&gt; unif_distribution(0.1, 0.3);</div><div class="line"></div><div class="line">    constexpr <span class="keywordtype">size_t</span> num_samples = 1024; <span class="comment">// must be multiple of the default stride</span></div><div class="line">    std::vector&lt;double&gt; beta(num_samples), gamma(num_samples);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;b : beta)  b = unif_distribution(park_miller);</div><div class="line">    <span class="keywordflow">for</span>(<span class="keyword">auto</span> &amp;g : gamma) g = unif_distribution(park_miller);</div><div class="line"></div><div class="line">    <a class="code" href="structhala_1_1chronometer.html">hala::chronometer</a> meter; <span class="comment">// times the calls to integrate the equations</span></div><div class="line"></div><div class="line">    <span class="comment">// basic implementation with no vectorization</span></div><div class="line">    meter.<a class="code" href="structhala_1_1chronometer.html#a4d8fa412a520e583eb0ecbb492d9fb3a">set_start</a>();</div><div class="line">    <span class="keywordtype">double</span> result_basic = <a class="code" href="example__vex_8cpp.html#a0b4dd43e09f07ed657c4983c176350f1">integrate_sir_basic</a>(beta, gamma);</div><div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> duration_basic = meter.<a class="code" href="structhala_1_1chronometer.html#a411ba500e2322086f19c0501c781ddc5">get_end</a>();</div><div class="line"></div><div class="line">    <span class="comment">// implementation with vectorization and default registers</span></div><div class="line">    meter.<a class="code" href="structhala_1_1chronometer.html#a4d8fa412a520e583eb0ecbb492d9fb3a">set_start</a>();</div><div class="line">    <span class="keywordtype">double</span> result_vector = <a class="code" href="example__vex_8cpp.html#a021ff36a8d95a89dd4cb8f5edefe7da4">integrate_sir_vex</a>(beta, gamma);</div><div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> duration_vector = meter.<a class="code" href="structhala_1_1chronometer.html#a411ba500e2322086f19c0501c781ddc5">get_end</a>();</div><div class="line"></div><div class="line">    cout &lt;&lt; setw(10) &lt;&lt; <span class="stringliteral">&quot;Mode&quot;</span> &lt;&lt; setw(20) &lt;&lt; <span class="stringliteral">&quot;Result&quot;</span> &lt;&lt; setw(20) &lt;&lt; <span class="stringliteral">&quot;Milliseconds&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    cout &lt;&lt; setw(10) &lt;&lt; <span class="stringliteral">&quot;basic:&quot;</span> &lt;&lt; setw(20) &lt;&lt; result_basic</div><div class="line">         &lt;&lt; setw(20) &lt;&lt; duration_basic &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">    cout &lt;&lt; setw(10) &lt;&lt; <span class="stringliteral">&quot;default:&quot;</span> &lt;&lt; setw(20) &lt;&lt; result_vector</div><div class="line">         &lt;&lt; setw(20) &lt;&lt; duration_vector &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"></div><div class="line">    <span class="comment">// implementation using the templated vectorized code but removing actual vectorization</span></div><div class="line">    <span class="comment">// i.e., defaulting to an implementation that is equivalent to the basic mode</span></div><div class="line">    meter.<a class="code" href="structhala_1_1chronometer.html#a4d8fa412a520e583eb0ecbb492d9fb3a">set_start</a>();</div><div class="line">    <span class="keywordtype">double</span> result_none = integrate_sir_vex&lt;hala::regtype::none&gt;(beta, gamma);</div><div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> duration_none = meter.<a class="code" href="structhala_1_1chronometer.html#a411ba500e2322086f19c0501c781ddc5">get_end</a>();</div><div class="line">    cout &lt;&lt; setw(10) &lt;&lt; <span class="stringliteral">&quot;none:&quot;</span> &lt;&lt; setw(20) &lt;&lt; result_none</div><div class="line">         &lt;&lt; setw(20) &lt;&lt; duration_none &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"></div><div class="line"><span class="preprocessor">    #ifdef __SSE3__</span></div><div class="line">    <span class="comment">// the __SSE3__ macro is enabled by the -msse3 flag and enables the 128-bit registers</span></div><div class="line">    meter.<a class="code" href="structhala_1_1chronometer.html#a4d8fa412a520e583eb0ecbb492d9fb3a">set_start</a>();</div><div class="line">    <span class="keywordtype">double</span> result_sse = integrate_sir_vex&lt;hala::regtype::sse&gt;(beta, gamma);</div><div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> duration_sse = meter.<a class="code" href="structhala_1_1chronometer.html#a411ba500e2322086f19c0501c781ddc5">get_end</a>();</div><div class="line">    cout &lt;&lt; setw(10) &lt;&lt; <span class="stringliteral">&quot;128-bit:&quot;</span> &lt;&lt; setw(20) &lt;&lt; result_sse</div><div class="line">         &lt;&lt; setw(20) &lt;&lt; duration_sse &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">    #ifdef __AVX__</span></div><div class="line">    <span class="comment">// the __SSE3__ macro is enabled by the -mavx flag and enables the 256-bit registers</span></div><div class="line">    meter.<a class="code" href="structhala_1_1chronometer.html#a4d8fa412a520e583eb0ecbb492d9fb3a">set_start</a>();</div><div class="line">    <span class="keywordtype">double</span> result_avx = integrate_sir_vex&lt;hala::regtype::avx&gt;(beta, gamma);</div><div class="line">    <span class="keywordtype">long</span> <span class="keywordtype">long</span> duration_avx = meter.<a class="code" href="structhala_1_1chronometer.html#a411ba500e2322086f19c0501c781ddc5">get_end</a>();</div><div class="line">    cout &lt;&lt; setw(10) &lt;&lt; <span class="stringliteral">&quot;256-bit:&quot;</span> &lt;&lt; setw(20) &lt;&lt; result_avx</div><div class="line">         &lt;&lt; setw(20) &lt;&lt; duration_avx &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><span class="preprocessor">    #endif</span></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div> -->
</body>
</html>
