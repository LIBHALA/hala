<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HALA: Handy Accelerated Linear Algebra v1.0: HALA LAPACK Wrapper Templates</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hala.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"/>
                </a> 1.8.13
    </div>
   <div id="projectname">HALA: Handy Accelerated Linear Algebra v1.0
   <!--         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 -->
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__HALALAPACK.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HALA LAPACK Wrapper Templates</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for HALA LAPACK Wrapper Templates:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__HALALAPACK.png" border="0" alt="" usemap="#group____HALALAPACK"/>
<map name="group____HALALAPACK" id="group____HALALAPACK">
<area shape="rect" id="node1" href="group__HALALAPACKPLU.html" title="LAPACK solver templates" alt="" coords="220,13,395,39"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__HALALAPACKPLU"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALALAPACKPLU.html">LAPACK solver templates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:hala__lapack_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hala__lapack_8hpp.html">hala_lapack.hpp</a></td></tr>
<tr class="memdesc:hala__lapack_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">HALA wrapper for LAPACK methods. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga47aa56f6ea4aef498777e9995ba07d45"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeB &gt; </td></tr>
<tr class="memitem:ga47aa56f6ea4aef498777e9995ba07d45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#ga47aa56f6ea4aef498777e9995ba07d45">hala::gels</a> (char type, int M, int N, int num_rhs, VectorLikeA &amp;A, VectorLikeB &amp;B, int lda=-1, int ldb=-1)</td></tr>
<tr class="memdesc:ga47aa56f6ea4aef498777e9995ba07d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to LAPACK linear least-squares solver xGELS().  <a href="group__HALALAPACK.html#ga47aa56f6ea4aef498777e9995ba07d45">More...</a><br /></td></tr>
<tr class="separator:ga47aa56f6ea4aef498777e9995ba07d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64dc258ffa5840023abf4d8adf849655"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeS &gt; </td></tr>
<tr class="memitem:ga64dc258ffa5840023abf4d8adf849655"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#ga64dc258ffa5840023abf4d8adf849655">hala::svd</a> (int M, int N, VectorLikeA &amp;A, VectorLikeS &amp;S, int lda=-1)</td></tr>
<tr class="memdesc:ga64dc258ffa5840023abf4d8adf849655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to LAPACK singular value decomposition xGESVD(), compute the singular values only.  <a href="group__HALALAPACK.html#ga64dc258ffa5840023abf4d8adf849655">More...</a><br /></td></tr>
<tr class="separator:ga64dc258ffa5840023abf4d8adf849655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad70066bb270b888e700d5659a637f561"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeS , class VectorLikeU , class VectorLikeUH &gt; </td></tr>
<tr class="memitem:gad70066bb270b888e700d5659a637f561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#gad70066bb270b888e700d5659a637f561">hala::svd</a> (int M, int N, VectorLikeA &amp;A, VectorLikeS &amp;S, VectorLikeU &amp;U, VectorLikeUH &amp;VH, int lda=-1, int ldu=-1, int ldvh=-1)</td></tr>
<tr class="memdesc:gad70066bb270b888e700d5659a637f561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to LAPACK singular value decomposition xGESVD(), compute the singular values only.  <a href="group__HALALAPACK.html#gad70066bb270b888e700d5659a637f561">More...</a><br /></td></tr>
<tr class="separator:gad70066bb270b888e700d5659a637f561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16ce5c724f1c0b10fcc87f0ad95ea162"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeP , class VectorLikeB &gt; </td></tr>
<tr class="memitem:ga16ce5c724f1c0b10fcc87f0ad95ea162"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#ga16ce5c724f1c0b10fcc87f0ad95ea162">hala::gesv</a> (int N, int num_rhs, VectorLikeA &amp;A, VectorLikeP &amp;ipiv, VectorLikeB &amp;B, int lda=-1, int ldb=-1)</td></tr>
<tr class="memdesc:ga16ce5c724f1c0b10fcc87f0ad95ea162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to LAPACK general solver using PLU factorization xGESV().  <a href="group__HALALAPACK.html#ga16ce5c724f1c0b10fcc87f0ad95ea162">More...</a><br /></td></tr>
<tr class="separator:ga16ce5c724f1c0b10fcc87f0ad95ea162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4eb682a3828328bab61cab15a0adc0d"><td class="memTemplParams" colspan="2"><a id="gaa4eb682a3828328bab61cab15a0adc0d"></a>
template&lt;class VectorLikeA &gt; </td></tr>
<tr class="memitem:gaa4eb682a3828328bab61cab15a0adc0d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#gaa4eb682a3828328bab61cab15a0adc0d">hala::condition_number</a> (int N, VectorLikeA const &amp;A, int lda=-1)</td></tr>
<tr class="memdesc:gaa4eb682a3828328bab61cab15a0adc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the condition number of a <b>N</b> by <b>N</b> non-singular matrix, requires an internal copy of <b>A</b>. <br /></td></tr>
<tr class="separator:gaa4eb682a3828328bab61cab15a0adc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f9acfb7c7000a9e4f67cf79516bcd9"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA &gt; </td></tr>
<tr class="memitem:gad7f9acfb7c7000a9e4f67cf79516bcd9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#gad7f9acfb7c7000a9e4f67cf79516bcd9">hala::geqr_opt_size</a> (int M, int N, VectorLikeA &amp;&amp;A, int lda)</td></tr>
<tr class="memdesc:gad7f9acfb7c7000a9e4f67cf79516bcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the required size of the Q factor and workspace used by xgeqr().  <a href="group__HALALAPACK.html#gad7f9acfb7c7000a9e4f67cf79516bcd9">More...</a><br /></td></tr>
<tr class="separator:gad7f9acfb7c7000a9e4f67cf79516bcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c7b7463bb42548654b87c5f6415cd88"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA &gt; </td></tr>
<tr class="memitem:ga1c7b7463bb42548654b87c5f6415cd88"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#ga1c7b7463bb42548654b87c5f6415cd88">hala::geqr_min_size</a> (int M, int N, VectorLikeA &amp;&amp;A, int lda)</td></tr>
<tr class="memdesc:ga1c7b7463bb42548654b87c5f6415cd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the required size of the Q factor and workspace used by xgeqr().  <a href="group__HALALAPACK.html#ga1c7b7463bb42548654b87c5f6415cd88">More...</a><br /></td></tr>
<tr class="separator:ga1c7b7463bb42548654b87c5f6415cd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga533c0c95cc992345d370ef35d7085504"><td class="memTemplParams" colspan="2">template&lt;bool use_opt = true, class VectorLikeA , class VectorLikeT &gt; </td></tr>
<tr class="memitem:ga533c0c95cc992345d370ef35d7085504"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#ga533c0c95cc992345d370ef35d7085504">hala::geqr</a> (int M, int N, VectorLikeA &amp;&amp;A, int lda, VectorLikeT &amp;&amp;T)</td></tr>
<tr class="memdesc:ga533c0c95cc992345d370ef35d7085504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around Lapack xgeqr() for QR factorization.  <a href="group__HALALAPACK.html#ga533c0c95cc992345d370ef35d7085504">More...</a><br /></td></tr>
<tr class="separator:ga533c0c95cc992345d370ef35d7085504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40f6bc2df70774c39bfe2490ad7b2f72"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeT , class VectorLikeC &gt; </td></tr>
<tr class="memitem:ga40f6bc2df70774c39bfe2490ad7b2f72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#ga40f6bc2df70774c39bfe2490ad7b2f72">hala::gemqr</a> (char side, char trans, int M, int N, int K, VectorLikeA const &amp;A, int lda, VectorLikeT const &amp;T, int tsize, VectorLikeC &amp;&amp;C, int ldc)</td></tr>
<tr class="memdesc:ga40f6bc2df70774c39bfe2490ad7b2f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around Lapack xgemqr() for multiplication by a QR factor.  <a href="group__HALALAPACK.html#ga40f6bc2df70774c39bfe2490ad7b2f72">More...</a><br /></td></tr>
<tr class="separator:ga40f6bc2df70774c39bfe2490ad7b2f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>HALA LAPACK Wrapper Templates</dt><dd>A set of templates that wrap around LAPACK functions providing generality, overloads and error checking similar to the <a class="el" href="group__HALABLAS.html">HALA BLAS Wrapper Templates</a>. Currently, only a small subset of LAPACK methods is included in HALA and there is no support for engine overloads or GPUs. </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga47aa56f6ea4aef498777e9995ba07d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47aa56f6ea4aef498777e9995ba07d45">&#9670;&nbsp;</a></span>gels()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeA , class VectorLikeB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::gels </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeB &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to LAPACK linear least-squares solver xGELS(). </p>
<dl class="section user"><dt>Type 'N', with M &gt;= N</dt><dd>Solves the over-determined system of equations \( \min_{X} \| B - A X \|_2 \)<ul>
<li><b>A</b> is column-major of size M (rows) by N (columns), or lda by N</li>
<li><b>A</b> is overwritten by the matrix QR factorization (see LAPACK dgeqrf function)</li>
<li><b>B</b> is column-major of size M (rows) by num_rhs (columns), or ldb by num_rhs</li>
<li><b>B</b> is overwritten with the solution and residual norm for each column<ul>
<li>rows 1:N hold the solution to the minimization problem</li>
<li>the 2-norm of rows N+1:M is the residual norm for the corresponding column</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Type 'T', with M &lt; N</dt><dd>Solves the over-determined system of equations \( \min_{X} \| B - A^T X \|_2 \)<ul>
<li><b>A</b> is column-major of size M (rows) by N (columns), or lda by N</li>
<li><b>A</b> is overwritten by the matrix LQ factorization (see LAPACK dgelqf function)</li>
<li><b>B</b> is column-major of size N (rows) by num_rhs (columns), or ldb by num_rhs</li>
<li><b>B</b> is overwritten with the solution and residual norm for each column<ul>
<li>rows 1:M hold the solution to the minimization problem</li>
<li>the 2-norm of rows M+1:N is the residual norm for the corresponding column</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Type 'N', with M &lt; N</dt><dd>Find the minimum norm solution to under-determined system \( A X = B \)<ul>
<li><b>A</b> is column-major of size M (rows) by N (columns), or lda by N</li>
<li><b>A</b> is overwritten by the matrix LQ factorization (see LAPACK dgelqf function)</li>
<li><b>B</b> is column-major of size N (rows) by num_rhs (columns), or ldb by num_rhs</li>
<li><b>B</b> is overwritten with the minimum norm solution (solution has size N)</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Type 'T', with M &gt;= N</dt><dd>Find the minimum norm solution to under-determined system \( A^T X = B \)<ul>
<li><b>A</b> is column-major of size M (rows) by N (columns), or lda by N</li>
<li><b>A</b> is overwritten by the matrix QR factorization (see LAPACK dgeqrf function)</li>
<li><b>B</b> is column-major of size M (rows) by num_rhs (columns), or ldb by num_rhs</li>
<li><b>B</b> is overwritten with the minimum norm solution (solution has size M) </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga64dc258ffa5840023abf4d8adf849655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64dc258ffa5840023abf4d8adf849655">&#9670;&nbsp;</a></span>svd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeA , class VectorLikeS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::svd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeS &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper to LAPACK singular value decomposition xGESVD(), compute the singular values only. </p>
<p>Computes the singular values of the general <b>M</b> by <b>N</b> matrix <b>A</b>.</p><ul>
<li><b>S</b> is a vector which is resized to min(<b>M</b>, <b>N</b>) and holds the singular vectors</li>
<li><b>Note:</b> the content of <b>A</b> is destoryed in the factorization process </li>
</ul>

</div>
</div>
<a id="gad70066bb270b888e700d5659a637f561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad70066bb270b888e700d5659a637f561">&#9670;&nbsp;</a></span>svd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeA , class VectorLikeS , class VectorLikeU , class VectorLikeUH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::svd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeS &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeU &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeUH &amp;&#160;</td>
          <td class="paramname"><em>VH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldu</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldvh</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper to LAPACK singular value decomposition xGESVD(), compute the singular values only. </p>
<p>Computes the singular values AND singular vectors of the general <b>M</b> by <b>N</b> matrix <b>A</b>.</p><ul>
<li><b>S</b> is a vector which is resized to min(<b>M</b>, <b>N</b>) and holds the singular vectors</li>
<li><b>U</b> is a matrix of size <b>ldu</b> by min(<b>M</b>, <b>N</b>), holds the left singular vectors</li>
<li><b>VH</b> is a matrix of size <b>ldvh</b> by <b>N</b>, holds the complex transpose of the right singular vectors</li>
<li><b>ldu</b> is at least <b>M</b>, <b>ldvh</b> is at least min(<b>M</b>, <b>N</b>)</li>
<li>if any of <b>lda</b>, <b>ldu</b> or <b>ldvh</b> are set to default -1, then the minimum allowed values are assumed</li>
<li><b>Note:</b> the content of <b>A</b> is destoryed in the factorization process </li>
</ul>

</div>
</div>
<a id="ga16ce5c724f1c0b10fcc87f0ad95ea162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16ce5c724f1c0b10fcc87f0ad95ea162">&#9670;&nbsp;</a></span>gesv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeA , class VectorLikeP , class VectorLikeB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::gesv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeP &amp;&#160;</td>
          <td class="paramname"><em>ipiv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeB &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper to LAPACK general solver using PLU factorization xGESV(). </p>
<p>Solves the linear system of equations \( A X = B \), where B is overwritten with the solution</p><ul>
<li><b>A</b> is a column major matrix of size N by N (or lda by N)</li>
<li><b>A</b> is overwritten with the LU part of the PLU factorization</li>
<li><b>B</b> is a column major matrix of size N by num_rhs (or ldb by num_rhs)</li>
<li><b>B</b> is overwritten with the solution</li>
<li><b>ipiv</b> must be a vector of integers, will be resized to <b>N</b> (if smaller) and overwritten with <b>P</b> </li>
</ul>

</div>
</div>
<a id="gad7f9acfb7c7000a9e4f67cf79516bcd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7f9acfb7c7000a9e4f67cf79516bcd9">&#9670;&nbsp;</a></span>geqr_opt_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;int, int&gt; hala::geqr_opt_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeA &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the required size of the Q factor and workspace used by xgeqr(). </p>
<p>Returns the size required for an optimal performance QR decomposition LAPACK xgeqr. The first entry in the pair represents the size of the factor, the second entry is the size of the temporary work-space. </p>

</div>
</div>
<a id="ga1c7b7463bb42548654b87c5f6415cd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c7b7463bb42548654b87c5f6415cd88">&#9670;&nbsp;</a></span>geqr_min_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;int, int&gt; hala::geqr_min_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeA &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the required size of the Q factor and workspace used by xgeqr(). </p>
<p>Returns the size required for an optimal performance QR decomposition LAPACK xgeqr. The first entry in the pair represents the size of the factor, the second entry is the size of the temporary work-space. </p>

</div>
</div>
<a id="ga533c0c95cc992345d370ef35d7085504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga533c0c95cc992345d370ef35d7085504">&#9670;&nbsp;</a></span>geqr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool use_opt = true, class VectorLikeA , class VectorLikeT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::geqr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeA &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around Lapack xgeqr() for QR factorization. </p>
<p>Performs the factorization \( A = Q R \) where <b>Q</b> has orthonormal columns and <b>R</b> is either upper triangular (M = N), upper triangular with padded zeros (M &gt; N) or trapezoidal (M &lt; N). The matrix <b>A</b> will be overwritten with <b>R</b> and the matrix <b>Q</b> will be stored in the zero section of <b>R</b> (below the diagonal) and the vector <b>T</b>. Follow on multiplications of <b>Q</b> can be done with <a class="el" href="group__HALALAPACK.html#ga40f6bc2df70774c39bfe2490ad7b2f72" title="Wrapper around Lapack xgemqr() for multiplication by a QR factor. ">hala::gemqr()</a>.</p>
<ul>
<li><b>M</b> is positive integer indicating the number of rows of <b>A</b> </li>
<li><b>N</b> is positive integer indicating the number of columns of <b>A</b> </li>
<li><b>lda</b> is the leading dimension of <b>A</b>, must be minimum of <b>M</b> </li>
<li><b>A</b> must have size at least <b>lda</b> by <b>N</b> </li>
<li><b>T</b> holds a portion of the matrix <b>Q</b>, will be resized if the size is insufficient</li>
</ul>
<p>The size of the <b>T</b> will be determined by a call to: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> sizes = <a class="code" href="group__HALALAPACK.html#gad7f9acfb7c7000a9e4f67cf79516bcd9">hala::geqr_opt_size</a>(M, N, A, lda);</div><div class="line"><span class="comment">// T must have size sizes.first</span></div><div class="line"><span class="comment">// additional workspace will be used with size sizes.second</span></div></div><!-- fragment --><p>Overloads: </p><div class="fragment"><div class="line"><a class="code" href="group__HALALAPACK.html#ga533c0c95cc992345d370ef35d7085504">hala::geqr</a>(M, N, A, lda, T);</div><div class="line"><a class="code" href="group__HALALAPACK.html#ga533c0c95cc992345d370ef35d7085504">hala::geqr</a>(M, N, A, T, lda = -1);</div><div class="line">hala::geqr_min(M, N, A, lda, T);</div><div class="line">hala::geqr_min(M, N, A, T, lda = -1);</div></div><!-- fragment --><p> Negative leading dimensions are overwritten with the minimum acceptable size. The _min variants use minimum memory variants and <a class="el" href="group__HALALAPACK.html#ga1c7b7463bb42548654b87c5f6415cd88" title="Query the required size of the Q factor and workspace used by xgeqr(). ">hala::geqr_min_size()</a>. </p>

</div>
</div>
<a id="ga40f6bc2df70774c39bfe2490ad7b2f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40f6bc2df70774c39bfe2490ad7b2f72">&#9670;&nbsp;</a></span>gemqr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeA , class VectorLikeT , class VectorLikeC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::gemqr </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeA const &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeT const &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeC &amp;&amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrapper around Lapack xgemqr() for multiplication by a QR factor. </p>
<p>Performs multiplication \( C = op(Q) C \) or \( C = C op(Q) \) where <b>Q</b> is a matrix computed and stored in the format used by hala::gerq(). Specifically, the matrix is defined by the two vectors <b>A</b> and <b>T</b> that are used in the call to <a class="el" href="group__HALALAPACK.html#ga533c0c95cc992345d370ef35d7085504" title="Wrapper around Lapack xgeqr() for QR factorization. ">hala::geqr()</a>.</p>
<ul>
<li><b>side</b> is lower/upper case L or R indicating whether <b>Q</b> is on the left (L) or right (R) side</li>
<li><b>trans</b> is lower/upper case N (non-transpose) or T (conjugate transpose), indicating <b>op</b> </li>
<li><b>C</b> is an <b>M</b> by <b>N</b> matrix (or <b>ldc</b> by <b>N</b>)</li>
<li><b>A</b> and <b>T</b> are the vectors that come from a call to <a class="el" href="group__HALALAPACK.html#ga533c0c95cc992345d370ef35d7085504" title="Wrapper around Lapack xgeqr() for QR factorization. ">hala::geqr()</a> with sizes given by geqr_M and geqr_N</li>
<li><b>K</b> is the number of factors used to define <b>Q</b>, namely the smaller of geqr_M and geqr_N</li>
<li><b>lda</b> is as in the call to <a class="el" href="group__HALALAPACK.html#ga533c0c95cc992345d370ef35d7085504" title="Wrapper around Lapack xgeqr() for QR factorization. ">hala::geqr()</a></li>
<li><b>ldc</b> is the leading dimension of <b>C</b>, minimum <b>M</b> </li>
<li><b>tsize</b> is best inferred from the size of <b>T</b>, if not, it is taken from the second output of <a class="el" href="group__HALALAPACK.html#gad7f9acfb7c7000a9e4f67cf79516bcd9" title="Query the required size of the Q factor and workspace used by xgeqr(). ">hala::geqr_opt_size()</a></li>
</ul>
<p>Overloads: </p><div class="fragment"><div class="line"><a class="code" href="group__HALALAPACK.html#ga40f6bc2df70774c39bfe2490ad7b2f72">hala::gemqr</a>(side, trans, M, N, K, A, lda, T, tsize, C, ldc);</div><div class="line"><a class="code" href="group__HALALAPACK.html#ga40f6bc2df70774c39bfe2490ad7b2f72">hala::gemqr</a>(side, trans, M, N, K, A, lda, T, C, ldc);</div><div class="line"><a class="code" href="group__HALALAPACK.html#ga40f6bc2df70774c39bfe2490ad7b2f72">hala::gemqr</a>(side, trans, M, N, K, A, T, C, lda = -1, ldc = -1);</div></div><!-- fragment --><p> Negative leading dimensions are overwritten with the minimum acceptable size. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div> -->
</body>
</html>
