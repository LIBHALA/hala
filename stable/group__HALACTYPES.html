<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HALA: Handy Accelerated Linear Algebra v1.0: Custom Type Definitions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hala.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"/>
                </a> 1.8.13
    </div>
   <div id="projectname">HALA: Handy Accelerated Linear Algebra v1.0
   <!--         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 -->
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__HALACTYPES.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Custom Type Definitions<div class="ingroups"><a class="el" href="group__HALACUSTOM.html">HALA Support for Custom Vector Class</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Custom Type Definitions:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__HALACTYPES.png" border="0" alt="" usemap="#group____HALACTYPES"/>
<map name="group____HALACTYPES" id="group____HALACTYPES">
<area shape="rect" id="node1" href="group__HALACUSTOM.html" title="HALA Support for Custom\l Vector Class" alt="" coords="5,5,180,47"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__float.html">hala::is_float&lt; candidate &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that defines whether <b>candidate</b> is effectively the same as <b>float</b>.  <a href="structhala_1_1is__float.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__double.html">hala::is_double&lt; candidate &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that defines whether <b>candidate</b> is effectively the same as <b>double</b>.  <a href="structhala_1_1is__double.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__fcomplex.html">hala::is_fcomplex&lt; candidate &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that defines whether <b>candidate</b> is effectively the same as <b>std::complex&lt;float&gt;</b>.  <a href="structhala_1_1is__fcomplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__dcomplex.html">hala::is_dcomplex&lt; candidate &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that defines whether <b>candidate</b> is effectively the same as <b>std::complex&lt;double&gt;</b>.  <a href="structhala_1_1is__dcomplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__fcomplex_3_01cuComplex_01_4.html">hala::is_fcomplex&lt; cuComplex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUDA libraries use types cuComplex for single precision complex numbers.  <a href="structhala_1_1is__fcomplex_3_01cuComplex_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__dcomplex_3_01cuDoubleComplex_01_4.html">hala::is_dcomplex&lt; cuDoubleComplex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUDA libraries use types cuDoubleComplex for double precision complex numbers.  <a href="structhala_1_1is__dcomplex_3_01cuDoubleComplex_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__fcomplex_3_01rocblas__float__complex_01_4.html">hala::is_fcomplex&lt; rocblas_float_complex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUDA libraries use types cuComplex for single precision complex numbers.  <a href="structhala_1_1is__fcomplex_3_01rocblas__float__complex_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__dcomplex_3_01rocblas__double__complex_01_4.html">hala::is_dcomplex&lt; rocblas_double_complex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUDA libraries use types cuDoubleComplex for double precision complex numbers.  <a href="structhala_1_1is__dcomplex_3_01rocblas__double__complex_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1261252b2b2088f5bfd449ed2496ab4d"><td class="memTemplParams" colspan="2"><a id="ga1261252b2b2088f5bfd449ed2496ab4d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1261252b2b2088f5bfd449ed2496ab4d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACTYPES.html#ga1261252b2b2088f5bfd449ed2496ab4d">hala::creal</a> (T const x)</td></tr>
<tr class="memdesc:ga1261252b2b2088f5bfd449ed2496ab4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the real part of <b>x</b>. <br /></td></tr>
<tr class="separator:ga1261252b2b2088f5bfd449ed2496ab4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2445e5d4f61f21fd7a95207f134b7ee"><td class="memTemplParams" colspan="2"><a id="gaf2445e5d4f61f21fd7a95207f134b7ee"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf2445e5d4f61f21fd7a95207f134b7ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACTYPES.html#gaf2445e5d4f61f21fd7a95207f134b7ee">hala::cimag</a> (T const x)</td></tr>
<tr class="memdesc:gaf2445e5d4f61f21fd7a95207f134b7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex part of <b>x</b>. <br /></td></tr>
<tr class="separator:gaf2445e5d4f61f21fd7a95207f134b7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2150d29d12084dfd095bb69ff6d0f56f"><td class="memTemplParams" colspan="2"><a id="ga2150d29d12084dfd095bb69ff6d0f56f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2150d29d12084dfd095bb69ff6d0f56f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACTYPES.html#ga2150d29d12084dfd095bb69ff6d0f56f">hala::cconj</a> (T const x)</td></tr>
<tr class="memdesc:ga2150d29d12084dfd095bb69ff6d0f56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate of a number, note that the returned type always matches <b>x</b>. <br /></td></tr>
<tr class="separator:ga2150d29d12084dfd095bb69ff6d0f56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee99633ebb74762ab996c1672f2c805"><td class="memTemplParams" colspan="2"><a id="gaeee99633ebb74762ab996c1672f2c805"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaeee99633ebb74762ab996c1672f2c805"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACTYPES.html#gaeee99633ebb74762ab996c1672f2c805">hala::hala_abs</a> (T const x)</td></tr>
<tr class="memdesc:gaeee99633ebb74762ab996c1672f2c805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of a number, real or complex, standard or custom. <br /></td></tr>
<tr class="separator:gaeee99633ebb74762ab996c1672f2c805"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>BLAS and LAPACK standards works with real and complex floating point numbers with single and double precision. The corresponding equivalents C++ standard types are: </p><div class="fragment"><div class="line">float, double, std::complex&lt;float&gt;, std::complex&lt;double&gt;</div></div><!-- fragment --><p> By default, HALA works with these types; however, some libraries define their own. This is often true in the case of complex numbers and to facilitate interfacing with custom complex types, HALA provides several templates that can be specialized to help identify the correct native equivalents.</p>
<p>Note that C++ is good at automatically identifying the native aliases with the std::is_same template. Specialization here is needed only if the std::is_same does not correctly identify the types.</p>
<p>Example of custom double-complex: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>CustomComplex{</div><div class="line">    <span class="keywordtype">double</span> r, i;</div><div class="line">    <span class="comment">// define just multiplication for example</span></div><div class="line">    CustomComplex operator *= (CustomComplex <span class="keyword">const</span> &amp;other){</div><div class="line">        <span class="keywordtype">double</span> temp = r;</div><div class="line">        r = r * other.r - i * other.i;</div><div class="line">        i = i * other.r + temp * other.i;</div><div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">std::vector&lt;CustomComplex&gt; x = {{1.0, 1.0}, {1.0, 2.0}};</div><div class="line"></div><div class="line"><span class="comment">// std::cout &lt;&lt; hala::norm2(x) &lt;&lt; std::endl; // will fail because CustomComplex is unknown</span></div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span><a class="code" href="structhala_1_1is__dcomplex.html">hala::is_dcomplex</a>&lt;CustomComplex&gt; : std::true_type{};</div><div class="line"></div><div class="line">std::cout &lt;&lt; <a class="code" href="group__HALABLAS1.html#ga48f8d9b686ef4a9cdb69897e3f22bbe5">hala::norm2</a>(x) &lt;&lt; std::endl; <span class="comment">// now this works</span></div></div><!-- fragment --><p>The C++ standard also includes methods such as std::real() and std::imag() that return the real and complex components of C++ standard types and have appropriate overloads for float and double. However, the conjugate operation in the standard is defined as std::conj() and always returns a complex number even if the input is real, which makes it hard to generalize operations of the form (e.g., used often in algorithms related to Hilbert space geometry): </p><div class="fragment"><div class="line"><span class="keyword">auto</span> z = std::conj(x) * y; <span class="comment">// z will be complex even if x and y are real float or double</span></div></div><!-- fragment --><p>HALA provides a set of complex methods that return real numbers for real inputs and work for custom complex numbers as defined above:</p><ul>
<li>hala::hala_real()</li>
<li>hala::hala_imag()</li>
<li>hala::hala_conj()</li>
<li><a class="el" href="group__HALACTYPES.html#gaeee99633ebb74762ab996c1672f2c805" title="Returns the absolute value of a number, real or complex, standard or custom. ">hala::hala_abs()</a> The standard STL real, imag, conj, and abs methods will be used whenever appropriate, reinterpret-cast and other tricks will be employed to handle the custom complex cases. The methods are designed to work with standard types, custom complex types, and custom real types that are aliases to float or double (or int), there is no guarantee that the methods would work for some exotic double precision standard. </li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div> -->
</body>
</html>
