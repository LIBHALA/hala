<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HALA: Handy Accelerated Linear Algebra v1.0: hala Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hala.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"/>
                </a> 1.8.13
    </div>
   <div id="projectname">HALA: Handy Accelerated Linear Algebra v1.0
   <!--         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 -->
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacehala.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">hala Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Master namespace encapsulating all HALA capabilities.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacehala_1_1valid"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala_1_1valid.html">valid</a></td></tr>
<tr class="memdesc:namespacehala_1_1valid"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper namespace for input consistency. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhala_1_1aligned__allocator.html">aligned_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator that aligns memory to the selected register.  <a href="classhala_1_1aligned__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1aligned__iterator.html">aligned_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned random iterator that always moves in strides of the corresponding <a class="el" href="structhala_1_1mmpack.html" title="Wrapper for the aligned memory used by intrinsic methods. ">hala::mmpack</a>.  <a href="structhala_1_1aligned__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1aligned__iterator__traits.html">aligned_iterator_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1aligned__iterator__traits_3_01T_00_01R_00_01aligned__vector_3_01T_00_01R_01_4_01const_01_4.html">aligned_iterator_traits&lt; T, R, aligned_vector&lt; T, R &gt; const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1bind__pack.html">bind_pack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a memory slice to an address, constructor reads from the address, destructor writes back.  <a href="structhala_1_1bind__pack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1binded__gpu__vector.html">binded_gpu_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that wraps around a <a class="el" href="classhala_1_1gpu__vector.html" title="Templated class providing functionality similar to C++ containers. ">gpu_vector</a> and a reference to a cpu vector-like.  <a href="structhala_1_1binded__gpu__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhala_1_1cholmod__factor.html">cholmod_factor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a factorization of a sparse matrix using the Cholmod library.  <a href="classhala_1_1cholmod__factor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1chronometer.html">chronometer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple <b>chronometer</b> with start and stop functions that returns the milliseconds as a <b>long</b> <b>long</b>.  <a href="structhala_1_1chronometer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1convert__pointer.html">convert_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that wraps around a pointer and automatically casts it to any other pointer type.  <a href="structhala_1_1convert__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1cpu__engine.html">cpu_engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CPU Engine.  <a href="structhala_1_1cpu__engine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1cpu__ilu.html">cpu_ilu</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around an Incomplete Lower Upper (ILU) factorization.  <a href="structhala_1_1cpu__ilu.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1cpu__sparse__matrix.html">cpu_sparse_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a sparse matrix located in CPU memory.  <a href="structhala_1_1cpu__sparse__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhala_1_1cpu__triangular__matrix.html">cpu_triangular_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around triangular sparse matrix and the associated analysis.  <a href="classhala_1_1cpu__triangular__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1cuda__struct__description.html">cuda_struct_description</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around used in sparse mat-vec and mat-mat operations.  <a href="structhala_1_1cuda__struct__description.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1default__alignment.html">default_alignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines whether the <b>hala::vex</b> constructor, <b>load</b>, <b>store</b> and <b>operator</b> <b>=</b> default to aligned or unaligned mode.  <a href="structhala_1_1default__alignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1default__alignment_3_01T_00_01regtype_1_1avx_01_4.html">default_alignment&lt; T, regtype::avx &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization for <b><a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea73758c37e4499f20ac5f995a144abba6" title="Using the 256 bit AVX registers. ">regtype::avx</a></b> registers.  <a href="structhala_1_1default__alignment_3_01T_00_01regtype_1_1avx_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1default__alignment_3_01T_00_01regtype_1_1avx512_01_4.html">default_alignment&lt; T, regtype::avx512 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization for <b><a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea01ed71f991f565d98b82f76ac36e0628" title="Using the 512 bit AVX-512 registers. ">regtype::avx512</a></b> registers.  <a href="structhala_1_1default__alignment_3_01T_00_01regtype_1_1avx512_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1default__alignment_3_01T_00_01regtype_1_1sse_01_4.html">default_alignment&lt; T, regtype::sse &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization for <b><a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea64192ca465194480a4621d6905dac5b7" title="Using the 128 bit SSE registers. ">regtype::sse</a></b> registers.  <a href="structhala_1_1default__alignment_3_01T_00_01regtype_1_1sse_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__aligned.html">define_aligned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type for good alignment.  <a href="structhala_1_1define__aligned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__data.html">define_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct with a single function that returns a raw pointer to the internal contiguous data stored in the vector, uses <b></b>.<a class="el" href="structhala_1_1define__data.html#a8a7fd5a50422be19c88638aa37b953dc" title="Returns a raw pointer to the internal data of the VectorLike. ">data()</a> method.  <a href="structhala_1_1define__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__data_3_01T_01_5_01_4.html">define_data&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__data_3_01T_01_5const_01_4.html">define_data&lt; T *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__data_3_01typename_01std_1_1valarray_3_01T_01_4_01_4.html">define_data&lt; typename std::valarray&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__data_3_01typename_01std_1_1valarray_3_01T_01_4_01const_01_4.html">define_data&lt; typename std::valarray&lt; T &gt; const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__preconditioner.html">define_preconditioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__resize.html">define_resize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template that defines how to resize of the vector.  <a href="structhala_1_1define__resize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__single.html">define_single</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type for reading single entry and setting it to all registers.  <a href="structhala_1_1define__single.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__size.html">define_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template that defines the size of the vector.  <a href="structhala_1_1define__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__size_3_01T_01_5_01_4.html">define_size&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__standard__precision.html">define_standard_precision</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to specialize that returns the precision, e.g., float for float and complex-float.  <a href="structhala_1_1define__standard__precision.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__standard__precision_3_01scalar__type_00_01typename_01std_1_1enable__if__t_94c39c3699550bf062219c02f69ea58a.html">define_standard_precision&lt; scalar_type, typename std::enable_if_t&lt; is_double&lt; scalar_type &gt;::value||is_dcomplex&lt; scalar_type &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for double and double-complex.  <a href="structhala_1_1define__standard__precision_3_01scalar__type_00_01typename_01std_1_1enable__if__t_94c39c3699550bf062219c02f69ea58a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__standard__precision_3_01scalar__type_00_01typename_01std_1_1enable__if__t_afbd26a018402ee8942f38140aef9e94.html">define_standard_precision&lt; scalar_type, typename std::enable_if_t&lt; is_float&lt; scalar_type &gt;::value||is_fcomplex&lt; scalar_type &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for float and float-complex.  <a href="structhala_1_1define__standard__precision_3_01scalar__type_00_01typename_01std_1_1enable__if__t_afbd26a018402ee8942f38140aef9e94.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__standard__type.html">define_standard_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to specialize that returns the C++ standard equivalent of each type.  <a href="structhala_1_1define__standard__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__standard__type_3_01scalar__type_00_01typename_01std_1_1enable__if__t_3_01i4cf2038c150435d805bd9b1d467e7b42.html">define_standard_type&lt; scalar_type, typename std::enable_if_t&lt; is_dcomplex&lt; scalar_type &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for double-complex.  <a href="structhala_1_1define__standard__type_3_01scalar__type_00_01typename_01std_1_1enable__if__t_3_01i4cf2038c150435d805bd9b1d467e7b42.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__standard__type_3_01scalar__type_00_01typename_01std_1_1enable__if__t_3_01i0c5b0ce6d79cae0efb87b13dc9252089.html">define_standard_type&lt; scalar_type, typename std::enable_if_t&lt; is_double&lt; scalar_type &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for double.  <a href="structhala_1_1define__standard__type_3_01scalar__type_00_01typename_01std_1_1enable__if__t_3_01i0c5b0ce6d79cae0efb87b13dc9252089.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__standard__type_3_01scalar__type_00_01typename_01std_1_1enable__if__t_3_01i5857803c55254d4e3b184184a85d241b.html">define_standard_type&lt; scalar_type, typename std::enable_if_t&lt; is_fcomplex&lt; scalar_type &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for float-complex.  <a href="structhala_1_1define__standard__type_3_01scalar__type_00_01typename_01std_1_1enable__if__t_3_01i5857803c55254d4e3b184184a85d241b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__standard__type_3_01scalar__type_00_01typename_01std_1_1enable__if__t_3_01i73aed2a2c5e61137348d720971f714c7.html">define_standard_type&lt; scalar_type, typename std::enable_if_t&lt; is_float&lt; scalar_type &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for float.  <a href="structhala_1_1define__standard__type_3_01scalar__type_00_01typename_01std_1_1enable__if__t_3_01i73aed2a2c5e61137348d720971f714c7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__standard__type_3_01scalar__type_00_01typename_01std_1_1enable__if__t_3_01sa8e02b8fa9ca8687afebc17a0dd6429a.html">define_standard_type&lt; scalar_type, typename std::enable_if_t&lt; std::is_integral&lt; scalar_type &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for index types.  <a href="structhala_1_1define__standard__type_3_01scalar__type_00_01typename_01std_1_1enable__if__t_3_01sa8e02b8fa9ca8687afebc17a0dd6429a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__type.html">define_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template that defined the type of the vector variable.  <a href="structhala_1_1define__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__type_3_01T_01_5_01_4.html">define_type&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__type_3_01T_01_5_6_01_4.html">define_type&lt; T *&amp; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__type_3_01T_01_5const_01_4.html">define_type&lt; T *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__unaligned.html">define_unaligned</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type for bad alignment.  <a href="structhala_1_1define__unaligned.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__vdefault.html">define_vdefault</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of this struct are used to define the default vector classes.  <a href="structhala_1_1define__vdefault.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1device__pntr.html">device_pntr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows expressively using scalar pointer on the GPU device, see <a class="el" href="structhala_1_1gpu__pntr.html">hala::gpu_pntr</a>.  <a href="structhala_1_1device__pntr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1deviceid__extractor.html">deviceid_extractor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct the reads the GPU device ID associated with the <b>VectorLike</b>, result will be ignored unless specialized.  <a href="structhala_1_1deviceid__extractor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1deviceid__extractor_3_01const_01gpu__vector_3_01T_01_4_01_4.html">deviceid_extractor&lt; const gpu_vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for GPU device ID for const <a class="el" href="classhala_1_1gpu__vector.html" title="Templated class providing functionality similar to C++ containers. ">hala::gpu_vector</a>.  <a href="structhala_1_1deviceid__extractor_3_01const_01gpu__vector_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1deviceid__extractor_3_01gpu__vector_3_01T_01_4_01_4.html">deviceid_extractor&lt; gpu_vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for GPU device ID for non-const <a class="el" href="classhala_1_1gpu__vector.html" title="Templated class providing functionality similar to C++ containers. ">hala::gpu_vector</a>.  <a href="structhala_1_1deviceid__extractor_3_01gpu__vector_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1engined__vector.html">engined_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that binds an engine and a vector so both can be carried in one context.  <a href="structhala_1_1engined__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1engined__vector__binding.html">engined_vector_binding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core engine class, deals with handles and data transfer.  <a href="structhala_1_1gpu__engine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1gpu__ilu.html">gpu_ilu</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPU implementation of the incomplete Lower-Upper factorization.  <a href="structhala_1_1gpu__ilu.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1gpu__pconvert.html">gpu_pconvert</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a CPU bound value into a host pointer.  <a href="structhala_1_1gpu__pconvert.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1gpu__pntr.html">gpu_pntr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1gpu__sparse__matrix.html">gpu_sparse_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around sparse matrix data associated with the GPU device.  <a href="structhala_1_1gpu__sparse__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhala_1_1gpu__triangular__matrix.html">gpu_triangular_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around a sparse triangular matrix and all associated analysis.  <a href="classhala_1_1gpu__triangular__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhala_1_1gpu__vector.html">gpu_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Templated class providing functionality similar to C++ containers.  <a href="classhala_1_1gpu__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhala_1_1gpu__wrapped__array.html">gpu_wrapped_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around C-style GPU arrays that can be passed to <a class="el" href="structhala_1_1gpu__engine.html" title="Core engine class, deals with handles and data transfer. ">hala::gpu_engine</a> templates.  <a href="classhala_1_1gpu__wrapped__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1has__resize.html">has_resize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to check if a <b>VectorLike</b> class has a resize method.  <a href="structhala_1_1has__resize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1host__pntr.html">host_pntr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows expressively using scalar pointer on the Host (CPU) device, see <a class="el" href="structhala_1_1gpu__pntr.html">hala::gpu_pntr</a>.  <a href="structhala_1_1host__pntr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__compatible.html">is_compatible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines <b>value</b> to be true if <b>T</b> and <b>U</b> are compatible, e.g., complex with double precision.  <a href="structhala_1_1is__compatible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__compatible_3_01T_00_01U_00_01std_1_1enable__if__t_3_07is__float_3_01T_01_4_1_1412954aeeba2a8653ccbd9c396d17c2e.html">is_compatible&lt; T, U, std::enable_if_t&lt;(is_float&lt; T &gt;::value &amp;&amp;is_float&lt; U &gt;::value)||(is_double&lt; T &gt;::value &amp;&amp;is_double&lt; U &gt;::value)||(is_fcomplex&lt; T &gt;::value &amp;&amp;is_fcomplex&lt; U &gt;::value)||(is_dcomplex&lt; T &gt;::value &amp;&amp;is_dcomplex&lt; U &gt;::value) &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the true case.  <a href="structhala_1_1is__compatible_3_01T_00_01U_00_01std_1_1enable__if__t_3_07is__float_3_01T_01_4_1_1412954aeeba2a8653ccbd9c396d17c2e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__complex.html">is_complex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines <b>value</b> <b>=</b> <b>true</b> if the type <b>T</b> is <b>std::complex&lt;float&gt;</b> or <b>std::complex&lt;double&gt;</b>.  <a href="structhala_1_1is__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__dcomplex.html">is_dcomplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that defines whether <b>candidate</b> is effectively the same as <b>std::complex&lt;double&gt;</b>.  <a href="structhala_1_1is__dcomplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__dcomplex_3_01cuDoubleComplex_01_4.html">is_dcomplex&lt; cuDoubleComplex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUDA libraries use types cuDoubleComplex for double precision complex numbers.  <a href="structhala_1_1is__dcomplex_3_01cuDoubleComplex_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__dcomplex_3_01rocblas__double__complex_01_4.html">is_dcomplex&lt; rocblas_double_complex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUDA libraries use types cuDoubleComplex for double precision complex numbers.  <a href="structhala_1_1is__dcomplex_3_01rocblas__double__complex_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__double.html">is_double</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that defines whether <b>candidate</b> is effectively the same as <b>double</b>.  <a href="structhala_1_1is__double.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__engine.html">is_engine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__fcomplex.html">is_fcomplex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that defines whether <b>candidate</b> is effectively the same as <b>std::complex&lt;float&gt;</b>.  <a href="structhala_1_1is__fcomplex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__fcomplex_3_01cuComplex_01_4.html">is_fcomplex&lt; cuComplex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUDA libraries use types cuComplex for single precision complex numbers.  <a href="structhala_1_1is__fcomplex_3_01cuComplex_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__fcomplex_3_01rocblas__float__complex_01_4.html">is_fcomplex&lt; rocblas_float_complex &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CUDA libraries use types cuComplex for single precision complex numbers.  <a href="structhala_1_1is__fcomplex_3_01rocblas__float__complex_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__float.html">is_float</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that defines whether <b>candidate</b> is effectively the same as <b>float</b>.  <a href="structhala_1_1is__float.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__on__cpu.html">is_on_cpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__on__cpu_3_01TriangularMatrix_00_01std_1_1enable__if__t_3_01std_1_1is__same_3_059ab93c57629e156e98a33cf295ab077.html">is_on_cpu&lt; TriangularMatrix, std::enable_if_t&lt; std::is_same&lt; typename TriangularMatrix::engine_type, cpu_engine &gt;::value, void &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__on__gpu.html">is_on_gpu</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches between true-type and false-type depending whether <b>TriangularMatrix::engine_type</b> is <a class="el" href="structhala_1_1cpu__engine.html" title="The CPU Engine. ">cpu_engine</a>.  <a href="structhala_1_1is__on__gpu.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1is__on__gpu_3_01TriangularMatrix_00_01std_1_1enable__if__t_3_01std_1_1is__same_3_0bdb9fd270764a905cfa4ec2238334172.html">is_on_gpu&lt; TriangularMatrix, std::enable_if_t&lt; std::is_same&lt; typename TriangularMatrix::engine_type, gpu_engine &gt;::value, void &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization indicating that the engine is indeed the cuda_engine.  <a href="structhala_1_1is__on__gpu_3_01TriangularMatrix_00_01std_1_1enable__if__t_3_01std_1_1is__same_3_0bdb9fd270764a905cfa4ec2238334172.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1mmpack.html">mmpack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the aligned memory used by intrinsic methods.  <a href="structhala_1_1mmpack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__abs.html">number_abs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of a number, handles the non-custom complex case.  <a href="structhala_1_1number__abs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__abs_3_01T_00_01std_1_1enable__if__t_3_07is__fcomplex_3_01T_01_4_1_1value_7ce04d684b004476fad02b6dcb4096c1e.html">number_abs&lt; T, std::enable_if_t&lt;(is_fcomplex&lt; T &gt;::value||is_dcomplex&lt; T &gt;::value) &amp;&amp;!std::is_same&lt; T, std::complex&lt; float &gt; &gt;::value &amp;&amp;!std::is_same&lt; T, std::complex&lt; double &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of a number, handles the custom complex case.  <a href="structhala_1_1number__abs_3_01T_00_01std_1_1enable__if__t_3_07is__fcomplex_3_01T_01_4_1_1value_7ce04d684b004476fad02b6dcb4096c1e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__caster.html">number_caster</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around static cast that can be specialized.  <a href="structhala_1_1number__caster.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__caster_3_01T_00_01T_00_01void_01_4.html">number_caster&lt; T, T, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization when the type is the same.  <a href="structhala_1_1number__caster_3_01T_00_01T_00_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__caster_3_01T_00_01U_00_01std_1_1enable__if__t_3_07is__fcomplex_3_01T_01_4_c9ebd9e05ddfb819c620fe1b9ddb50bf.html">number_caster&lt; T, U, std::enable_if_t&lt;(is_fcomplex&lt; T &gt;::value||is_dcomplex&lt; T &gt;::value) &amp;&amp;!std::is_same&lt; T, std::complex&lt; float &gt; &gt;::value &amp;&amp;!std::is_same&lt; T, std::complex&lt; double &gt; &gt;::value &amp;&amp;(is_float&lt; U &gt;::value||is_double&lt; U &gt;::value) &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization when converting standard real to custom complex.  <a href="structhala_1_1number__caster_3_01T_00_01U_00_01std_1_1enable__if__t_3_07is__fcomplex_3_01T_01_4_c9ebd9e05ddfb819c620fe1b9ddb50bf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__caster_3_01T_00_01U_00_01std_1_1enable__if__t_3_07is__fcomplex_3_01T_01_4_c12169cc39bc67d5aaab32e4081dd46b.html">number_caster&lt; T, U, std::enable_if_t&lt;(is_fcomplex&lt; T &gt;::value||is_dcomplex&lt; T &gt;::value) &amp;&amp;(is_fcomplex&lt; U &gt;::value||is_dcomplex&lt; U &gt;::value) &amp;&amp;!(std::is_same&lt; T, std::complex&lt; float &gt;&gt;::value &amp;&amp;std::is_same&lt; U, std::complex&lt; double &gt;&gt;::value) &amp;&amp;!(std::is_same&lt; T, std::complex&lt; double &gt;&gt;::value &amp;&amp;std::is_same&lt; U, std::complex&lt; float &gt;&gt;::value) &amp;&amp;!std::is_same&lt; T, U &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization when converting complex to complex, at least one is not standard.  <a href="structhala_1_1number__caster_3_01T_00_01U_00_01std_1_1enable__if__t_3_07is__fcomplex_3_01T_01_4_c12169cc39bc67d5aaab32e4081dd46b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__caster_3_01T_00_01U_00_01std_1_1enable__if__t_3_07is__float_3_01T_01_4_1_159fd8110665464cad2aa9be3cbdd2598.html">number_caster&lt; T, U, std::enable_if_t&lt;(is_float&lt; T &gt;::value||is_double&lt; T &gt;::value) &amp;&amp;(is_fcomplex&lt; U &gt;::value||is_dcomplex&lt; U &gt;::value) &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization when converting standard complex to real.  <a href="structhala_1_1number__caster_3_01T_00_01U_00_01std_1_1enable__if__t_3_07is__float_3_01T_01_4_1_159fd8110665464cad2aa9be3cbdd2598.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__caster_3_01T_00_01U_00_01std_1_1enable__if__t_3_07std_1_1is__same_3_01T_00f2af9c0422053eadd209190d24740aed.html">number_caster&lt; T, U, std::enable_if_t&lt;(std::is_same&lt; T, std::complex&lt; float &gt;&gt;::value &amp;&amp;std::is_same&lt; U, std::complex&lt; double &gt;&gt;::value)||(std::is_same&lt; U, std::complex&lt; float &gt;&gt;::value &amp;&amp;std::is_same&lt; T, std::complex&lt; double &gt;&gt;::value) &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization when converting standard complex to complex.  <a href="structhala_1_1number__caster_3_01T_00_01U_00_01std_1_1enable__if__t_3_07std_1_1is__same_3_01T_00f2af9c0422053eadd209190d24740aed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__conj.html">number_conj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate of a number, handles the real case (i.e., just return the number).  <a href="structhala_1_1number__conj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__conj_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__same_3_01T_00_01std_1_e84fa513bea1c99ddd37d505900889ee.html">number_conj&lt; T, std::enable_if_t&lt; std::is_same&lt; T, std::complex&lt; float &gt; &gt;::value||std::is_same&lt; T, std::complex&lt; double &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate of a number, handles the std::complex case (i.e., just use std::conj).  <a href="structhala_1_1number__conj_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__same_3_01T_00_01std_1_e84fa513bea1c99ddd37d505900889ee.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__conj_3_01T_00_01std_1_1enable__if__t_3_07is__fcomplex_3_01T_01_4_1_1value_33d777c74e4de7ed17be3c79b186c62e.html">number_conj&lt; T, std::enable_if_t&lt;(is_fcomplex&lt; T &gt;::value||is_dcomplex&lt; T &gt;::value) &amp;&amp;!std::is_same&lt; T, std::complex&lt; float &gt; &gt;::value &amp;&amp;!std::is_same&lt; T, std::complex&lt; double &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate of a number, handles the non-standard complex case (i.e., using reinterpret cast).  <a href="structhala_1_1number__conj_3_01T_00_01std_1_1enable__if__t_3_07is__fcomplex_3_01T_01_4_1_1value_33d777c74e4de7ed17be3c79b186c62e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__imag.html">number_imag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around standard imag() that can be specialized.  <a href="structhala_1_1number__imag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__imag_3_01T_00_01std_1_1enable__if__t_3_07is__fcomplex_3_01T_01_4_1_1value_a834d0f43150f3aaba3f99fe64cd01f2.html">number_imag&lt; T, std::enable_if_t&lt;(is_fcomplex&lt; T &gt;::value||is_dcomplex&lt; T &gt;::value) &amp;&amp;!std::is_same&lt; T, std::complex&lt; float &gt; &gt;::value &amp;&amp;!std::is_same&lt; T, std::complex&lt; double &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for compatible custom complex class.  <a href="structhala_1_1number__imag_3_01T_00_01std_1_1enable__if__t_3_07is__fcomplex_3_01T_01_4_1_1value_a834d0f43150f3aaba3f99fe64cd01f2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__real.html">number_real</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around standard real that can be specialized.  <a href="structhala_1_1number__real.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1number__real_3_01T_00_01std_1_1enable__if__t_3_07is__fcomplex_3_01T_01_4_1_1value_53d3abf6ae39c17636ad491fb948cd44.html">number_real&lt; T, std::enable_if_t&lt;(is_fcomplex&lt; T &gt;::value||is_dcomplex&lt; T &gt;::value) &amp;&amp;!std::is_same&lt; T, std::complex&lt; float &gt; &gt;::value &amp;&amp;!std::is_same&lt; T, std::complex&lt; double &gt; &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for compatible custom complex class.  <a href="structhala_1_1number__real_3_01T_00_01std_1_1enable__if__t_3_07is__fcomplex_3_01T_01_4_1_1value_53d3abf6ae39c17636ad491fb948cd44.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1rocm__struct__description.html">rocm_struct_description</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1stop__criteria.html">stop_criteria</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct that describes the convergence criteria of an iterative solver.  <a href="structhala_1_1stop__criteria.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1vector__constructor.html">vector_constructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assumes the vector has a default constructor <b>VectorLike()</b>, otherwise must specialize.  <a href="structhala_1_1vector__constructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1vector__constructor_3_01gpu__vector_3_01T_01_4_01_4.html">vector_constructor&lt; gpu_vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization that assigns the device ID to the <a class="el" href="classhala_1_1gpu__vector.html" title="Templated class providing functionality similar to C++ containers. ">hala::gpu_vector</a>.  <a href="structhala_1_1vector__constructor_3_01gpu__vector_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1vex__regtype.html">vex_regtype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the variable used in the intrinsic functions, defaults to <b>T</b>, e.g., <b>double</b>.  <a href="structhala_1_1vex__regtype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1vex__stride.html">vex_stride</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the stride for the vectorization, e.g., <b><a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea64192ca465194480a4621d6905dac5b7" title="Using the 128 bit SSE registers. ">regtype::sse</a></b> with <b>double</b> gives <b>stride</b> = 2; defaults to 1 unless specialized.  <a href="structhala_1_1vex__stride.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhala_1_1wrapped__array.html">wrapped_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around C-style arrays that can be passed to HALA templates.  <a href="classhala_1_1wrapped__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac0ae1ffeb6a5b4ccaa1628d44c76d362"><td class="memTemplParams" colspan="2">template&lt;class engine , class VectorLike &gt; </td></tr>
<tr class="memitem:ac0ae1ffeb6a5b4ccaa1628d44c76d362"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ac0ae1ffeb6a5b4ccaa1628d44c76d362">get_vdefault</a> = typename <a class="el" href="structhala_1_1define__vdefault.html">define_vdefault</a>&lt; engine, typename <a class="el" href="structhala_1_1define__type.html">define_type</a>&lt; VectorLike &gt;::value_type &gt;::vector</td></tr>
<tr class="separator:ac0ae1ffeb6a5b4ccaa1628d44c76d362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab93c1d2ec9a0e8222f141d16c56a1b58"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:gab93c1d2ec9a0e8222f141d16c56a1b58"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACUSTOM.html#gab93c1d2ec9a0e8222f141d16c56a1b58">get_scalar_type</a> = typename <a class="el" href="structhala_1_1define__type.html">define_type</a>&lt; std::remove_reference_t&lt; VectorLike &gt; &gt;::value_type</td></tr>
<tr class="memdesc:gab93c1d2ec9a0e8222f141d16c56a1b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to the scalar type of a vector-like class.  <a href="group__HALACUSTOM.html#gab93c1d2ec9a0e8222f141d16c56a1b58">More...</a><br /></td></tr>
<tr class="separator:gab93c1d2ec9a0e8222f141d16c56a1b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb090a328015649aed8ed8bb9b5e4980"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:gaeb090a328015649aed8ed8bb9b5e4980"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACUSTOM.html#gaeb090a328015649aed8ed8bb9b5e4980">get_standard_type</a> = typename <a class="el" href="structhala_1_1define__standard__type.html">define_standard_type</a>&lt; typename <a class="el" href="structhala_1_1define__type.html">define_type</a>&lt; VectorLike &gt;::value_type &gt;::value_type</td></tr>
<tr class="memdesc:gaeb090a328015649aed8ed8bb9b5e4980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to the standard equivalent for the scalar type of a vector-like class.  <a href="group__HALACUSTOM.html#gaeb090a328015649aed8ed8bb9b5e4980">More...</a><br /></td></tr>
<tr class="separator:gaeb090a328015649aed8ed8bb9b5e4980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78609b70f45312e08e520b6ed736ff40"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:ga78609b70f45312e08e520b6ed736ff40"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACUSTOM.html#ga78609b70f45312e08e520b6ed736ff40">get_precision_type</a> = typename <a class="el" href="structhala_1_1define__standard__precision.html">define_standard_precision</a>&lt; typename <a class="el" href="structhala_1_1define__type.html">define_type</a>&lt; VectorLike &gt;::value_type &gt;::value_type</td></tr>
<tr class="memdesc:ga78609b70f45312e08e520b6ed736ff40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to the base precision type of a vector, e.g., <b>float</b> and <b>std::complex&lt;float&gt;</b> map to float.  <a href="group__HALACUSTOM.html#ga78609b70f45312e08e520b6ed736ff40">More...</a><br /></td></tr>
<tr class="separator:ga78609b70f45312e08e520b6ed736ff40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e42c8118b1a08628124f28874d411cf"><td class="memTemplParams" colspan="2">template&lt;class engine , class VectorLike &gt; </td></tr>
<tr class="memitem:ga4e42c8118b1a08628124f28874d411cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASOLVERS.html#ga4e42c8118b1a08628124f28874d411cf">preconditioner</a> = typename <a class="el" href="structhala_1_1define__preconditioner.html">define_preconditioner</a>&lt; engine, VectorLike &gt;::type</td></tr>
<tr class="memdesc:ga4e42c8118b1a08628124f28874d411cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that describes the preconditioner for an iterative solver, engine case.  <a href="group__HALASOLVERS.html#ga4e42c8118b1a08628124f28874d411cf">More...</a><br /></td></tr>
<tr class="separator:ga4e42c8118b1a08628124f28874d411cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79e339da4158ec79ddcfae6317588390"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:ga79e339da4158ec79ddcfae6317588390"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASOLVERS.html#ga79e339da4158ec79ddcfae6317588390">preconditioner_noe</a> = std::function&lt; void(decltype(<a class="el" href="group__HALACPUENGINE.html#ga830472d103ac598f3ca1c5204a5c0991">new_vector</a>(std::declval&lt; VectorLike &gt;())) const &amp;x, decltype(<a class="el" href="group__HALACPUENGINE.html#ga830472d103ac598f3ca1c5204a5c0991">new_vector</a>(std::declval&lt; VectorLike &gt;())) &amp;r)&gt;</td></tr>
<tr class="memdesc:ga79e339da4158ec79ddcfae6317588390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that describes the preconditioner for an iterative solver, no-engine case.  <a href="group__HALASOLVERS.html#ga79e339da4158ec79ddcfae6317588390">More...</a><br /></td></tr>
<tr class="separator:ga79e339da4158ec79ddcfae6317588390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb09081de2bccbc9add2b253d4793368"><td class="memTemplParams" colspan="2">template&lt;class compute_engine &gt; </td></tr>
<tr class="memitem:acb09081de2bccbc9add2b253d4793368"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#acb09081de2bccbc9add2b253d4793368">hala_int</a> = int</td></tr>
<tr class="separator:acb09081de2bccbc9add2b253d4793368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb6d5e51fe0f4ebf2e5ff5c54bda1b0e"><td class="memTemplParams" colspan="2">
template&lt;typename T , regtype R = default_regtype&gt; </td></tr>
<tr class="memitem:gadb6d5e51fe0f4ebf2e5ff5c54bda1b0e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAALALLOC.html#gadb6d5e51fe0f4ebf2e5ff5c54bda1b0e">aligned_vector</a> = std::vector&lt; T, <a class="el" href="classhala_1_1aligned__allocator.html">aligned_allocator</a>&lt; T, R &gt; &gt;</td></tr>
<tr class="memdesc:gadb6d5e51fe0f4ebf2e5ff5c54bda1b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligned vector alias. <br /></td></tr>
<tr class="separator:gadb6d5e51fe0f4ebf2e5ff5c54bda1b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf92953ace32fcf72b0851b9334306432"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf92953ace32fcf72b0851b9334306432"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#gaf92953ace32fcf72b0851b9334306432">mmpack_sse</a> = <a class="el" href="structhala_1_1mmpack.html">mmpack</a>&lt; T, <a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea64192ca465194480a4621d6905dac5b7">regtype::sse</a> &gt;</td></tr>
<tr class="memdesc:gaf92953ace32fcf72b0851b9334306432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut alias to <b>mmpack&lt;T</b>, <b>sse&gt;</b>. <br /></td></tr>
<tr class="separator:gaf92953ace32fcf72b0851b9334306432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga963b24f8519b434eaa131621d8f188a1"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga963b24f8519b434eaa131621d8f188a1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga963b24f8519b434eaa131621d8f188a1">mmpack_avx</a> = <a class="el" href="structhala_1_1mmpack.html">mmpack</a>&lt; T, <a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea73758c37e4499f20ac5f995a144abba6">regtype::avx</a> &gt;</td></tr>
<tr class="memdesc:ga963b24f8519b434eaa131621d8f188a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut alias to <b>mmpack&lt;T</b>, <b>avx&gt;</b>. <br /></td></tr>
<tr class="separator:ga963b24f8519b434eaa131621d8f188a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23936923329b992d6d248f906c005bac"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga23936923329b992d6d248f906c005bac"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga23936923329b992d6d248f906c005bac">mmpack_avx512</a> = <a class="el" href="structhala_1_1mmpack.html">mmpack</a>&lt; T, <a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea01ed71f991f565d98b82f76ac36e0628">regtype::avx512</a> &gt;</td></tr>
<tr class="memdesc:ga23936923329b992d6d248f906c005bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut alias to <b>mmpack&lt;T</b>, <b>avx512&gt;</b>. <br /></td></tr>
<tr class="separator:ga23936923329b992d6d248f906c005bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a37f4d8a83828612055f625f0523ad667"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a37f4d8a83828612055f625f0523ad667">copy_direction</a> { <a class="el" href="namespacehala.html#a37f4d8a83828612055f625f0523ad667a2b5f960e5534a6b7454f84eff0c00338">copy_direction::host2device</a>, 
<a class="el" href="namespacehala.html#a37f4d8a83828612055f625f0523ad667ad22e421f7bf867f47424129321dbc6d2">copy_direction::device2device</a>, 
<a class="el" href="namespacehala.html#a37f4d8a83828612055f625f0523ad667a626599cea05648790c546cb69e0fd765">copy_direction::device2host</a>
 }</td></tr>
<tr class="separator:a37f4d8a83828612055f625f0523ad667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf9392711eaa1cd0f3ba628585d4bee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga5cf9392711eaa1cd0f3ba628585d4bee">regtype</a> { <a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea334c4a4c42fdb79d7ebc3e73b517e6f8">regtype::none</a>, 
<a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea64192ca465194480a4621d6905dac5b7">regtype::sse</a>, 
<a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea73758c37e4499f20ac5f995a144abba6">regtype::avx</a>, 
<a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea01ed71f991f565d98b82f76ac36e0628">regtype::avx512</a>
 }<tr class="memdesc:ga5cf9392711eaa1cd0f3ba628585d4bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of register to use for vectorization.  <a href="group__HALAVEX.html#ga5cf9392711eaa1cd0f3ba628585d4bee">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga5cf9392711eaa1cd0f3ba628585d4bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7bca3847ab0f6794e00289160ab4a83d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a7bca3847ab0f6794e00289160ab4a83d">check_trans</a> (char trans)</td></tr>
<tr class="memdesc:a7bca3847ab0f6794e00289160ab4a83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <b>trans</b> is either lower or upper case N, T, or C.  <a href="#a7bca3847ab0f6794e00289160ab4a83d">More...</a><br /></td></tr>
<tr class="separator:a7bca3847ab0f6794e00289160ab4a83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd8ccaea8345081dbf41139ec3d4f29"><td class="memItemLeft" align="right" valign="top"><a id="aadd8ccaea8345081dbf41139ec3d4f29"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#aadd8ccaea8345081dbf41139ec3d4f29">check_uplo</a> (char uplo)</td></tr>
<tr class="memdesc:aadd8ccaea8345081dbf41139ec3d4f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <b>uplo</b> is either lower or upper case U or L. <br /></td></tr>
<tr class="separator:aadd8ccaea8345081dbf41139ec3d4f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c9ebc3f1cb43914f083994b15cebfe"><td class="memItemLeft" align="right" valign="top"><a id="ae0c9ebc3f1cb43914f083994b15cebfe"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#ae0c9ebc3f1cb43914f083994b15cebfe">check_diag</a> (char diag)</td></tr>
<tr class="memdesc:ae0c9ebc3f1cb43914f083994b15cebfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <b>diag</b> is either lower or upper case U or N. <br /></td></tr>
<tr class="separator:ae0c9ebc3f1cb43914f083994b15cebfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b759ea821aba8a74b92093923b59898"><td class="memItemLeft" align="right" valign="top"><a id="a5b759ea821aba8a74b92093923b59898"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a5b759ea821aba8a74b92093923b59898">check_side</a> (char side)</td></tr>
<tr class="memdesc:a5b759ea821aba8a74b92093923b59898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <b>side</b> is either lower or upper case L or R. <br /></td></tr>
<tr class="separator:a5b759ea821aba8a74b92093923b59898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93446c76cb50d6232a5995fa2429e564"><td class="memItemLeft" align="right" valign="top"><a id="a93446c76cb50d6232a5995fa2429e564"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a93446c76cb50d6232a5995fa2429e564">is_n</a> (char trans)</td></tr>
<tr class="memdesc:a93446c76cb50d6232a5995fa2429e564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <b>trans</b> is upper or lower case 'N'. <br /></td></tr>
<tr class="separator:a93446c76cb50d6232a5995fa2429e564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3922559d600a27c7ee8d5697e0a9d592"><td class="memItemLeft" align="right" valign="top"><a id="a3922559d600a27c7ee8d5697e0a9d592"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a3922559d600a27c7ee8d5697e0a9d592">is_c</a> (char trans)</td></tr>
<tr class="memdesc:a3922559d600a27c7ee8d5697e0a9d592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <b>trans</b> is upper or lower case 'C'. <br /></td></tr>
<tr class="separator:a3922559d600a27c7ee8d5697e0a9d592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad722c3b1b9afcd56eebb389b1a2447d5"><td class="memItemLeft" align="right" valign="top"><a id="ad722c3b1b9afcd56eebb389b1a2447d5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#ad722c3b1b9afcd56eebb389b1a2447d5">is_l</a> (char side)</td></tr>
<tr class="memdesc:ad722c3b1b9afcd56eebb389b1a2447d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <b>true</b> if <b>side</b> is upper or lower case 'L'. <br /></td></tr>
<tr class="separator:ad722c3b1b9afcd56eebb389b1a2447d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98850706b7be2eb74266c994d1030a37"><td class="memTemplParams" colspan="2">template&lt;typename IntA , typename IntB &gt; </td></tr>
<tr class="memitem:a98850706b7be2eb74266c994d1030a37"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a98850706b7be2eb74266c994d1030a37">hala_size</a> (IntA a, IntB b)</td></tr>
<tr class="separator:a98850706b7be2eb74266c994d1030a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae23b85f0bdb359210cfcb187b5b66080"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALACORE.html#gae23b85f0bdb359210cfcb187b5b66080">runtime_assert</a> (bool pass, std::string message)</td></tr>
<tr class="memdesc:gae23b85f0bdb359210cfcb187b5b66080"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <b>pass</b> is false, it throws <b>runtime_error()</b> with the given message. <br /></td></tr>
<tr class="separator:gae23b85f0bdb359210cfcb187b5b66080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga830472d103ac598f3ca1c5204a5c0991"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:ga830472d103ac598f3ca1c5204a5c0991"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACPUENGINE.html#ga830472d103ac598f3ca1c5204a5c0991">new_vector</a> (<a class="el" href="structhala_1_1cpu__engine.html">cpu_engine</a> const &amp;engine, VectorLike const &amp;)</td></tr>
<tr class="memdesc:ga830472d103ac598f3ca1c5204a5c0991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a default vector with the default constructor.  <a href="group__HALACPUENGINE.html#ga830472d103ac598f3ca1c5204a5c0991">More...</a><br /></td></tr>
<tr class="separator:ga830472d103ac598f3ca1c5204a5c0991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62920b87c52ab7902af228d770896fb5"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:ga62920b87c52ab7902af228d770896fb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACPUENGINE.html#ga62920b87c52ab7902af228d770896fb5">set_zero</a> (size_t num_entries, VectorLike &amp;&amp;x)</td></tr>
<tr class="memdesc:ga62920b87c52ab7902af228d770896fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the first <b>num_entries</b> of a vector with zeros.  <a href="group__HALACPUENGINE.html#ga62920b87c52ab7902af228d770896fb5">More...</a><br /></td></tr>
<tr class="separator:ga62920b87c52ab7902af228d770896fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1754bbdc7b056afb54044fc35bd4d015"><td class="memTemplParams" colspan="2">template&lt;typename ArrayType &gt; </td></tr>
<tr class="memitem:ga1754bbdc7b056afb54044fc35bd4d015"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACPUENGINE.html#ga1754bbdc7b056afb54044fc35bd4d015">wrap_array</a> (<a class="el" href="structhala_1_1cpu__engine.html">cpu_engine</a> const &amp;, ArrayType arr[], size_t num_entries)</td></tr>
<tr class="memdesc:ga1754bbdc7b056afb54044fc35bd4d015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an array wrapper for the corresponding engine.  <a href="group__HALACPUENGINE.html#ga1754bbdc7b056afb54044fc35bd4d015">More...</a><br /></td></tr>
<tr class="separator:ga1754bbdc7b056afb54044fc35bd4d015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1261252b2b2088f5bfd449ed2496ab4d"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1261252b2b2088f5bfd449ed2496ab4d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACTYPES.html#ga1261252b2b2088f5bfd449ed2496ab4d">creal</a> (T const x)</td></tr>
<tr class="memdesc:ga1261252b2b2088f5bfd449ed2496ab4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the real part of <b>x</b>. <br /></td></tr>
<tr class="separator:ga1261252b2b2088f5bfd449ed2496ab4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2445e5d4f61f21fd7a95207f134b7ee"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf2445e5d4f61f21fd7a95207f134b7ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACTYPES.html#gaf2445e5d4f61f21fd7a95207f134b7ee">cimag</a> (T const x)</td></tr>
<tr class="memdesc:gaf2445e5d4f61f21fd7a95207f134b7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex part of <b>x</b>. <br /></td></tr>
<tr class="separator:gaf2445e5d4f61f21fd7a95207f134b7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2150d29d12084dfd095bb69ff6d0f56f"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2150d29d12084dfd095bb69ff6d0f56f"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACTYPES.html#ga2150d29d12084dfd095bb69ff6d0f56f">cconj</a> (T const x)</td></tr>
<tr class="memdesc:ga2150d29d12084dfd095bb69ff6d0f56f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate of a number, note that the returned type always matches <b>x</b>. <br /></td></tr>
<tr class="separator:ga2150d29d12084dfd095bb69ff6d0f56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee99633ebb74762ab996c1672f2c805"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaeee99633ebb74762ab996c1672f2c805"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACTYPES.html#gaeee99633ebb74762ab996c1672f2c805">hala_abs</a> (T const x)</td></tr>
<tr class="memdesc:gaeee99633ebb74762ab996c1672f2c805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of a number, real or complex, standard or custom. <br /></td></tr>
<tr class="separator:gaeee99633ebb74762ab996c1672f2c805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bb288a038255685ad7c8273cee53e0"><td class="memTemplParams" colspan="2"><a id="a81bb288a038255685ad7c8273cee53e0"></a>
template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:a81bb288a038255685ad7c8273cee53e0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a81bb288a038255685ad7c8273cee53e0">get_standard_data</a> (VectorLike &amp;x)</td></tr>
<tr class="memdesc:a81bb288a038255685ad7c8273cee53e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using reinterpret_cast, get a raw-array of type matching the base. <br /></td></tr>
<tr class="separator:a81bb288a038255685ad7c8273cee53e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ab5a58ae697cc382a735064f06c9ce"><td class="memTemplParams" colspan="2"><a id="af9ab5a58ae697cc382a735064f06c9ce"></a>
template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:af9ab5a58ae697cc382a735064f06c9ce"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#af9ab5a58ae697cc382a735064f06c9ce">get_standard_data</a> (VectorLike const &amp;x)</td></tr>
<tr class="memdesc:af9ab5a58ae697cc382a735064f06c9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using reinterpret_cast, get a raw-array of type matching the base (const overload). <br /></td></tr>
<tr class="separator:af9ab5a58ae697cc382a735064f06c9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f4cd15d6f2fee76d37a6543539b6a4"><td class="memTemplParams" colspan="2"><a id="a15f4cd15d6f2fee76d37a6543539b6a4"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a15f4cd15d6f2fee76d37a6543539b6a4"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a15f4cd15d6f2fee76d37a6543539b6a4">get_cast</a> (U x)</td></tr>
<tr class="memdesc:a15f4cd15d6f2fee76d37a6543539b6a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a number into a new type, or copy if the type is the same. <br /></td></tr>
<tr class="separator:a15f4cd15d6f2fee76d37a6543539b6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f569cff6185ec959911b50370e6af9"><td class="memTemplParams" colspan="2"><a id="ac5f569cff6185ec959911b50370e6af9"></a>
template&lt;class VectorLike , typename SizeType &gt; </td></tr>
<tr class="memitem:ac5f569cff6185ec959911b50370e6af9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ac5f569cff6185ec959911b50370e6af9">check_size</a> (VectorLike &amp;x, SizeType required_size)</td></tr>
<tr class="memdesc:ac5f569cff6185ec959911b50370e6af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <b>get_size(x)</b> is no less than <b>required_size</b>, also calls static cast to <b>size_t</b> to avoid extraneous warnings. <br /></td></tr>
<tr class="separator:ac5f569cff6185ec959911b50370e6af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac721b879ce964f3ed25f5f65306c85dd"><td class="memTemplParams" colspan="2"><a id="ac721b879ce964f3ed25f5f65306c85dd"></a>
template&lt;class VectorLike , typename SizeTypeA , typename SizeTypeB &gt; </td></tr>
<tr class="memitem:ac721b879ce964f3ed25f5f65306c85dd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ac721b879ce964f3ed25f5f65306c85dd">check_size</a> (VectorLike &amp;x, SizeTypeA required_sizeA, SizeTypeB required_sizeB)</td></tr>
<tr class="memdesc:ac721b879ce964f3ed25f5f65306c85dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if <b>get_size(x)</b> is no less than the product of <b>required_sizeA</b> and <b>required_sizeB</b>, also calls static cast to <b>size_t</b> to avoid extraneous warnings. <br /></td></tr>
<tr class="separator:ac721b879ce964f3ed25f5f65306c85dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a221a072d52df2fc701b26836835bd"><td class="memTemplParams" colspan="2">template&lt;class VectorLike , typename SizeType &gt; </td></tr>
<tr class="memitem:a22a221a072d52df2fc701b26836835bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a22a221a072d52df2fc701b26836835bd">check_set_size</a> (bool strict_output, VectorLike &amp;x, SizeType required_size)</td></tr>
<tr class="memdesc:a22a221a072d52df2fc701b26836835bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <b>x</b> is strictly used as output and if the size is insufficient, then resize it; otherwise call assert <a class="el" href="namespacehala.html#ac5f569cff6185ec959911b50370e6af9" title="Return true if get_size(x) is no less than required_size, also calls static cast to size_t to avoid e...">check_size()</a>.  <a href="#a22a221a072d52df2fc701b26836835bd">More...</a><br /></td></tr>
<tr class="separator:a22a221a072d52df2fc701b26836835bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7588344969e24ca01cae74737af4a81"><td class="memTemplParams" colspan="2">template&lt;class VectorLike , typename SizeTypeA , typename SizeTypeB &gt; </td></tr>
<tr class="memitem:af7588344969e24ca01cae74737af4a81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#af7588344969e24ca01cae74737af4a81">check_set_size</a> (bool strict_output, VectorLike &amp;x, SizeTypeA required_sizeA, SizeTypeB required_sizeB)</td></tr>
<tr class="memdesc:af7588344969e24ca01cae74737af4a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using required size as the product of two numbers.  <a href="#af7588344969e24ca01cae74737af4a81">More...</a><br /></td></tr>
<tr class="separator:af7588344969e24ca01cae74737af4a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f2742cfa24e63db2ac9bdda4af918f"><td class="memTemplParams" colspan="2"><a id="ab5f2742cfa24e63db2ac9bdda4af918f"></a>
template&lt;class VectorLike , typename SizeType &gt; </td></tr>
<tr class="memitem:ab5f2742cfa24e63db2ac9bdda4af918f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ab5f2742cfa24e63db2ac9bdda4af918f">force_size</a> (SizeType required_size, VectorLike &amp;x)</td></tr>
<tr class="memdesc:ab5f2742cfa24e63db2ac9bdda4af918f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <b>get_size(x)</b> is not equal to the <b>required_size</b>, then call <b><a class="el" href="group__HALACUSTOM.html#ga957f659d97426f04b2060bceb9d90fee" title="Set new size for the VectorLike, called only if get_size(x) is not sufficient and it uses ...">hala::set_size()</a></b>. <br /></td></tr>
<tr class="separator:ab5f2742cfa24e63db2ac9bdda4af918f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2473b505275b0ddcb9bf0b22382bacf8"><td class="memTemplParams" colspan="2"><a id="a2473b505275b0ddcb9bf0b22382bacf8"></a>
template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:a2473b505275b0ddcb9bf0b22382bacf8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a2473b505275b0ddcb9bf0b22382bacf8">check_types</a> (VectorLike const &amp;)</td></tr>
<tr class="memdesc:a2473b505275b0ddcb9bf0b22382bacf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static asserts that the value_type of <b>VectorLike</b> is one of float, double, complex&lt;float&gt;, complex&lt;double&gt;. <br /></td></tr>
<tr class="separator:a2473b505275b0ddcb9bf0b22382bacf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c661f584d4c3b9d3268276692eb155"><td class="memTemplParams" colspan="2"><a id="a04c661f584d4c3b9d3268276692eb155"></a>
template&lt;class VectorLike1 , class VectorLike2 &gt; </td></tr>
<tr class="memitem:a04c661f584d4c3b9d3268276692eb155"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a04c661f584d4c3b9d3268276692eb155">match_types</a> (VectorLike1 const &amp;, VectorLike2 const &amp;)</td></tr>
<tr class="memdesc:a04c661f584d4c3b9d3268276692eb155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates variadric recustion, runs a static assert that the types of <b>VectorLike1</b> and <b>VectorLike2</b> match. <br /></td></tr>
<tr class="separator:a04c661f584d4c3b9d3268276692eb155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e416655393808f61c1e0eb2fa0dabfe"><td class="memTemplParams" colspan="2"><a id="a6e416655393808f61c1e0eb2fa0dabfe"></a>
template&lt;class VectorLike1 , class VectorLike2 , class VectorLike3 , class... MoreVectorLikes&gt; </td></tr>
<tr class="memitem:a6e416655393808f61c1e0eb2fa0dabfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a6e416655393808f61c1e0eb2fa0dabfe">match_types</a> (VectorLike1 const &amp;x, VectorLike2 const &amp;y, VectorLike3 const &amp;z, MoreVectorLikes const &amp;... more_vecs)</td></tr>
<tr class="memdesc:a6e416655393808f61c1e0eb2fa0dabfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effectively instantiates <b>match_types</b> with <b>VectorLike1</b> and every vector type <b>VectorLike2</b>, <b>VectorLike3</b> and <b>MoreVectorLikes</b>. <br /></td></tr>
<tr class="separator:a6e416655393808f61c1e0eb2fa0dabfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67f84d1bf275c328e61ee57b24fc408"><td class="memTemplParams" colspan="2"><a id="ac67f84d1bf275c328e61ee57b24fc408"></a>
template&lt;class VectorLike , class... MoreVectorLikes&gt; </td></tr>
<tr class="memitem:ac67f84d1bf275c328e61ee57b24fc408"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ac67f84d1bf275c328e61ee57b24fc408">check_types</a> (VectorLike const &amp;x, MoreVectorLikes const &amp;...more_vecs)</td></tr>
<tr class="memdesc:ac67f84d1bf275c328e61ee57b24fc408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <b>check_vector</b> on <b>VectorLike</b> and then uses <b><a class="el" href="namespacehala.html#a04c661f584d4c3b9d3268276692eb155" title="Terminates variadric recustion, runs a static assert that the types of VectorLike1 and VectorLike2 ma...">match_types()</a></b> to recursively check is all vectors in <b>MoreVectorLikes</b> match. <br /></td></tr>
<tr class="separator:ac67f84d1bf275c328e61ee57b24fc408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1315f78cc98911aed95ac5e68ec6761"><td class="memTemplParams" colspan="2"><a id="ae1315f78cc98911aed95ac5e68ec6761"></a>
template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:ae1315f78cc98911aed95ac5e68ec6761"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ae1315f78cc98911aed95ac5e68ec6761">check_types_int</a> (VectorLike const &amp;)</td></tr>
<tr class="memdesc:ae1315f78cc98911aed95ac5e68ec6761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminates variadric recustion, runs a static assert that the types of <b>VectorLike</b> is <b>int</b>. <br /></td></tr>
<tr class="separator:ae1315f78cc98911aed95ac5e68ec6761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935aa27ad11db0319957e993e0e77067"><td class="memTemplParams" colspan="2"><a id="a935aa27ad11db0319957e993e0e77067"></a>
template&lt;class VectorLike1 , class VectorLike2 , class... MoreVectorLikes&gt; </td></tr>
<tr class="memitem:a935aa27ad11db0319957e993e0e77067"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a935aa27ad11db0319957e993e0e77067">check_types_int</a> (VectorLike1 const &amp;x, VectorLike2 const &amp;y, MoreVectorLikes const &amp;... more_vecs)</td></tr>
<tr class="memdesc:a935aa27ad11db0319957e993e0e77067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks with <b>static_assert</b> if every vector has type <b>int</b>. <br /></td></tr>
<tr class="separator:a935aa27ad11db0319957e993e0e77067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46a9f833ff7c0b4fb3c86adc5127f45"><td class="memTemplParams" colspan="2"><a id="ab46a9f833ff7c0b4fb3c86adc5127f45"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab46a9f833ff7c0b4fb3c86adc5127f45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhala_1_1convert__pointer.html">convert_pointer</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ab46a9f833ff7c0b4fb3c86adc5127f45">pconvert</a> (T *pntr)</td></tr>
<tr class="memdesc:ab46a9f833ff7c0b4fb3c86adc5127f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the pointer using <b><a class="el" href="structhala_1_1convert__pointer.html" title="Structure that wraps around a pointer and automatically casts it to any other pointer type...">hala::convert_pointer</a></b>. <br /></td></tr>
<tr class="separator:ab46a9f833ff7c0b4fb3c86adc5127f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad966be151711e5f1aa3f0ee81c6c45f4"><td class="memTemplParams" colspan="2"><a id="ad966be151711e5f1aa3f0ee81c6c45f4"></a>
template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:ad966be151711e5f1aa3f0ee81c6c45f4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ad966be151711e5f1aa3f0ee81c6c45f4">convert</a> (VectorLike &amp;x)</td></tr>
<tr class="memdesc:ad966be151711e5f1aa3f0ee81c6c45f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the pointer using <b><a class="el" href="structhala_1_1convert__pointer.html" title="Structure that wraps around a pointer and automatically casts it to any other pointer type...">hala::convert_pointer</a></b>. <br /></td></tr>
<tr class="separator:ad966be151711e5f1aa3f0ee81c6c45f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3640648d350efab4a287cb3491e92ecb"><td class="memTemplParams" colspan="2"><a id="a3640648d350efab4a287cb3491e92ecb"></a>
template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:a3640648d350efab4a287cb3491e92ecb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a3640648d350efab4a287cb3491e92ecb">cconvert</a> (VectorLike &amp;&amp;x)</td></tr>
<tr class="memdesc:a3640648d350efab4a287cb3491e92ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the non-const pointer using <b><a class="el" href="structhala_1_1convert__pointer.html" title="Structure that wraps around a pointer and automatically casts it to any other pointer type...">hala::convert_pointer</a></b>. <br /></td></tr>
<tr class="separator:a3640648d350efab4a287cb3491e92ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c64c3229f624079a6c31fb4c0444716"><td class="memTemplParams" colspan="2"><a id="a1c64c3229f624079a6c31fb4c0444716"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1c64c3229f624079a6c31fb4c0444716"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a1c64c3229f624079a6c31fb4c0444716">check_gpu_type</a> ()</td></tr>
<tr class="memdesc:a1c64c3229f624079a6c31fb4c0444716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs <b>static_assert</b> on T, permits int in addition to the floating point types. <br /></td></tr>
<tr class="separator:a1c64c3229f624079a6c31fb4c0444716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1fc5c5c97af376246b7ff14394eb95"><td class="memTemplParams" colspan="2"><a id="a6d1fc5c5c97af376246b7ff14394eb95"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d1fc5c5c97af376246b7ff14394eb95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a6d1fc5c5c97af376246b7ff14394eb95">get_pointer</a> (T const *p)</td></tr>
<tr class="memdesc:a6d1fc5c5c97af376246b7ff14394eb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">If given a pointer, simply use the pointer. <br /></td></tr>
<tr class="separator:a6d1fc5c5c97af376246b7ff14394eb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c41de8b709f9847b5c266a415cee31"><td class="memTemplParams" colspan="2"><a id="ac7c41de8b709f9847b5c266a415cee31"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ac7c41de8b709f9847b5c266a415cee31"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; !std::is_pointer&lt; U &gt;::value, <a class="el" href="structhala_1_1gpu__pconvert.html">gpu_pconvert</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ac7c41de8b709f9847b5c266a415cee31">get_pointer</a> (U x)</td></tr>
<tr class="memdesc:ac7c41de8b709f9847b5c266a415cee31"><td class="mdescLeft">&#160;</td><td class="mdescRight">If given a value, convert it to a host pointer. <br /></td></tr>
<tr class="separator:ac7c41de8b709f9847b5c266a415cee31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8da04eaa2d4b55fa0075c08b9bfef3"><td class="memTemplParams" colspan="2">template&lt;typename FPB , typename VectorLike , typename IntA , typename IntB &gt; </td></tr>
<tr class="memitem:a6b8da04eaa2d4b55fa0075c08b9bfef3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; !std::is_pointer&lt; FPB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a6b8da04eaa2d4b55fa0075c08b9bfef3">pntr_check_set_size</a> (FPB beta, VectorLike &amp;C, IntA M, IntB N)</td></tr>
<tr class="memdesc:a6b8da04eaa2d4b55fa0075c08b9bfef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <b>beta</b> is not a pointer, then check if it is zero and resize C if necessary.  <a href="#a6b8da04eaa2d4b55fa0075c08b9bfef3">More...</a><br /></td></tr>
<tr class="separator:a6b8da04eaa2d4b55fa0075c08b9bfef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e501ba14bd3d909073ecc4add8b639"><td class="memTemplParams" colspan="2"><a id="a66e501ba14bd3d909073ecc4add8b639"></a>
template&lt;typename FPB , typename VectorLike , typename IntA , typename IntB &gt; </td></tr>
<tr class="memitem:a66e501ba14bd3d909073ecc4add8b639"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_pointer&lt; FPB &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a66e501ba14bd3d909073ecc4add8b639">pntr_check_set_size</a> (FPB, VectorLike &amp;C, IntA M, IntB N)</td></tr>
<tr class="memdesc:a66e501ba14bd3d909073ecc4add8b639"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <b>beta</b> is a pointer, do nothing. <br /></td></tr>
<tr class="separator:a66e501ba14bd3d909073ecc4add8b639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458b10b5d0de03107488fb746190aa5b"><td class="memTemplParams" colspan="2"><a id="a458b10b5d0de03107488fb746190aa5b"></a>
template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:a458b10b5d0de03107488fb746190aa5b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a458b10b5d0de03107488fb746190aa5b">get_device</a> (VectorLike &amp;x)</td></tr>
<tr class="memdesc:a458b10b5d0de03107488fb746190aa5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the GPU device ID associated with the <b>VectorLike</b>, result will be ignored unless this or <b><a class="el" href="structhala_1_1deviceid__extractor.html" title="Struct the reads the GPU device ID associated with the VectorLike, result will be ignored unless spec...">hala::deviceid_extractor</a></b> are specialized. <br /></td></tr>
<tr class="separator:a458b10b5d0de03107488fb746190aa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008958f065be0ba7ec19336dcac08f14"><td class="memTemplParams" colspan="2"><a id="a008958f065be0ba7ec19336dcac08f14"></a>
template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:a008958f065be0ba7ec19336dcac08f14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a008958f065be0ba7ec19336dcac08f14">get_back</a> (VectorLike const &amp;x)</td></tr>
<tr class="memdesc:a008958f065be0ba7ec19336dcac08f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last entry of the vector, e.g., useful when the last entry is the number of non-zeros. <br /></td></tr>
<tr class="separator:a008958f065be0ba7ec19336dcac08f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada3048131102af6636985a61bad422e5"><td class="memTemplParams" colspan="2">template&lt;typename criteria , typename Fsingle , typename Fdouble , typename Fcomplex , typename Fzomplex , class... Inputs&gt; </td></tr>
<tr class="memitem:ada3048131102af6636985a61bad422e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ada3048131102af6636985a61bad422e5">call_backend</a> (Fsingle &amp;sfunc, Fdouble &amp;dfunc, Fcomplex &amp;cfunc, Fzomplex &amp;zfunc, Inputs &amp;&amp;...args)</td></tr>
<tr class="memdesc:ada3048131102af6636985a61bad422e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call one of the 4 possible functions according to the <b>criteria</b>.  <a href="#ada3048131102af6636985a61bad422e5">More...</a><br /></td></tr>
<tr class="separator:ada3048131102af6636985a61bad422e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0830dc4e08216100f6642e74fe261033"><td class="memTemplParams" colspan="2">template&lt;typename criteria , typename Fsingle , typename Fdouble , class... Inputs&gt; </td></tr>
<tr class="memitem:a0830dc4e08216100f6642e74fe261033"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a0830dc4e08216100f6642e74fe261033">call_backend2</a> (Fsingle &amp;sfunc, Fdouble &amp;dfunc, Inputs &amp;&amp;...args)</td></tr>
<tr class="memdesc:a0830dc4e08216100f6642e74fe261033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call one of the 2 possible functions according to the <b>criteria</b>.  <a href="#a0830dc4e08216100f6642e74fe261033">More...</a><br /></td></tr>
<tr class="separator:a0830dc4e08216100f6642e74fe261033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7db1d64d1b8f41150879e541ba0444b"><td class="memTemplParams" colspan="2">template&lt;bool flag, typename criteria , typename Fsingle , typename Fdouble , typename Fcomplex , typename Fzomplex , typename Frcomplex , typename Frzomplex , class... Inputs&gt; </td></tr>
<tr class="memitem:ae7db1d64d1b8f41150879e541ba0444b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ae7db1d64d1b8f41150879e541ba0444b">call_backend6</a> (Fsingle &amp;sfunc, Fdouble &amp;dfunc, Fcomplex &amp;cfunc, Fzomplex &amp;zfunc, Frcomplex &amp;crfunc, Frzomplex &amp;zrfunc, Inputs &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae7db1d64d1b8f41150879e541ba0444b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call one of the 6 possible functions according to the <b>criteria</b>.  <a href="#ae7db1d64d1b8f41150879e541ba0444b">More...</a><br /></td></tr>
<tr class="separator:ae7db1d64d1b8f41150879e541ba0444b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb23ab0a92ecead8007cf9aa8dc972db"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:gacb23ab0a92ecead8007cf9aa8dc972db"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACUSTOM.html#gacb23ab0a92ecead8007cf9aa8dc972db">get_size</a> (VectorLike const &amp;x)</td></tr>
<tr class="memdesc:gacb23ab0a92ecead8007cf9aa8dc972db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of entries in the vector, if <b>VectorLike</b> does not have <b></b>.size() method, then the template must be specialized.  <a href="group__HALACUSTOM.html#gacb23ab0a92ecead8007cf9aa8dc972db">More...</a><br /></td></tr>
<tr class="separator:gacb23ab0a92ecead8007cf9aa8dc972db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e761656c953c9fa8646a208c7321eda"><td class="memTemplParams" colspan="2"><a id="a9e761656c953c9fa8646a208c7321eda"></a>
template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:a9e761656c953c9fa8646a208c7321eda"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a9e761656c953c9fa8646a208c7321eda">get_size_int</a> (VectorLike const &amp;x)</td></tr>
<tr class="memdesc:a9e761656c953c9fa8646a208c7321eda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the output of <b><a class="el" href="group__HALACUSTOM.html#gacb23ab0a92ecead8007cf9aa8dc972db" title="Returns the number of entries in the vector, if VectorLike does not have .size() method, then the template must be specialized. ">get_size()</a></b> and type-cast it to <b>int</b>. <br /></td></tr>
<tr class="separator:a9e761656c953c9fa8646a208c7321eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga957f659d97426f04b2060bceb9d90fee"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:ga957f659d97426f04b2060bceb9d90fee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACUSTOM.html#ga957f659d97426f04b2060bceb9d90fee">set_size</a> (size_t new_size, VectorLike &amp;x)</td></tr>
<tr class="memdesc:ga957f659d97426f04b2060bceb9d90fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set new size for the <b>VectorLike</b>, called only if <b>get_size(x)</b> is not sufficient and it uses <b></b>.resize() method.  <a href="group__HALACUSTOM.html#ga957f659d97426f04b2060bceb9d90fee">More...</a><br /></td></tr>
<tr class="separator:ga957f659d97426f04b2060bceb9d90fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee2b3b81522284482c1196d20ed0635"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:gaeee2b3b81522284482c1196d20ed0635"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACUSTOM.html#gaeee2b3b81522284482c1196d20ed0635">get_data</a> (VectorLike &amp;x)</td></tr>
<tr class="memdesc:gaeee2b3b81522284482c1196d20ed0635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to the internal contiguous array stored in the <b>VectorLike</b>.  <a href="group__HALACUSTOM.html#gaeee2b3b81522284482c1196d20ed0635">More...</a><br /></td></tr>
<tr class="separator:gaeee2b3b81522284482c1196d20ed0635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97c2a161aa9d137f6490adb3142e5b36"><td class="memTemplParams" colspan="2">
template&lt;typename ArrayType &gt; </td></tr>
<tr class="memitem:ga97c2a161aa9d137f6490adb3142e5b36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhala_1_1wrapped__array.html">wrapped_array</a>&lt; ArrayType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAARRAY.html#ga97c2a161aa9d137f6490adb3142e5b36">wrap_array</a> (ArrayType arr[], size_t num_entries)</td></tr>
<tr class="memdesc:ga97c2a161aa9d137f6490adb3142e5b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a wrapper around the C-style arrays that can be passed to HALA templates. <br /></td></tr>
<tr class="separator:ga97c2a161aa9d137f6490adb3142e5b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga199fd708ca4ff8b2c65b6ee47491b37d"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga199fd708ca4ff8b2c65b6ee47491b37d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">vcopy</a> (int N, VectorLikeX const &amp;x, int incx, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga199fd708ca4ff8b2c65b6ee47491b37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS xcopy() methods.  <a href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">More...</a><br /></td></tr>
<tr class="separator:ga199fd708ca4ff8b2c65b6ee47491b37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2809dfc1c6ae1f53eb9f59d68f23c7b0"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga2809dfc1c6ae1f53eb9f59d68f23c7b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga2809dfc1c6ae1f53eb9f59d68f23c7b0">vswap</a> (int N, VectorLikeX &amp;&amp;x, int incx, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga2809dfc1c6ae1f53eb9f59d68f23c7b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS xswap() methods.  <a href="group__HALABLAS1.html#ga2809dfc1c6ae1f53eb9f59d68f23c7b0">More...</a><br /></td></tr>
<tr class="separator:ga2809dfc1c6ae1f53eb9f59d68f23c7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48f8d9b686ef4a9cdb69897e3f22bbe5"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga48f8d9b686ef4a9cdb69897e3f22bbe5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga48f8d9b686ef4a9cdb69897e3f22bbe5">norm2</a> (int N, VectorLikeX const &amp;x, int incx)</td></tr>
<tr class="memdesc:ga48f8d9b686ef4a9cdb69897e3f22bbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS vector 2-norm.  <a href="group__HALABLAS1.html#ga48f8d9b686ef4a9cdb69897e3f22bbe5">More...</a><br /></td></tr>
<tr class="separator:ga48f8d9b686ef4a9cdb69897e3f22bbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2690240bc40fc865a64a9acc7cce06b5"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga2690240bc40fc865a64a9acc7cce06b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga2690240bc40fc865a64a9acc7cce06b5">asum</a> (int N, VectorLikeX const &amp;x, int incx)</td></tr>
<tr class="memdesc:ga2690240bc40fc865a64a9acc7cce06b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS vector sum of absolute values of the entry components.  <a href="group__HALABLAS1.html#ga2690240bc40fc865a64a9acc7cce06b5">More...</a><br /></td></tr>
<tr class="separator:ga2690240bc40fc865a64a9acc7cce06b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f2f0c0b1c17c7a8ee5fe664fe0d652c"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga4f2f0c0b1c17c7a8ee5fe664fe0d652c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga4f2f0c0b1c17c7a8ee5fe664fe0d652c">iamax</a> (int N, VectorLikeX const &amp;x, int incx)</td></tr>
<tr class="memdesc:ga4f2f0c0b1c17c7a8ee5fe664fe0d652c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS find index of largest vector entry, ixamax().  <a href="group__HALABLAS1.html#ga4f2f0c0b1c17c7a8ee5fe664fe0d652c">More...</a><br /></td></tr>
<tr class="separator:ga4f2f0c0b1c17c7a8ee5fe664fe0d652c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dff938a94c75c58427ede241c05429b"><td class="memTemplParams" colspan="2">template&lt;typename FS , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga0dff938a94c75c58427ede241c05429b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">axpy</a> (int N, FS alpha, VectorLikeX const &amp;x, int incx, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga0dff938a94c75c58427ede241c05429b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS vector scaled addition xaxpy().  <a href="group__HALABLAS1.html#ga0dff938a94c75c58427ede241c05429b">More...</a><br /></td></tr>
<tr class="separator:ga0dff938a94c75c58427ede241c05429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512ac4265c71ac5a1da06f901d1ad077"><td class="memTemplParams" colspan="2">template&lt;bool conjugate, typename T &gt; </td></tr>
<tr class="memitem:a512ac4265c71ac5a1da06f901d1ad077"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a512ac4265c71ac5a1da06f901d1ad077">dot_array</a> (int N, T const x[], int incx, T const y[], int incy)</td></tr>
<tr class="separator:a512ac4265c71ac5a1da06f901d1ad077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55b878e5a1a05ef1c181a879edaa6528"><td class="memTemplParams" colspan="2">template&lt;bool conjugate = true, class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga55b878e5a1a05ef1c181a879edaa6528"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga55b878e5a1a05ef1c181a879edaa6528">dot</a> (int N, VectorLikeX const &amp;x, int incx, VectorLikeY const &amp;y, int incy)</td></tr>
<tr class="memdesc:ga55b878e5a1a05ef1c181a879edaa6528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS vector dot-product xdot().  <a href="group__HALABLAS1.html#ga55b878e5a1a05ef1c181a879edaa6528">More...</a><br /></td></tr>
<tr class="separator:ga55b878e5a1a05ef1c181a879edaa6528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d8f14a164c86b89abbb4e7bfbdca660"><td class="memTemplParams" colspan="2">template&lt;typename FS , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga3d8f14a164c86b89abbb4e7bfbdca660"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga3d8f14a164c86b89abbb4e7bfbdca660">scal</a> (int N, FS alpha, VectorLikeX &amp;&amp;x, int incx)</td></tr>
<tr class="memdesc:ga3d8f14a164c86b89abbb4e7bfbdca660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS vector scale by constant xscal().  <a href="group__HALABLAS1.html#ga3d8f14a164c86b89abbb4e7bfbdca660">More...</a><br /></td></tr>
<tr class="separator:ga3d8f14a164c86b89abbb4e7bfbdca660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d16bf7ce27762641f5a019b7cbd8495"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6d16bf7ce27762641f5a019b7cbd8495"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga6d16bf7ce27762641f5a019b7cbd8495">rotg</a> (T &amp;SA, T &amp;SB, typename <a class="el" href="structhala_1_1define__standard__precision.html">define_standard_precision</a>&lt; T &gt;::value_type &amp;C, T &amp;S)</td></tr>
<tr class="memdesc:ga6d16bf7ce27762641f5a019b7cbd8495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS generate Givens rotation, xrotg().  <a href="group__HALABLAS1.html#ga6d16bf7ce27762641f5a019b7cbd8495">More...</a><br /></td></tr>
<tr class="separator:ga6d16bf7ce27762641f5a019b7cbd8495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc25006cc0ab0a6befa1b7af6ab18e91"><td class="memTemplParams" colspan="2">template&lt;typename FC , typename FS , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:gafc25006cc0ab0a6befa1b7af6ab18e91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#gafc25006cc0ab0a6befa1b7af6ab18e91">rot</a> (int N, VectorLikeX &amp;&amp;x, int incx, VectorLikeY &amp;&amp;y, int incy, FC C, FS S)</td></tr>
<tr class="memdesc:gafc25006cc0ab0a6befa1b7af6ab18e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS apply the Givens rotation, xrot().  <a href="group__HALABLAS1.html#gafc25006cc0ab0a6befa1b7af6ab18e91">More...</a><br /></td></tr>
<tr class="separator:gafc25006cc0ab0a6befa1b7af6ab18e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d34e87ad9216f7838bb02ea978d5f64"><td class="memTemplParams" colspan="2">template&lt;typename T , class VectorLike &gt; </td></tr>
<tr class="memitem:ga7d34e87ad9216f7838bb02ea978d5f64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga7d34e87ad9216f7838bb02ea978d5f64">rotmg</a> (T &amp;D1, T &amp;D2, T &amp;X, T const &amp;Y, VectorLike &amp;&amp;param)</td></tr>
<tr class="memdesc:ga7d34e87ad9216f7838bb02ea978d5f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS generate modified Givens rotation.  <a href="group__HALABLAS1.html#ga7d34e87ad9216f7838bb02ea978d5f64">More...</a><br /></td></tr>
<tr class="separator:ga7d34e87ad9216f7838bb02ea978d5f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67aa0d17df77921cd1e3d4b59fafb6ab"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX , class VectorLikeY , class VectorLikeP &gt; </td></tr>
<tr class="memitem:ga67aa0d17df77921cd1e3d4b59fafb6ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga67aa0d17df77921cd1e3d4b59fafb6ab">rotm</a> (int N, VectorLikeX &amp;&amp;x, int incx, VectorLikeY &amp;&amp;y, int incy, VectorLikeP const &amp;param)</td></tr>
<tr class="memdesc:ga67aa0d17df77921cd1e3d4b59fafb6ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS apply the Givens rotation, xrotm().  <a href="group__HALABLAS1.html#ga67aa0d17df77921cd1e3d4b59fafb6ab">More...</a><br /></td></tr>
<tr class="separator:ga67aa0d17df77921cd1e3d4b59fafb6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga925bf0c14261ed419bb931e85658f6eb"><td class="memTemplParams" colspan="2">template&lt;typename FSa , typename FSb , class VectorLikeA , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga925bf0c14261ed419bb931e85658f6eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#ga925bf0c14261ed419bb931e85658f6eb">gemv</a> (char trans, int M, int N, FSa alpha, const VectorLikeA &amp;A, int lda, const VectorLikeX &amp;x, int incx, FSb beta, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga925bf0c14261ed419bb931e85658f6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS general matrix-vector multiply xgemv().  <a href="group__HALABLAS2.html#ga925bf0c14261ed419bb931e85658f6eb">More...</a><br /></td></tr>
<tr class="separator:ga925bf0c14261ed419bb931e85658f6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66d692d6f53390614c17005b6cf68a9a"><td class="memTemplParams" colspan="2">template&lt;typename FSa , typename FSb , class VectorLikeA , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga66d692d6f53390614c17005b6cf68a9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#ga66d692d6f53390614c17005b6cf68a9a">gbmv</a> (char trans, int M, int N, int kl, int ku, FSa alpha, const VectorLikeA &amp;A, int lda, const VectorLikeX &amp;x, int incx, FSb beta, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga66d692d6f53390614c17005b6cf68a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS general banded matrix-vector multiply xgbmv().  <a href="group__HALABLAS2.html#ga66d692d6f53390614c17005b6cf68a9a">More...</a><br /></td></tr>
<tr class="separator:ga66d692d6f53390614c17005b6cf68a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6455a4464f0792f0b8e79d904ccea5c7"><td class="memTemplParams" colspan="2">template&lt;bool conjugate = false, typename FSa , typename FSb , class VectorLikeA , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga6455a4464f0792f0b8e79d904ccea5c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#ga6455a4464f0792f0b8e79d904ccea5c7">symv</a> (char uplo, int N, FSa alpha, const VectorLikeA &amp;A, int lda, const VectorLikeX &amp;x, int incx, FSb beta, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga6455a4464f0792f0b8e79d904ccea5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS symmetric or Hermitian matrix-vector multiply xsymv().  <a href="group__HALABLAS2.html#ga6455a4464f0792f0b8e79d904ccea5c7">More...</a><br /></td></tr>
<tr class="separator:ga6455a4464f0792f0b8e79d904ccea5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85d6d8324cb5793642ae29d63d21658a"><td class="memTemplParams" colspan="2">template&lt;bool conjugate = false, typename FSa , typename FSb , class VectorLikeA , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga85d6d8324cb5793642ae29d63d21658a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#ga85d6d8324cb5793642ae29d63d21658a">sbmv</a> (char uplo, int N, int k, FSa alpha, const VectorLikeA &amp;A, int lda, const VectorLikeX &amp;x, int incx, FSb beta, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga85d6d8324cb5793642ae29d63d21658a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS symmetric or Hermitian banded matrix-vector multiply xsbmv().  <a href="group__HALABLAS2.html#ga85d6d8324cb5793642ae29d63d21658a">More...</a><br /></td></tr>
<tr class="separator:ga85d6d8324cb5793642ae29d63d21658a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8564e8f752ccd082449a5985d050da5"><td class="memTemplParams" colspan="2">template&lt;bool conjugate = false, typename FSa , typename FSb , class VectorLikeA , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:gac8564e8f752ccd082449a5985d050da5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#gac8564e8f752ccd082449a5985d050da5">spmv</a> (char uplo, int N, FSa alpha, const VectorLikeA &amp;A, const VectorLikeX &amp;x, int incx, FSb beta, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:gac8564e8f752ccd082449a5985d050da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS symmetric or Hermitian matrix-vector multiply xspmv() in packed format.  <a href="group__HALABLAS2.html#gac8564e8f752ccd082449a5985d050da5">More...</a><br /></td></tr>
<tr class="separator:gac8564e8f752ccd082449a5985d050da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeecc553d9de2eb43ab61941581af918a"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeX &gt; </td></tr>
<tr class="memitem:gaeecc553d9de2eb43ab61941581af918a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#gaeecc553d9de2eb43ab61941581af918a">trmv</a> (char uplo, char trans, char diag, int N, const VectorLikeA &amp;A, int lda, VectorLikeX &amp;&amp;x, int incx)</td></tr>
<tr class="memdesc:gaeecc553d9de2eb43ab61941581af918a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS triangular matrix-vector multiply xtrmv().  <a href="group__HALABLAS2.html#gaeecc553d9de2eb43ab61941581af918a">More...</a><br /></td></tr>
<tr class="separator:gaeecc553d9de2eb43ab61941581af918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5277f0adc6762b3cd4adebe1b637b7f9"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga5277f0adc6762b3cd4adebe1b637b7f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#ga5277f0adc6762b3cd4adebe1b637b7f9">trsv</a> (char uplo, char trans, char diag, int N, const VectorLikeA &amp;A, int lda, VectorLikeX &amp;&amp;x, int incx)</td></tr>
<tr class="memdesc:ga5277f0adc6762b3cd4adebe1b637b7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS triangular matrix-vector solve xtrsv().  <a href="group__HALABLAS2.html#ga5277f0adc6762b3cd4adebe1b637b7f9">More...</a><br /></td></tr>
<tr class="separator:ga5277f0adc6762b3cd4adebe1b637b7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga478bf27f95e6d1db67c5d19df6db8e8b"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga478bf27f95e6d1db67c5d19df6db8e8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#ga478bf27f95e6d1db67c5d19df6db8e8b">tbmv</a> (char uplo, char trans, char diag, int N, int k, const VectorLikeA &amp;A, int lda, VectorLikeX &amp;&amp;x, int incx)</td></tr>
<tr class="memdesc:ga478bf27f95e6d1db67c5d19df6db8e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS triangular banded matrix-vector multiply xtbmv().  <a href="group__HALABLAS2.html#ga478bf27f95e6d1db67c5d19df6db8e8b">More...</a><br /></td></tr>
<tr class="separator:ga478bf27f95e6d1db67c5d19df6db8e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ff50eeb8bb1682349d7a68d2fdfe610"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga9ff50eeb8bb1682349d7a68d2fdfe610"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#ga9ff50eeb8bb1682349d7a68d2fdfe610">tbsv</a> (char uplo, char trans, char diag, int N, int k, const VectorLikeA &amp;A, int lda, VectorLikeX &amp;&amp;x, int incx)</td></tr>
<tr class="memdesc:ga9ff50eeb8bb1682349d7a68d2fdfe610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS triangular matrix-vector solve xtbsv().  <a href="group__HALABLAS2.html#ga9ff50eeb8bb1682349d7a68d2fdfe610">More...</a><br /></td></tr>
<tr class="separator:ga9ff50eeb8bb1682349d7a68d2fdfe610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga475bc96a0943950bfb09d0cb4668fce2"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga475bc96a0943950bfb09d0cb4668fce2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#ga475bc96a0943950bfb09d0cb4668fce2">tpmv</a> (char uplo, char trans, char diag, int N, const VectorLikeA &amp;A, VectorLikeX &amp;&amp;x, int incx=1)</td></tr>
<tr class="memdesc:ga475bc96a0943950bfb09d0cb4668fce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS triangular matrix-vector multiply in packed format xtpmv().  <a href="group__HALABLAS2.html#ga475bc96a0943950bfb09d0cb4668fce2">More...</a><br /></td></tr>
<tr class="separator:ga475bc96a0943950bfb09d0cb4668fce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd6b77f32615c8f05e83a9c703da9cb"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga3cd6b77f32615c8f05e83a9c703da9cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#ga3cd6b77f32615c8f05e83a9c703da9cb">tpsv</a> (char uplo, char trans, char diag, int N, const VectorLikeA &amp;A, VectorLikeX &amp;&amp;x, int incx=1)</td></tr>
<tr class="memdesc:ga3cd6b77f32615c8f05e83a9c703da9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS triangular matrix-vector solve in packed format xtpsv().  <a href="group__HALABLAS2.html#ga3cd6b77f32615c8f05e83a9c703da9cb">More...</a><br /></td></tr>
<tr class="separator:ga3cd6b77f32615c8f05e83a9c703da9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9892a87c910d20dd69b355162106f639"><td class="memTemplParams" colspan="2">template&lt;bool conjugate = true, typename FSa , class VectorLikeX , class VectorLikeY , class VectorLikeA &gt; </td></tr>
<tr class="memitem:ga9892a87c910d20dd69b355162106f639"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#ga9892a87c910d20dd69b355162106f639">ger</a> (int M, int N, FSa alpha, VectorLikeX const &amp;x, int incx, VectorLikeY const &amp;y, int incy, VectorLikeA &amp;&amp;A, int lda)</td></tr>
<tr class="memdesc:ga9892a87c910d20dd69b355162106f639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS general rank-1 update xgerx().  <a href="group__HALABLAS2.html#ga9892a87c910d20dd69b355162106f639">More...</a><br /></td></tr>
<tr class="separator:ga9892a87c910d20dd69b355162106f639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73979f45fda60503c0bb5fda9676aff5"><td class="memTemplParams" colspan="2">template&lt;bool conjugate = false, typename FSa , class VectorLikeX , class VectorLikeA &gt; </td></tr>
<tr class="memitem:ga73979f45fda60503c0bb5fda9676aff5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#ga73979f45fda60503c0bb5fda9676aff5">syr</a> (char uplo, int N, FSa alpha, VectorLikeX const &amp;x, int incx, VectorLikeA &amp;&amp;A, int lda)</td></tr>
<tr class="memdesc:ga73979f45fda60503c0bb5fda9676aff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS symmetric or Hermitian rank-1 update xsyr() and xher().  <a href="group__HALABLAS2.html#ga73979f45fda60503c0bb5fda9676aff5">More...</a><br /></td></tr>
<tr class="separator:ga73979f45fda60503c0bb5fda9676aff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e969612f9c482e554cba96b8a1f7b8"><td class="memTemplParams" colspan="2">template&lt;bool conjugate = false, typename FSa , class VectorLikeX , class VectorLikeA &gt; </td></tr>
<tr class="memitem:ga09e969612f9c482e554cba96b8a1f7b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#ga09e969612f9c482e554cba96b8a1f7b8">spr</a> (char uplo, int N, FSa alpha, VectorLikeX const &amp;x, int incx, VectorLikeA &amp;&amp;A)</td></tr>
<tr class="memdesc:ga09e969612f9c482e554cba96b8a1f7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS symmetric or Hermitian rank-1 update using packed format xspr() and xhpr().  <a href="group__HALABLAS2.html#ga09e969612f9c482e554cba96b8a1f7b8">More...</a><br /></td></tr>
<tr class="separator:ga09e969612f9c482e554cba96b8a1f7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac51cb0c2069759ab18a212564412111"><td class="memTemplParams" colspan="2">template&lt;bool conjugate = false, typename FSa , class VectorLikeX , class VectorLikeY , class VectorLikeA &gt; </td></tr>
<tr class="memitem:gaac51cb0c2069759ab18a212564412111"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#gaac51cb0c2069759ab18a212564412111">syr2</a> (char uplo, int N, FSa alpha, VectorLikeX const &amp;x, int incx, VectorLikeY const &amp;y, int incy, VectorLikeA &amp;&amp;A, int lda)</td></tr>
<tr class="memdesc:gaac51cb0c2069759ab18a212564412111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS symmetric or Hermitian rank-2 update xsyr2() and xher2().  <a href="group__HALABLAS2.html#gaac51cb0c2069759ab18a212564412111">More...</a><br /></td></tr>
<tr class="separator:gaac51cb0c2069759ab18a212564412111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55dcd6616fb7fbe0e918c86c9f59c295"><td class="memTemplParams" colspan="2">template&lt;bool conjugate = false, typename FSa , class VectorLikeX , class VectorLikeY , class VectorLikeA &gt; </td></tr>
<tr class="memitem:ga55dcd6616fb7fbe0e918c86c9f59c295"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS2.html#ga55dcd6616fb7fbe0e918c86c9f59c295">spr2</a> (char uplo, int N, FSa alpha, VectorLikeX const &amp;x, int incx, VectorLikeY const &amp;y, int incy, VectorLikeA &amp;&amp;A)</td></tr>
<tr class="memdesc:ga55dcd6616fb7fbe0e918c86c9f59c295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS symmetric or Hermitian rank-2 update in packed format xspr2() and xhpr2().  <a href="group__HALABLAS2.html#ga55dcd6616fb7fbe0e918c86c9f59c295">More...</a><br /></td></tr>
<tr class="separator:ga55dcd6616fb7fbe0e918c86c9f59c295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76b9027b698b804e16553c0ad6f8f952"><td class="memTemplParams" colspan="2">template&lt;typename FS , class VectorLikeA , class VectorLikeB &gt; </td></tr>
<tr class="memitem:ga76b9027b698b804e16553c0ad6f8f952"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS3.html#ga76b9027b698b804e16553c0ad6f8f952">trmm</a> (char side, char uplo, char trans, char diag, int M, int N, FS alpha, const VectorLikeA &amp;A, int lda, VectorLikeB &amp;&amp;B, int ldb)</td></tr>
<tr class="memdesc:ga76b9027b698b804e16553c0ad6f8f952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS triangular matrix-matrix multiply xtrmm().  <a href="group__HALABLAS3.html#ga76b9027b698b804e16553c0ad6f8f952">More...</a><br /></td></tr>
<tr class="separator:ga76b9027b698b804e16553c0ad6f8f952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa45d25006e2c87ad9138fda8347b5a"><td class="memTemplParams" colspan="2">template&lt;typename FS , class VectorLikeA , class VectorLikeB &gt; </td></tr>
<tr class="memitem:gaafa45d25006e2c87ad9138fda8347b5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS3.html#gaafa45d25006e2c87ad9138fda8347b5a">trsm</a> (char side, char uplo, char trans, char diag, int M, int N, FS alpha, const VectorLikeA &amp;A, int lda, VectorLikeB &amp;&amp;B, int ldb)</td></tr>
<tr class="memdesc:gaafa45d25006e2c87ad9138fda8347b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS triangular matrix-matrix solve xtrsm().  <a href="group__HALABLAS3.html#gaafa45d25006e2c87ad9138fda8347b5a">More...</a><br /></td></tr>
<tr class="separator:gaafa45d25006e2c87ad9138fda8347b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85ff3bcfb9b27d8e49526edce35051a2"><td class="memTemplParams" colspan="2">template&lt;bool conjugate = false, typename FSa , typename FSb , class VectorLikeA , class VectorLikeC &gt; </td></tr>
<tr class="memitem:ga85ff3bcfb9b27d8e49526edce35051a2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS3.html#ga85ff3bcfb9b27d8e49526edce35051a2">syrk</a> (char uplo, char trans, int N, int K, FSa alpha, VectorLikeA const &amp;A, int lda, FSb beta, VectorLikeC &amp;&amp;C, int ldc)</td></tr>
<tr class="memdesc:ga85ff3bcfb9b27d8e49526edce35051a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS symmetric or Hermitian rank-k matrix update xsyrk()/xherk().  <a href="group__HALABLAS3.html#ga85ff3bcfb9b27d8e49526edce35051a2">More...</a><br /></td></tr>
<tr class="separator:ga85ff3bcfb9b27d8e49526edce35051a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab03a5b3ed217cb6f30961a885925f5d5"><td class="memTemplParams" colspan="2">template&lt;bool conjugate = false, typename FSa , typename FSb , class VectorLikeA , class VectorLikeB , class VectorLikeC &gt; </td></tr>
<tr class="memitem:gab03a5b3ed217cb6f30961a885925f5d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS3.html#gab03a5b3ed217cb6f30961a885925f5d5">syr2k</a> (char uplo, char trans, int N, int K, FSa alpha, VectorLikeA const &amp;A, int lda, VectorLikeB const &amp;B, int ldb, FSb beta, VectorLikeC &amp;&amp;C, int ldc)</td></tr>
<tr class="memdesc:gab03a5b3ed217cb6f30961a885925f5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS symmetric or Hermitian 2x rank-k matrix update xsyr2k()/xher2k().  <a href="group__HALABLAS3.html#gab03a5b3ed217cb6f30961a885925f5d5">More...</a><br /></td></tr>
<tr class="separator:gab03a5b3ed217cb6f30961a885925f5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ba86adc1807ef69a40cc304dacb4f4"><td class="memTemplParams" colspan="2">template&lt;bool conjugate = false, typename FSa , typename FSb , class VectorLikeA , class VectorLikeB , class VectorLikeC &gt; </td></tr>
<tr class="memitem:ga74ba86adc1807ef69a40cc304dacb4f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS3.html#ga74ba86adc1807ef69a40cc304dacb4f4">symm</a> (char side, char uplo, int M, int N, FSa alpha, VectorLikeA const &amp;A, int lda, VectorLikeB const &amp;B, int ldb, FSb beta, VectorLikeC &amp;&amp;C, int ldc)</td></tr>
<tr class="memdesc:ga74ba86adc1807ef69a40cc304dacb4f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS symmetric or Hermitian matrix multiply xsymm()/xhemm().  <a href="group__HALABLAS3.html#ga74ba86adc1807ef69a40cc304dacb4f4">More...</a><br /></td></tr>
<tr class="separator:ga74ba86adc1807ef69a40cc304dacb4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae98fae51e118dc3682284a5d001cd946"><td class="memTemplParams" colspan="2">template&lt;typename FSa , typename FSb , class VectorLikeA , class VectorLikeB , class VectorLikeC &gt; </td></tr>
<tr class="memitem:gae98fae51e118dc3682284a5d001cd946"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS3.html#gae98fae51e118dc3682284a5d001cd946">gemm</a> (char transa, char transb, int M, int N, int K, FSa alpha, VectorLikeA const &amp;A, int lda, VectorLikeB const &amp;B, int ldb, FSb beta, VectorLikeC &amp;&amp;C, int ldc)</td></tr>
<tr class="memdesc:gae98fae51e118dc3682284a5d001cd946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS general matrix multiply xgemm().  <a href="group__HALABLAS3.html#gae98fae51e118dc3682284a5d001cd946">More...</a><br /></td></tr>
<tr class="separator:gae98fae51e118dc3682284a5d001cd946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47aa56f6ea4aef498777e9995ba07d45"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeB &gt; </td></tr>
<tr class="memitem:ga47aa56f6ea4aef498777e9995ba07d45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#ga47aa56f6ea4aef498777e9995ba07d45">gels</a> (char type, int M, int N, int num_rhs, VectorLikeA &amp;A, VectorLikeB &amp;B, int lda=-1, int ldb=-1)</td></tr>
<tr class="memdesc:ga47aa56f6ea4aef498777e9995ba07d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to LAPACK linear least-squares solver xGELS().  <a href="group__HALALAPACK.html#ga47aa56f6ea4aef498777e9995ba07d45">More...</a><br /></td></tr>
<tr class="separator:ga47aa56f6ea4aef498777e9995ba07d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64dc258ffa5840023abf4d8adf849655"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeS &gt; </td></tr>
<tr class="memitem:ga64dc258ffa5840023abf4d8adf849655"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#ga64dc258ffa5840023abf4d8adf849655">svd</a> (int M, int N, VectorLikeA &amp;A, VectorLikeS &amp;S, int lda=-1)</td></tr>
<tr class="memdesc:ga64dc258ffa5840023abf4d8adf849655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to LAPACK singular value decomposition xGESVD(), compute the singular values only.  <a href="group__HALALAPACK.html#ga64dc258ffa5840023abf4d8adf849655">More...</a><br /></td></tr>
<tr class="separator:ga64dc258ffa5840023abf4d8adf849655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad70066bb270b888e700d5659a637f561"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeS , class VectorLikeU , class VectorLikeUH &gt; </td></tr>
<tr class="memitem:gad70066bb270b888e700d5659a637f561"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#gad70066bb270b888e700d5659a637f561">svd</a> (int M, int N, VectorLikeA &amp;A, VectorLikeS &amp;S, VectorLikeU &amp;U, VectorLikeUH &amp;VH, int lda=-1, int ldu=-1, int ldvh=-1)</td></tr>
<tr class="memdesc:gad70066bb270b888e700d5659a637f561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to LAPACK singular value decomposition xGESVD(), compute the singular values only.  <a href="group__HALALAPACK.html#gad70066bb270b888e700d5659a637f561">More...</a><br /></td></tr>
<tr class="separator:gad70066bb270b888e700d5659a637f561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16ce5c724f1c0b10fcc87f0ad95ea162"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeP , class VectorLikeB &gt; </td></tr>
<tr class="memitem:ga16ce5c724f1c0b10fcc87f0ad95ea162"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#ga16ce5c724f1c0b10fcc87f0ad95ea162">gesv</a> (int N, int num_rhs, VectorLikeA &amp;A, VectorLikeP &amp;ipiv, VectorLikeB &amp;B, int lda=-1, int ldb=-1)</td></tr>
<tr class="memdesc:ga16ce5c724f1c0b10fcc87f0ad95ea162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to LAPACK general solver using PLU factorization xGESV().  <a href="group__HALALAPACK.html#ga16ce5c724f1c0b10fcc87f0ad95ea162">More...</a><br /></td></tr>
<tr class="separator:ga16ce5c724f1c0b10fcc87f0ad95ea162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4eb682a3828328bab61cab15a0adc0d"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeA &gt; </td></tr>
<tr class="memitem:gaa4eb682a3828328bab61cab15a0adc0d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#gaa4eb682a3828328bab61cab15a0adc0d">condition_number</a> (int N, VectorLikeA const &amp;A, int lda=-1)</td></tr>
<tr class="memdesc:gaa4eb682a3828328bab61cab15a0adc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the condition number of a <b>N</b> by <b>N</b> non-singular matrix, requires an internal copy of <b>A</b>. <br /></td></tr>
<tr class="separator:gaa4eb682a3828328bab61cab15a0adc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6faa5a4486553a0c0b151443265fbd3"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA &gt; </td></tr>
<tr class="memitem:af6faa5a4486553a0c0b151443265fbd3"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#af6faa5a4486553a0c0b151443265fbd3">geqr_query_size</a> (int query_type, int M, int N, VectorLikeA &amp;&amp;A, int lda)</td></tr>
<tr class="separator:af6faa5a4486553a0c0b151443265fbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f9acfb7c7000a9e4f67cf79516bcd9"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA &gt; </td></tr>
<tr class="memitem:gad7f9acfb7c7000a9e4f67cf79516bcd9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#gad7f9acfb7c7000a9e4f67cf79516bcd9">geqr_opt_size</a> (int M, int N, VectorLikeA &amp;&amp;A, int lda)</td></tr>
<tr class="memdesc:gad7f9acfb7c7000a9e4f67cf79516bcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the required size of the Q factor and workspace used by xgeqr().  <a href="group__HALALAPACK.html#gad7f9acfb7c7000a9e4f67cf79516bcd9">More...</a><br /></td></tr>
<tr class="separator:gad7f9acfb7c7000a9e4f67cf79516bcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c7b7463bb42548654b87c5f6415cd88"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA &gt; </td></tr>
<tr class="memitem:ga1c7b7463bb42548654b87c5f6415cd88"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#ga1c7b7463bb42548654b87c5f6415cd88">geqr_min_size</a> (int M, int N, VectorLikeA &amp;&amp;A, int lda)</td></tr>
<tr class="memdesc:ga1c7b7463bb42548654b87c5f6415cd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the required size of the Q factor and workspace used by xgeqr().  <a href="group__HALALAPACK.html#ga1c7b7463bb42548654b87c5f6415cd88">More...</a><br /></td></tr>
<tr class="separator:ga1c7b7463bb42548654b87c5f6415cd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga533c0c95cc992345d370ef35d7085504"><td class="memTemplParams" colspan="2">template&lt;bool use_opt = true, class VectorLikeA , class VectorLikeT &gt; </td></tr>
<tr class="memitem:ga533c0c95cc992345d370ef35d7085504"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#ga533c0c95cc992345d370ef35d7085504">geqr</a> (int M, int N, VectorLikeA &amp;&amp;A, int lda, VectorLikeT &amp;&amp;T)</td></tr>
<tr class="memdesc:ga533c0c95cc992345d370ef35d7085504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around Lapack xgeqr() for QR factorization.  <a href="group__HALALAPACK.html#ga533c0c95cc992345d370ef35d7085504">More...</a><br /></td></tr>
<tr class="separator:ga533c0c95cc992345d370ef35d7085504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40f6bc2df70774c39bfe2490ad7b2f72"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeT , class VectorLikeC &gt; </td></tr>
<tr class="memitem:ga40f6bc2df70774c39bfe2490ad7b2f72"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACK.html#ga40f6bc2df70774c39bfe2490ad7b2f72">gemqr</a> (char side, char trans, int M, int N, int K, VectorLikeA const &amp;A, int lda, VectorLikeT const &amp;T, int tsize, VectorLikeC &amp;&amp;C, int ldc)</td></tr>
<tr class="memdesc:ga40f6bc2df70774c39bfe2490ad7b2f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around Lapack xgemqr() for multiplication by a QR factor.  <a href="group__HALALAPACK.html#ga40f6bc2df70774c39bfe2490ad7b2f72">More...</a><br /></td></tr>
<tr class="separator:ga40f6bc2df70774c39bfe2490ad7b2f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2d5578205f2f1548f4a5921daadb1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a0d2d5578205f2f1548f4a5921daadb1d">lapack_check</a> (int info, std::string const &amp;name)</td></tr>
<tr class="separator:a0d2d5578205f2f1548f4a5921daadb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga259ceeb979483374aad216925fb1e8e9"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA &gt; </td></tr>
<tr class="memitem:ga259ceeb979483374aad216925fb1e8e9"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACKPLU.html#ga259ceeb979483374aad216925fb1e8e9">potrf_size</a> (char, int, VectorLikeA const &amp;, int=-1)</td></tr>
<tr class="memdesc:ga259ceeb979483374aad216925fb1e8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the workspace used by the <a class="el" href="group__HALALAPACKPLU.html#gae417ba12b25899c8bc4560f8b8966589" title="Wrapper to LAPACK Cholesky decomposition of an s.p.d. matrix xpotrf() ">potrf()</a> method.  <a href="group__HALALAPACKPLU.html#ga259ceeb979483374aad216925fb1e8e9">More...</a><br /></td></tr>
<tr class="separator:ga259ceeb979483374aad216925fb1e8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae417ba12b25899c8bc4560f8b8966589"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeW &gt; </td></tr>
<tr class="memitem:gae417ba12b25899c8bc4560f8b8966589"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACKPLU.html#gae417ba12b25899c8bc4560f8b8966589">potrf</a> (char uplo, int N, VectorLikeA &amp;&amp;A, int lda, VectorLikeW &amp;&amp;)</td></tr>
<tr class="memdesc:gae417ba12b25899c8bc4560f8b8966589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to LAPACK Cholesky decomposition of an s.p.d. matrix xpotrf()  <a href="group__HALALAPACKPLU.html#gae417ba12b25899c8bc4560f8b8966589">More...</a><br /></td></tr>
<tr class="separator:gae417ba12b25899c8bc4560f8b8966589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd9e7b807e6c45c89e0ae46f5f6da892"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeB &gt; </td></tr>
<tr class="memitem:gacd9e7b807e6c45c89e0ae46f5f6da892"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACKPLU.html#gacd9e7b807e6c45c89e0ae46f5f6da892">potrs</a> (char uplo, int N, int nrhs, VectorLikeA const &amp;A, int lda, VectorLikeB &amp;&amp;B, int ldb)</td></tr>
<tr class="memdesc:gacd9e7b807e6c45c89e0ae46f5f6da892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to LAPACK solver using Cholesky decomposition of an s.p.d. matrix xpotrs()  <a href="group__HALALAPACKPLU.html#gacd9e7b807e6c45c89e0ae46f5f6da892">More...</a><br /></td></tr>
<tr class="separator:gacd9e7b807e6c45c89e0ae46f5f6da892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90a88b0775be6cfb699f74fc72ada5b5"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA &gt; </td></tr>
<tr class="memitem:ga90a88b0775be6cfb699f74fc72ada5b5"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACKPLU.html#ga90a88b0775be6cfb699f74fc72ada5b5">getrf_size</a> (int, int, VectorLikeA const &amp;, int=-1)</td></tr>
<tr class="memdesc:ga90a88b0775be6cfb699f74fc72ada5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the workspace used by the <a class="el" href="group__HALALAPACKPLU.html#ga51f94c66c52a2232e2d1d737540443db" title="Wrapper to LAPACK general PLU factorization xgetrf() ">getrf()</a> method.  <a href="group__HALALAPACKPLU.html#ga90a88b0775be6cfb699f74fc72ada5b5">More...</a><br /></td></tr>
<tr class="separator:ga90a88b0775be6cfb699f74fc72ada5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51f94c66c52a2232e2d1d737540443db"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeI , class VectorLikeW &gt; </td></tr>
<tr class="memitem:ga51f94c66c52a2232e2d1d737540443db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACKPLU.html#ga51f94c66c52a2232e2d1d737540443db">getrf</a> (int M, int N, VectorLikeA &amp;&amp;A, int lda, VectorLikeI &amp;&amp;ipiv, VectorLikeW &amp;&amp;)</td></tr>
<tr class="memdesc:ga51f94c66c52a2232e2d1d737540443db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to LAPACK general PLU factorization xgetrf()  <a href="group__HALALAPACKPLU.html#ga51f94c66c52a2232e2d1d737540443db">More...</a><br /></td></tr>
<tr class="separator:ga51f94c66c52a2232e2d1d737540443db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae885cc54f8e39f59fedcf47f67d44c53"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeI , class VectorLikeB &gt; </td></tr>
<tr class="memitem:gae885cc54f8e39f59fedcf47f67d44c53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALALAPACKPLU.html#gae885cc54f8e39f59fedcf47f67d44c53">getrs</a> (char trans, int N, int nrhs, VectorLikeA const &amp;A, int lda, VectorLikeI const &amp;ipiv, VectorLikeB &amp;&amp;B, int ldb)</td></tr>
<tr class="memdesc:gae885cc54f8e39f59fedcf47f67d44c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to LAPACK solver using general PLU factorization, xgetrs()  <a href="group__HALALAPACKPLU.html#gae885cc54f8e39f59fedcf47f67d44c53">More...</a><br /></td></tr>
<tr class="separator:gae885cc54f8e39f59fedcf47f67d44c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefe666323135b3f97794ebe814ee822e"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename FPa , class VectorLikeX , typename FPb , class VectorLikeY &gt; </td></tr>
<tr class="memitem:gaefe666323135b3f97794ebe814ee822e"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSEBLAS.html#gaefe666323135b3f97794ebe814ee822e">sparse_gemv_buffer_size</a> (MatrixType const &amp;matrix, char trans, FPa alpha, VectorLikeX const &amp;x, FPb beta, VectorLikeY &amp;&amp;y)</td></tr>
<tr class="memdesc:gaefe666323135b3f97794ebe814ee822e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size of the workspace needed for sparse gemv operation.  <a href="group__HALASPARSEBLAS.html#gaefe666323135b3f97794ebe814ee822e">More...</a><br /></td></tr>
<tr class="separator:gaefe666323135b3f97794ebe814ee822e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga224ea0b6952e5baeabfd0d4f2d581448"><td class="memTemplParams" colspan="2">template&lt;typename FSA , class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikeX , typename FSB , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga224ea0b6952e5baeabfd0d4f2d581448"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSEBLAS.html#ga224ea0b6952e5baeabfd0d4f2d581448">sparse_gemv</a> (char trans, int M, int N, FSA alpha, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, VectorLikeX const &amp;x, FSB beta, VectorLikeY &amp;&amp;y)</td></tr>
<tr class="memdesc:ga224ea0b6952e5baeabfd0d4f2d581448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix vector multiplication.  <a href="group__HALASPARSEBLAS.html#ga224ea0b6952e5baeabfd0d4f2d581448">More...</a><br /></td></tr>
<tr class="separator:ga224ea0b6952e5baeabfd0d4f2d581448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad22763af08c73bb54328c700f5cfd3c4"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename FSA , class VectorLikeB , typename FSB , class VectorLikeC &gt; </td></tr>
<tr class="memitem:gad22763af08c73bb54328c700f5cfd3c4"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSEBLAS.html#gad22763af08c73bb54328c700f5cfd3c4">sparse_gemm_buffer_size</a> (MatrixType const &amp;matrix, char transa, char transb, int b_rows, int b_cols, FSA alpha, VectorLikeB const &amp;B, int ldb, FSB beta, VectorLikeC &amp;&amp;C, int ldc)</td></tr>
<tr class="memdesc:gad22763af08c73bb54328c700f5cfd3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the size of the workspace needed for sparse gemm operation.  <a href="group__HALASPARSEBLAS.html#gad22763af08c73bb54328c700f5cfd3c4">More...</a><br /></td></tr>
<tr class="separator:gad22763af08c73bb54328c700f5cfd3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga505c5cc6b4589ba027c5283a099595b3"><td class="memTemplParams" colspan="2">template&lt;typename FSA , class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikeB , typename FSB , class VectorLikeC &gt; </td></tr>
<tr class="memitem:ga505c5cc6b4589ba027c5283a099595b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSEBLAS.html#ga505c5cc6b4589ba027c5283a099595b3">sparse_gemm</a> (char transa, char transb, int M, int N, int K, FSA alpha, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, VectorLikeB const &amp;B, int ldb, FSB beta, VectorLikeC &amp;&amp;C, int ldc)</td></tr>
<tr class="memdesc:ga505c5cc6b4589ba027c5283a099595b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix-matrix multiplication.  <a href="group__HALASPARSEBLAS.html#ga505c5cc6b4589ba027c5283a099595b3">More...</a><br /></td></tr>
<tr class="separator:ga505c5cc6b4589ba027c5283a099595b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d425f47ac5bf2bbcf81fa823c459686"><td class="memTemplParams" colspan="2">template&lt;class TriangularMat , typename FPA , class VectorLikeB , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga9d425f47ac5bf2bbcf81fa823c459686"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSEBLAS.html#ga9d425f47ac5bf2bbcf81fa823c459686">sparse_trsv</a> (char trans, TriangularMat const &amp;tri, FPA alpha, VectorLikeB const &amp;b, VectorLikeX &amp;&amp;x)</td></tr>
<tr class="memdesc:ga9d425f47ac5bf2bbcf81fa823c459686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the triangular system of equations.  <a href="group__HALASPARSEBLAS.html#ga9d425f47ac5bf2bbcf81fa823c459686">More...</a><br /></td></tr>
<tr class="separator:ga9d425f47ac5bf2bbcf81fa823c459686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd59cd08a3ff53ceab7adfb3ed021353"><td class="memTemplParams" colspan="2">template&lt;class TriangularMat , typename FPA , class VectorLikeB &gt; </td></tr>
<tr class="memitem:gafd59cd08a3ff53ceab7adfb3ed021353"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSEBLAS.html#gafd59cd08a3ff53ceab7adfb3ed021353">sparse_trsm</a> (char transa, char transb, int nrhs, TriangularMat const &amp;tri, FPA alpha, VectorLikeB &amp;&amp;B, int ldb=-1)</td></tr>
<tr class="memdesc:gafd59cd08a3ff53ceab7adfb3ed021353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the triangular system of equations with multiple right hand sides.  <a href="group__HALASPARSEBLAS.html#gafd59cd08a3ff53ceab7adfb3ed021353">More...</a><br /></td></tr>
<tr class="separator:gafd59cd08a3ff53ceab7adfb3ed021353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga246bb6436c73aec65eb6a6a268238572"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeD &gt; </td></tr>
<tr class="memitem:ga246bb6436c73aec65eb6a6a268238572"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#ga246bb6436c73aec65eb6a6a268238572">get_diagonal_index</a> (VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeD &amp;diag)</td></tr>
<tr class="memdesc:ga246bb6436c73aec65eb6a6a268238572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills <b>diag</b> with the indexes in <b>indx</b> of the diagonal entries of the matrix.  <a href="group__HALASPARSECORE.html#ga246bb6436c73aec65eb6a6a268238572">More...</a><br /></td></tr>
<tr class="separator:ga246bb6436c73aec65eb6a6a268238572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa61b115510b4207b10484f11a99da681"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeD , class VectorLikePU , class VectorLikeIU , class VectorLikePL , class VectorLikeIL &gt; </td></tr>
<tr class="memitem:gaa61b115510b4207b10484f11a99da681"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#gaa61b115510b4207b10484f11a99da681">split_pattern</a> (VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeD const &amp;diag, VectorLikePU &amp;upper_pntr, VectorLikeIU &amp;upper_indx, VectorLikePL &amp;lower_pntr, VectorLikeIL &amp;lower_indx)</td></tr>
<tr class="memdesc:gaa61b115510b4207b10484f11a99da681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the patter into upper and lower portions, i.e., make two sparse matrices.  <a href="group__HALASPARSECORE.html#gaa61b115510b4207b10484f11a99da681">More...</a><br /></td></tr>
<tr class="separator:gaa61b115510b4207b10484f11a99da681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade2b1775c44a1d08d4c634b89141ac87"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeV , class VectorLikePU , class VectorLikePL , class VectorLikeVU , class VectorLikeVL &gt; </td></tr>
<tr class="memitem:gade2b1775c44a1d08d4c634b89141ac87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#gade2b1775c44a1d08d4c634b89141ac87">split_values</a> (char uplo, char diag, VectorLikeP const &amp;pntr, VectorLikeV const &amp;vals, VectorLikePU const &amp;upper_pntr, VectorLikePL const &amp;lower_pntr, VectorLikeVU &amp;upper_vals, VectorLikeVL &amp;lower_vals)</td></tr>
<tr class="memdesc:gade2b1775c44a1d08d4c634b89141ac87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the values assuming the pattern has been split already.  <a href="group__HALASPARSECORE.html#gade2b1775c44a1d08d4c634b89141ac87">More...</a><br /></td></tr>
<tr class="separator:gade2b1775c44a1d08d4c634b89141ac87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf22a8e9b2aed8341f4fecabfa73117"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikePU , class VectorLikeIU , class VectorLikeVU , class VectorLikePL , class VectorLikeIL , class VectorLikeVL &gt; </td></tr>
<tr class="memitem:gaadf22a8e9b2aed8341f4fecabfa73117"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#gaadf22a8e9b2aed8341f4fecabfa73117">split_matrix</a> (char uplo, char diag, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, VectorLikePU &amp;upper_pntr, VectorLikeIU &amp;upper_indx, VectorLikeVU &amp;upper_vals, VectorLikePL &amp;lower_pntr, VectorLikeIL &amp;lower_indx, VectorLikeVL &amp;lower_vals)</td></tr>
<tr class="memdesc:gaadf22a8e9b2aed8341f4fecabfa73117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split both the pattern and values into two matrices, see <b><a class="el" href="group__HALASPARSECORE.html#gade2b1775c44a1d08d4c634b89141ac87" title="Split the values assuming the pattern has been split already. ">hala::split_values()</a></b>.  <a href="group__HALASPARSECORE.html#gaadf22a8e9b2aed8341f4fecabfa73117">More...</a><br /></td></tr>
<tr class="separator:gaadf22a8e9b2aed8341f4fecabfa73117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9c617c6608d9cf8c765ae5cfdc9567"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikeD , class VectorLikeILU &gt; </td></tr>
<tr class="memitem:gaec9c617c6608d9cf8c765ae5cfdc9567"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#gaec9c617c6608d9cf8c765ae5cfdc9567">factorize_ilu</a> (VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, VectorLikeD const &amp;diag, VectorLikeILU &amp;ilu)</td></tr>
<tr class="memdesc:gaec9c617c6608d9cf8c765ae5cfdc9567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the incomplete Lower-Upper factorization of a sparse matrix.  <a href="group__HALASPARSECORE.html#gaec9c617c6608d9cf8c765ae5cfdc9567">More...</a><br /></td></tr>
<tr class="separator:gaec9c617c6608d9cf8c765ae5cfdc9567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6dfccd47336e4ff8669f1bcdd77d51f"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikeD , class VectorLikeILU &gt; </td></tr>
<tr class="memitem:gaf6dfccd47336e4ff8669f1bcdd77d51f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#gaf6dfccd47336e4ff8669f1bcdd77d51f">factorize_ilu</a> (VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, VectorLikeD &amp;diag, VectorLikeILU &amp;ilu)</td></tr>
<tr class="memdesc:gaf6dfccd47336e4ff8669f1bcdd77d51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that will call <a class="el" href="group__HALASPARSECORE.html#ga246bb6436c73aec65eb6a6a268238572" title="Fills diag with the indexes in indx of the diagonal entries of the matrix. ">hala::get_diagonal_index()</a> if the <b>diag</b> has incorrect size.  <a href="group__HALASPARSECORE.html#gaf6dfccd47336e4ff8669f1bcdd77d51f">More...</a><br /></td></tr>
<tr class="separator:gaf6dfccd47336e4ff8669f1bcdd77d51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72909210b2ef6cac3bf8223aaa9190ce"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeD , class VectorLikeILU , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga72909210b2ef6cac3bf8223aaa9190ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#ga72909210b2ef6cac3bf8223aaa9190ce">apply_ilu</a> (VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeD &amp;diag, VectorLikeILU const &amp;ilu, VectorLikeX &amp;&amp;x)</td></tr>
<tr class="memdesc:ga72909210b2ef6cac3bf8223aaa9190ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that will call <a class="el" href="group__HALASPARSECORE.html#ga246bb6436c73aec65eb6a6a268238572" title="Fills diag with the indexes in indx of the diagonal entries of the matrix. ">hala::get_diagonal_index()</a> if the <b>diag</b> has incorrect size.  <a href="group__HALASPARSECORE.html#ga72909210b2ef6cac3bf8223aaa9190ce">More...</a><br /></td></tr>
<tr class="separator:ga72909210b2ef6cac3bf8223aaa9190ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7ebe9aba87ec87642ef9a8dea666e50"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV &gt; </td></tr>
<tr class="memitem:gab7ebe9aba87ec87642ef9a8dea666e50"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSEILU.html#gab7ebe9aba87ec87642ef9a8dea666e50">make_ilu</a> (<a class="el" href="structhala_1_1cpu__engine.html">cpu_engine</a> const &amp;cengine, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, char policy)</td></tr>
<tr class="memdesc:gab7ebe9aba87ec87642ef9a8dea666e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an ILU preconditioner associated with a compute engine.  <a href="group__HALASPARSEILU.html#gab7ebe9aba87ec87642ef9a8dea666e50">More...</a><br /></td></tr>
<tr class="separator:gab7ebe9aba87ec87642ef9a8dea666e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab35ecfc9a918cf1dd863144202fdd14b"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV &gt; </td></tr>
<tr class="memitem:gab35ecfc9a918cf1dd863144202fdd14b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSE.html#gab35ecfc9a918cf1dd863144202fdd14b">make_sparse_matrix</a> (int num_rows, int num_cols, int num_nz, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals)</td></tr>
<tr class="memdesc:gab35ecfc9a918cf1dd863144202fdd14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a sparse matrix. <br /></td></tr>
<tr class="separator:gab35ecfc9a918cf1dd863144202fdd14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39cf37ccca32645defcef4fa1446b4e2"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV &gt; </td></tr>
<tr class="memitem:ga39cf37ccca32645defcef4fa1446b4e2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSE.html#ga39cf37ccca32645defcef4fa1446b4e2">make_sparse_matrix</a> (int num_cols, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals)</td></tr>
<tr class="memdesc:ga39cf37ccca32645defcef4fa1446b4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a square sparse matrix. <br /></td></tr>
<tr class="separator:ga39cf37ccca32645defcef4fa1446b4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe015cc2dbc90baa8e01f24a4fdfd652"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV &gt; </td></tr>
<tr class="memitem:gabe015cc2dbc90baa8e01f24a4fdfd652"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSE.html#gabe015cc2dbc90baa8e01f24a4fdfd652">make_sparse_matrix</a> (<a class="el" href="structhala_1_1cpu__engine.html">cpu_engine</a> const &amp;, int num_rows, int num_cols, int num_nz, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals)</td></tr>
<tr class="memdesc:gabe015cc2dbc90baa8e01f24a4fdfd652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a sparse matrix, overload with explicit <a class="el" href="structhala_1_1cpu__engine.html" title="The CPU Engine. ">hala::cpu_engine</a>. <br /></td></tr>
<tr class="separator:gabe015cc2dbc90baa8e01f24a4fdfd652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaad0b82f94a6dc9bcc1af8575ab6e2f9"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV &gt; </td></tr>
<tr class="memitem:gaaad0b82f94a6dc9bcc1af8575ab6e2f9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSE.html#gaaad0b82f94a6dc9bcc1af8575ab6e2f9">make_sparse_matrix</a> (<a class="el" href="structhala_1_1cpu__engine.html">cpu_engine</a> const &amp;, int num_cols, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals)</td></tr>
<tr class="memdesc:gaaad0b82f94a6dc9bcc1af8575ab6e2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a square sparse matrix, overload with explicit <a class="el" href="structhala_1_1cpu__engine.html" title="The CPU Engine. ">hala::cpu_engine</a>. <br /></td></tr>
<tr class="separator:gaaad0b82f94a6dc9bcc1af8575ab6e2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a26ea5df130d864efcbe3e1200a9c80"><td class="memTemplParams" colspan="2"><a id="a7a26ea5df130d864efcbe3e1200a9c80"></a>
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV &gt; </td></tr>
<tr class="memitem:a7a26ea5df130d864efcbe3e1200a9c80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a7a26ea5df130d864efcbe3e1200a9c80">make_triangular_matrix</a> (<a class="el" href="structhala_1_1cpu__engine.html">cpu_engine</a> const &amp;engine, char uplo, char diag, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, char policy='N')</td></tr>
<tr class="memdesc:a7a26ea5df130d864efcbe3e1200a9c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method to construct a cpu variant of a triangular matrix. <br /></td></tr>
<tr class="separator:a7a26ea5df130d864efcbe3e1200a9c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4a541134b7e2d59b1f1929f22ff2bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0b4a541134b7e2d59b1f1929f22ff2bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a0b4a541134b7e2d59b1f1929f22ff2bc">dense_convert_array</a> (int num_rows, int num_cols, int const pntr[], int const indx[], T const vals[], T result[])</td></tr>
<tr class="memdesc:a0b4a541134b7e2d59b1f1929f22ff2bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts spares matrix to dense format, used raw-arrays.  <a href="#a0b4a541134b7e2d59b1f1929f22ff2bc">More...</a><br /></td></tr>
<tr class="separator:a0b4a541134b7e2d59b1f1929f22ff2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6054d9977f5b91df6fcfe7e9d55f9a"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV &gt; </td></tr>
<tr class="memitem:a5c6054d9977f5b91df6fcfe7e9d55f9a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a5c6054d9977f5b91df6fcfe7e9d55f9a">dense_convert</a> (int num_rows, int num_cols, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals)</td></tr>
<tr class="memdesc:a5c6054d9977f5b91df6fcfe7e9d55f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts spares matrix to dense format, useful for testing and debugging.  <a href="#a5c6054d9977f5b91df6fcfe7e9d55f9a">More...</a><br /></td></tr>
<tr class="separator:a5c6054d9977f5b91df6fcfe7e9d55f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cfc470b7eb47eec706f6b7c958e8b1"><td class="memTemplParams" colspan="2">template&lt;typename T , char trans&gt; </td></tr>
<tr class="memitem:a59cfc470b7eb47eec706f6b7c958e8b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a59cfc470b7eb47eec706f6b7c958e8b1">sparse_gemv_array</a> (int num_rows, int num_cols, T alpha, int const pntr[], int const indx[], T const vals[], T const x[], T beta, T y[])</td></tr>
<tr class="memdesc:a59cfc470b7eb47eec706f6b7c958e8b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs sparse matrix-vector multiply using raw-arrays.  <a href="#a59cfc470b7eb47eec706f6b7c958e8b1">More...</a><br /></td></tr>
<tr class="separator:a59cfc470b7eb47eec706f6b7c958e8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0517f0f70150c395e903fc99d8b365"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0c0517f0f70150c395e903fc99d8b365"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a0c0517f0f70150c395e903fc99d8b365">sparse_gemm_array</a> (char transa, char transb, int M, int N, int K, T alpha, int const pntr[], int const indx[], T const vals[], T const B[], int ldb, T beta, T C[], int ldc)</td></tr>
<tr class="memdesc:a0c0517f0f70150c395e903fc99d8b365"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs sparse matrix-matrix multiply using raw-arrays.  <a href="#a0c0517f0f70150c395e903fc99d8b365">More...</a><br /></td></tr>
<tr class="separator:a0c0517f0f70150c395e903fc99d8b365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc19093fe089f6e0a7941a06fa9607b6"><td class="memTemplParams" colspan="2">template&lt;bool set_pntrs, typename T  = int&gt; </td></tr>
<tr class="memitem:adc19093fe089f6e0a7941a06fa9607b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#adc19093fe089f6e0a7941a06fa9607b6">split_pattern_array</a> (T num_rows, T const pntr[], T const indx[], T const diag[], T upper_pntr[], T upper_indx[], T lower_pntr[], T lower_indx[])</td></tr>
<tr class="memdesc:adc19093fe089f6e0a7941a06fa9607b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the patter into upper and lower portions using raw-arrays.  <a href="#adc19093fe089f6e0a7941a06fa9607b6">More...</a><br /></td></tr>
<tr class="separator:adc19093fe089f6e0a7941a06fa9607b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d4940ff254848469afbed96b811cabb"><td class="memTemplParams" colspan="2">template&lt;typename Tindex , typename T &gt; </td></tr>
<tr class="memitem:ga7d4940ff254848469afbed96b811cabb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#ga7d4940ff254848469afbed96b811cabb">split_values_array</a> (Tindex num_rows, char uplo, char diag, Tindex const pntr[], T const vals[], Tindex const upper_pntr[], Tindex const lower_pntr[], T upper_vals[], T lower_vals[])</td></tr>
<tr class="memdesc:ga7d4940ff254848469afbed96b811cabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the values assuming the pattern has been split already, uses raw-arrays.  <a href="group__HALASPARSECORE.html#ga7d4940ff254848469afbed96b811cabb">More...</a><br /></td></tr>
<tr class="separator:ga7d4940ff254848469afbed96b811cabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e58bea37d6c3aaaec2745b2b1b7bcec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e58bea37d6c3aaaec2745b2b1b7bcec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a3e58bea37d6c3aaaec2745b2b1b7bcec">factorize_ilu_array</a> (int num_rows, int const pntr[], int const indx[], int const diag[], T ilu[])</td></tr>
<tr class="memdesc:a3e58bea37d6c3aaaec2745b2b1b7bcec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs ILU factorization using raw-arrays.  <a href="#a3e58bea37d6c3aaaec2745b2b1b7bcec">More...</a><br /></td></tr>
<tr class="separator:a3e58bea37d6c3aaaec2745b2b1b7bcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7ee374f6d403d167bd5a9b415b7b6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae7ee374f6d403d167bd5a9b415b7b6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#aae7ee374f6d403d167bd5a9b415b7b6f">apply_ilu_array</a> (int num_rows, int const pntr[], int const indx[], int const diag[], T const ilu[], T x[])</td></tr>
<tr class="memdesc:aae7ee374f6d403d167bd5a9b415b7b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies ILU factorization on a vector.  <a href="#aae7ee374f6d403d167bd5a9b415b7b6f">More...</a><br /></td></tr>
<tr class="separator:aae7ee374f6d403d167bd5a9b415b7b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79058435b69a018c2f46951ea133cbfd"><td class="memTemplParams" colspan="2">template&lt;char diag, typename T , typename Tindex  = int&gt; </td></tr>
<tr class="memitem:a79058435b69a018c2f46951ea133cbfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a79058435b69a018c2f46951ea133cbfd">sparse_trsv_array</a> (char uplo, char trans, Tindex num_rows, T alpha, Tindex const pntr[], Tindex const indx[], T const vals[], T const b[], T x[])</td></tr>
<tr class="memdesc:a79058435b69a018c2f46951ea133cbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a sparse triangular system of equations, raw-array version.  <a href="#a79058435b69a018c2f46951ea133cbfd">More...</a><br /></td></tr>
<tr class="separator:a79058435b69a018c2f46951ea133cbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f73e200007af75788e806bf73ed7115"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a5f73e200007af75788e806bf73ed7115">check_cuda</a> (cudaError_t status, std::string const &amp;function_name)</td></tr>
<tr class="memdesc:a5f73e200007af75788e806bf73ed7115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if cuda returns cudaSuccess; if not, throw <b>runtime_error</b> and append <b>message</b> to the cuda error info.  <a href="#a5f73e200007af75788e806bf73ed7115">More...</a><br /></td></tr>
<tr class="separator:a5f73e200007af75788e806bf73ed7115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8113e8d3a3e3cde22f63a9dc75db95d"><td class="memItemLeft" align="right" valign="top"><a id="ab8113e8d3a3e3cde22f63a9dc75db95d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#ab8113e8d3a3e3cde22f63a9dc75db95d">check_cuda</a> (cublasStatus_t cublasStatus, std::string const &amp;function_name)</td></tr>
<tr class="memdesc:ab8113e8d3a3e3cde22f63a9dc75db95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check cuBlas status. <br /></td></tr>
<tr class="separator:ab8113e8d3a3e3cde22f63a9dc75db95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6ae9ba075c8ca8a69745c9f90c2147"><td class="memItemLeft" align="right" valign="top"><a id="a5c6ae9ba075c8ca8a69745c9f90c2147"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a5c6ae9ba075c8ca8a69745c9f90c2147">check_cuda</a> (cusparseStatus_t cusparseStatus, std::string const &amp;function_name)</td></tr>
<tr class="memdesc:a5c6ae9ba075c8ca8a69745c9f90c2147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check cuSparse status. <br /></td></tr>
<tr class="separator:a5c6ae9ba075c8ca8a69745c9f90c2147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe8b34f45565e4514427242ae48ea24"><td class="memItemLeft" align="right" valign="top"><a id="adfe8b34f45565e4514427242ae48ea24"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#adfe8b34f45565e4514427242ae48ea24">check_cuda</a> (cusolverStatus_t status, std::string const &amp;function_name)</td></tr>
<tr class="memdesc:adfe8b34f45565e4514427242ae48ea24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check cuSolver status. <br /></td></tr>
<tr class="separator:adfe8b34f45565e4514427242ae48ea24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab252d931bb6e9fdbcab374bc842b178d"><td class="memTemplParams" colspan="2"><a id="ab252d931bb6e9fdbcab374bc842b178d"></a>
template&lt;typename criteria , typename Fsingle , typename Fdouble , typename Fcomplex , typename Fzomplex , class Engine , class... Inputs&gt; </td></tr>
<tr class="memitem:ab252d931bb6e9fdbcab374bc842b178d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ab252d931bb6e9fdbcab374bc842b178d">cuda_call_backend</a> (Fsingle &amp;sfunc, Fdouble &amp;dfunc, Fcomplex &amp;cfunc, Fzomplex &amp;zfunc, std::string const &amp;function_name, Engine const &amp;engine, Inputs const &amp;...args)</td></tr>
<tr class="memdesc:ab252d931bb6e9fdbcab374bc842b178d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very similar to <a class="el" href="namespacehala.html#ada3048131102af6636985a61bad422e5" title="Call one of the 4 possible functions according to the criteria. ">hala::call_backend()</a>, wraps all calls with check_cuda and accepts an engine and string with function name. <br /></td></tr>
<tr class="separator:ab252d931bb6e9fdbcab374bc842b178d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e74ff260f82c9550c6ee28de65a1e7"><td class="memTemplParams" colspan="2"><a id="a36e74ff260f82c9550c6ee28de65a1e7"></a>
template&lt;bool flag, typename criteria , typename Fsingle , typename Fdouble , typename Fcomplex , typename Fzomplex , typename Frcomplex , typename Frzomplex , class Engine , class... Inputs&gt; </td></tr>
<tr class="memitem:a36e74ff260f82c9550c6ee28de65a1e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a36e74ff260f82c9550c6ee28de65a1e7">cuda_call_backend6</a> (Fsingle &amp;sfunc, Fdouble &amp;dfunc, Fcomplex &amp;cfunc, Fzomplex &amp;zfunc, Frcomplex &amp;crfunc, Frzomplex &amp;zrfunc, std::string const &amp;function_name, Engine const &amp;engine, Inputs const &amp;...args)</td></tr>
<tr class="memdesc:a36e74ff260f82c9550c6ee28de65a1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very similar to <a class="el" href="namespacehala.html#ada3048131102af6636985a61bad422e5" title="Call one of the 4 possible functions according to the criteria. ">hala::call_backend()</a>, wraps all calls with check_cuda and accepts an engine and string with function name. <br /></td></tr>
<tr class="separator:a36e74ff260f82c9550c6ee28de65a1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fec147443150ae81e3335824276615d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALAGPU.html#ga6fec147443150ae81e3335824276615d">gpu_device_count</a> ()</td></tr>
<tr class="memdesc:ga6fec147443150ae81e3335824276615d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to CUDA API to read the number of visible devices.  <a href="group__HALAGPU.html#ga6fec147443150ae81e3335824276615d">More...</a><br /></td></tr>
<tr class="separator:ga6fec147443150ae81e3335824276615d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0f77f3fb8ed52640f603cc1d52cb60"><td class="memItemLeft" align="right" valign="top">cublasOperation_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a5a0f77f3fb8ed52640f603cc1d52cb60">trans_to_gpu</a> (char trans)</td></tr>
<tr class="memdesc:a5a0f77f3fb8ed52640f603cc1d52cb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts characters N, T, C (upper or lower) to the correct cublasOperation_t.  <a href="#a5a0f77f3fb8ed52640f603cc1d52cb60">More...</a><br /></td></tr>
<tr class="separator:a5a0f77f3fb8ed52640f603cc1d52cb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa618a50c536d41255fb039d1d5231e2b"><td class="memTemplParams" colspan="2"><a id="aa618a50c536d41255fb039d1d5231e2b"></a>
template&lt;typename scalar_type &gt; </td></tr>
<tr class="memitem:aa618a50c536d41255fb039d1d5231e2b"><td class="memTemplItemLeft" align="right" valign="top">cusparseOperation_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#aa618a50c536d41255fb039d1d5231e2b">trans_to_cuda_sparse</a> (char trans)</td></tr>
<tr class="memdesc:aa618a50c536d41255fb039d1d5231e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts characters N, T, C (upper or lower) to the correct cusparseOperation_t. <br /></td></tr>
<tr class="separator:aa618a50c536d41255fb039d1d5231e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707d6276ce6249e6e9e2c037de99f0fb"><td class="memItemLeft" align="right" valign="top">cublasSideMode_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a707d6276ce6249e6e9e2c037de99f0fb">side_to_gpu</a> (char side)</td></tr>
<tr class="memdesc:a707d6276ce6249e6e9e2c037de99f0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts characters L, R (upper or lower) to the correct cublasSideMode_t.  <a href="#a707d6276ce6249e6e9e2c037de99f0fb">More...</a><br /></td></tr>
<tr class="separator:a707d6276ce6249e6e9e2c037de99f0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e2db7908b19d61ec45aac104a50258"><td class="memItemLeft" align="right" valign="top">cublasFillMode_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a81e2db7908b19d61ec45aac104a50258">uplo_to_gpu</a> (char uplo)</td></tr>
<tr class="memdesc:a81e2db7908b19d61ec45aac104a50258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts characters U, L (upper or lower) to the correct cublasFillMode_t.  <a href="#a81e2db7908b19d61ec45aac104a50258">More...</a><br /></td></tr>
<tr class="separator:a81e2db7908b19d61ec45aac104a50258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9d16244639678a33eacc1d2cee1035"><td class="memItemLeft" align="right" valign="top">cublasDiagType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a4f9d16244639678a33eacc1d2cee1035">diag_to_gpu</a> (char diag)</td></tr>
<tr class="memdesc:a4f9d16244639678a33eacc1d2cee1035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts characters U, N (upper or lower) to the correct cublasDiagType_t.  <a href="#a4f9d16244639678a33eacc1d2cee1035">More...</a><br /></td></tr>
<tr class="separator:a4f9d16244639678a33eacc1d2cee1035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b89d5a71e52699677403ee49441b171"><td class="memTemplParams" colspan="2"><a id="a3b89d5a71e52699677403ee49441b171"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b89d5a71e52699677403ee49441b171"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a3b89d5a71e52699677403ee49441b171">gpu_allocate</a> (int gpu_device, size_t num_elements)</td></tr>
<tr class="memdesc:a3b89d5a71e52699677403ee49441b171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for the given number of elements on the specified device. <br /></td></tr>
<tr class="separator:a3b89d5a71e52699677403ee49441b171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb610dfc3d8a3ab283660b9161926122"><td class="memTemplParams" colspan="2"><a id="afb610dfc3d8a3ab283660b9161926122"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb610dfc3d8a3ab283660b9161926122"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#afb610dfc3d8a3ab283660b9161926122">gpu_free</a> (T *gpu_data)</td></tr>
<tr class="memdesc:afb610dfc3d8a3ab283660b9161926122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the allocated GPU memory. <br /></td></tr>
<tr class="separator:afb610dfc3d8a3ab283660b9161926122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01922cf0a42c58f28b22e8603ecb2b2"><td class="memTemplParams" colspan="2"><a id="aa01922cf0a42c58f28b22e8603ecb2b2"></a>
template&lt;copy_direction dir, typename T &gt; </td></tr>
<tr class="memitem:aa01922cf0a42c58f28b22e8603ecb2b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#aa01922cf0a42c58f28b22e8603ecb2b2">gpu_copy_n</a> (T const *source, size_t num_entries, T *destination)</td></tr>
<tr class="memdesc:aa01922cf0a42c58f28b22e8603ecb2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identical to std::copy_n() but works on cpu-gpu or gpu-gpu pair of arrays. <br /></td></tr>
<tr class="separator:aa01922cf0a42c58f28b22e8603ecb2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef9fc84ecbd6ccdb77c45a783da0f2c"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a8ef9fc84ecbd6ccdb77c45a783da0f2c">make_cuda_mat_description</a> (char type, char uplo, char diag)</td></tr>
<tr class="memdesc:a8ef9fc84ecbd6ccdb77c45a783da0f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates sparse matrix description.  <a href="#a8ef9fc84ecbd6ccdb77c45a783da0f2c">More...</a><br /></td></tr>
<tr class="separator:a8ef9fc84ecbd6ccdb77c45a783da0f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9719886301e1e15b7ea4c46c03ea270f"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV &gt; </td></tr>
<tr class="memitem:a9719886301e1e15b7ea4c46c03ea270f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a9719886301e1e15b7ea4c46c03ea270f">make_sparse_matrix</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, int num_rows, int num_cols, int num_nz, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals)</td></tr>
<tr class="memdesc:a9719886301e1e15b7ea4c46c03ea270f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method, creates a <a class="el" href="structhala_1_1gpu__sparse__matrix.html" title="Wrapper around sparse matrix data associated with the GPU device. ">hala::gpu_sparse_matrix</a> wrapper with the given matrix parameters.  <a href="#a9719886301e1e15b7ea4c46c03ea270f">More...</a><br /></td></tr>
<tr class="separator:a9719886301e1e15b7ea4c46c03ea270f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19ec0922c8fb1fdbd02a42e7f2582e1"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV &gt; </td></tr>
<tr class="memitem:ae19ec0922c8fb1fdbd02a42e7f2582e1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ae19ec0922c8fb1fdbd02a42e7f2582e1">make_sparse_matrix</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, int num_cols, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals)</td></tr>
<tr class="memdesc:ae19ec0922c8fb1fdbd02a42e7f2582e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method, creates a <a class="el" href="structhala_1_1gpu__sparse__matrix.html" title="Wrapper around sparse matrix data associated with the GPU device. ">hala::gpu_sparse_matrix</a> wrapper where most of the dimensions are inferred from the vector sizes.  <a href="#ae19ec0922c8fb1fdbd02a42e7f2582e1">More...</a><br /></td></tr>
<tr class="separator:ae19ec0922c8fb1fdbd02a42e7f2582e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9bac448ac23b350e59337fcd5a5b335"><td class="memTemplParams" colspan="2">
template&lt;typename FPa , class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikeX , typename FPb , class VectorLikeY &gt; </td></tr>
<tr class="memitem:gaa9bac448ac23b350e59337fcd5a5b335"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUSPARSE.html#gaa9bac448ac23b350e59337fcd5a5b335">sparse_gemv</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char trans, int M, int N, FPa alpha, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, VectorLikeX const &amp;x, FPb beta, VectorLikeY &amp;y)</td></tr>
<tr class="memdesc:gaa9bac448ac23b350e59337fcd5a5b335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix times a dense vector, GPU version. <br /></td></tr>
<tr class="separator:gaa9bac448ac23b350e59337fcd5a5b335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a0c55d572dfe33df36cd61f1a595ccb"><td class="memTemplParams" colspan="2">
template&lt;typename FSA , class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikeB , typename FSB , class VectorLikeC &gt; </td></tr>
<tr class="memitem:ga4a0c55d572dfe33df36cd61f1a595ccb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUSPARSE.html#ga4a0c55d572dfe33df36cd61f1a595ccb">sparse_gemm</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char transa, char transb, int M, int N, int K, FSA alpha, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, VectorLikeB const &amp;B, int ldb, FSB beta, VectorLikeC &amp;C, int ldc)</td></tr>
<tr class="memdesc:ga4a0c55d572dfe33df36cd61f1a595ccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix-matrix multiplication, GPU version. <br /></td></tr>
<tr class="separator:ga4a0c55d572dfe33df36cd61f1a595ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878e3e6a568bca8dee8c5410c4e1ec8c"><td class="memTemplParams" colspan="2"><a id="a878e3e6a568bca8dee8c5410c4e1ec8c"></a>
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV &gt; </td></tr>
<tr class="memitem:a878e3e6a568bca8dee8c5410c4e1ec8c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a878e3e6a568bca8dee8c5410c4e1ec8c">make_triangular_matrix</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, char diag, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, char policy='N')</td></tr>
<tr class="memdesc:a878e3e6a568bca8dee8c5410c4e1ec8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload using the CUDA engine. <br /></td></tr>
<tr class="separator:a878e3e6a568bca8dee8c5410c4e1ec8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1ae82cd4ea22a5eb0aec270718545be"><td class="memTemplParams" colspan="2">template&lt;typename FPa , class VectorLikeA , typename FPb , class VectorLikeB , class VectorLikeC &gt; </td></tr>
<tr class="memitem:gaf1ae82cd4ea22a5eb0aec270718545be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS0.html#gaf1ae82cd4ea22a5eb0aec270718545be">geam</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char transa, char transb, int M, int N, FPa alpha, VectorLikeA const &amp;A, int lda, FPb beta, VectorLikeB const &amp;B, int ldb, VectorLikeC &amp;&amp;C, int ldc)</td></tr>
<tr class="memdesc:gaf1ae82cd4ea22a5eb0aec270718545be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU-BLAS matrix addition Xgeam().  <a href="group__HALAGPUBLAS0.html#gaf1ae82cd4ea22a5eb0aec270718545be">More...</a><br /></td></tr>
<tr class="separator:gaf1ae82cd4ea22a5eb0aec270718545be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga913ed4bb219b279b396fe0a9ad5986bd"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeB , class VectorLikeC &gt; </td></tr>
<tr class="memitem:ga913ed4bb219b279b396fe0a9ad5986bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS0.html#ga913ed4bb219b279b396fe0a9ad5986bd">dgmm</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char side, int M, int N, VectorLikeA const &amp;A, int lda, VectorLikeB const &amp;x, int incx, VectorLikeC &amp;&amp;C, int ldc)</td></tr>
<tr class="memdesc:ga913ed4bb219b279b396fe0a9ad5986bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU-BLAS matrix addition Xdgmm().  <a href="group__HALAGPUBLAS0.html#ga913ed4bb219b279b396fe0a9ad5986bd">More...</a><br /></td></tr>
<tr class="separator:ga913ed4bb219b279b396fe0a9ad5986bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e5a1637dc8f4c1a755b7b9b14d197e4"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeAP &gt; </td></tr>
<tr class="memitem:ga4e5a1637dc8f4c1a755b7b9b14d197e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS0.html#ga4e5a1637dc8f4c1a755b7b9b14d197e4">tp2tr</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, int N, VectorLikeAP const &amp;AP, VectorLikeA &amp;&amp;A, int lda=-1)</td></tr>
<tr class="memdesc:ga4e5a1637dc8f4c1a755b7b9b14d197e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU-BLAS matrix addition Xtpttr(), converts triangular-packed to triangular-regular formats.  <a href="group__HALAGPUBLAS0.html#ga4e5a1637dc8f4c1a755b7b9b14d197e4">More...</a><br /></td></tr>
<tr class="separator:ga4e5a1637dc8f4c1a755b7b9b14d197e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c09d4952d6ea1dd7e5cc78bd5786d5"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeAP &gt; </td></tr>
<tr class="memitem:gad6c09d4952d6ea1dd7e5cc78bd5786d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS0.html#gad6c09d4952d6ea1dd7e5cc78bd5786d5">tr2tp</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, int N, VectorLikeA const &amp;A, int lda, VectorLikeAP &amp;&amp;AP)</td></tr>
<tr class="memdesc:gad6c09d4952d6ea1dd7e5cc78bd5786d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU-BLAS matrix addition Xttttp(), converts triangular-regular to triangular-packed formats.  <a href="group__HALAGPUBLAS0.html#gad6c09d4952d6ea1dd7e5cc78bd5786d5">More...</a><br /></td></tr>
<tr class="separator:gad6c09d4952d6ea1dd7e5cc78bd5786d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f358e2206833b947f1527c8a4d8d97d"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga1f358e2206833b947f1527c8a4d8d97d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS1.html#ga1f358e2206833b947f1527c8a4d8d97d">vcopy</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, int N, VectorLikeX const &amp;x, int incx, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga1f358e2206833b947f1527c8a4d8d97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU copy.  <a href="group__HALAGPUBLAS1.html#ga1f358e2206833b947f1527c8a4d8d97d">More...</a><br /></td></tr>
<tr class="separator:ga1f358e2206833b947f1527c8a4d8d97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc06ed5354451d0c4b206f81427da534"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:gacc06ed5354451d0c4b206f81427da534"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS1.html#gacc06ed5354451d0c4b206f81427da534">vcopy</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, VectorLikeX const &amp;x, VectorLikeY &amp;&amp;y, int incx=1, int incy=1, int N=-1)</td></tr>
<tr class="memdesc:gacc06ed5354451d0c4b206f81427da534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload with default parameters.  <a href="group__HALAGPUBLAS1.html#gacc06ed5354451d0c4b206f81427da534">More...</a><br /></td></tr>
<tr class="separator:gacc06ed5354451d0c4b206f81427da534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff1d8d3e51d4858a50e4859f3770e78"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga7ff1d8d3e51d4858a50e4859f3770e78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALABLAS1.html#ga7ff1d8d3e51d4858a50e4859f3770e78">vswap</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, int N, VectorLikeX &amp;&amp;x, int incx, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga7ff1d8d3e51d4858a50e4859f3770e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU Xswap() methods. <br /></td></tr>
<tr class="separator:ga7ff1d8d3e51d4858a50e4859f3770e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9041633e1e8c9f8a194ceef4b99ae5d"><td class="memTemplParams" colspan="2">
template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:gab9041633e1e8c9f8a194ceef4b99ae5d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS1.html#gab9041633e1e8c9f8a194ceef4b99ae5d">norm2</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, int N, VectorLike const &amp;x, int incx)</td></tr>
<tr class="memdesc:gab9041633e1e8c9f8a194ceef4b99ae5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU-BLAS 2-norm Xnrm2(). <br /></td></tr>
<tr class="separator:gab9041633e1e8c9f8a194ceef4b99ae5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f6c6921bede5648f30f6e8faa59b4c5"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga0f6c6921bede5648f30f6e8faa59b4c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS1.html#ga0f6c6921bede5648f30f6e8faa59b4c5">asum</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, int N, VectorLikeX const &amp;x, int incx)</td></tr>
<tr class="memdesc:ga0f6c6921bede5648f30f6e8faa59b4c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU vector sum of absolute values of the entry components. <br /></td></tr>
<tr class="separator:ga0f6c6921bede5648f30f6e8faa59b4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2556bba1b08d9c9f7dabb48734a1dbc"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeX &gt; </td></tr>
<tr class="memitem:gad2556bba1b08d9c9f7dabb48734a1dbc"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS1.html#gad2556bba1b08d9c9f7dabb48734a1dbc">iamax</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, int N, VectorLikeX const &amp;x, int incx)</td></tr>
<tr class="memdesc:gad2556bba1b08d9c9f7dabb48734a1dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU find index of largest vector entry, Ixamax(). <br /></td></tr>
<tr class="separator:gad2556bba1b08d9c9f7dabb48734a1dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9519f9894f64453f924c4df24d50db61"><td class="memTemplParams" colspan="2">
template&lt;bool conjugate = true, class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga9519f9894f64453f924c4df24d50db61"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS1.html#ga9519f9894f64453f924c4df24d50db61">dot</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, int N, VectorLikeX const &amp;x, int incx, VectorLikeY const &amp;y, int incy)</td></tr>
<tr class="memdesc:ga9519f9894f64453f924c4df24d50db61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU-BLAS vector dot Xdot(). <br /></td></tr>
<tr class="separator:ga9519f9894f64453f924c4df24d50db61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga722ff0a5092f0f8bacde3ed521b8241d"><td class="memTemplParams" colspan="2">
template&lt;typename FS , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga722ff0a5092f0f8bacde3ed521b8241d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS1.html#ga722ff0a5092f0f8bacde3ed521b8241d">axpy</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, int N, FS alpha, VectorLikeX const &amp;x, int incx, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga722ff0a5092f0f8bacde3ed521b8241d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU-BLAS vector scale-addition Xaxpy(). <br /></td></tr>
<tr class="separator:ga722ff0a5092f0f8bacde3ed521b8241d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33b2d9a415f19bb16799386df4063cdd"><td class="memTemplParams" colspan="2">
template&lt;typename FS , class VectorLike &gt; </td></tr>
<tr class="memitem:ga33b2d9a415f19bb16799386df4063cdd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS1.html#ga33b2d9a415f19bb16799386df4063cdd">scal</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, int N, FS alpha, VectorLike &amp;&amp;x, int incx)</td></tr>
<tr class="memdesc:ga33b2d9a415f19bb16799386df4063cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU-BLAS vector scale Xscal(). <br /></td></tr>
<tr class="separator:ga33b2d9a415f19bb16799386df4063cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5e998a170911b38c0568c23c74b0095"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad5e998a170911b38c0568c23c74b0095"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS1.html#gad5e998a170911b38c0568c23c74b0095">rotg</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, T *SA, T *SB, typename <a class="el" href="structhala_1_1define__standard__precision.html">define_standard_precision</a>&lt; T &gt;::value_type *C, T *S)</td></tr>
<tr class="memdesc:gad5e998a170911b38c0568c23c74b0095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS generate Givens rotation, xrotg(), (using only 4 variables on the cpu, no actual gpu work is done here). <br /></td></tr>
<tr class="separator:gad5e998a170911b38c0568c23c74b0095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga772a8780153634ddabe3d5bcc3891d85"><td class="memTemplParams" colspan="2">
template&lt;typename FC , typename FS , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga772a8780153634ddabe3d5bcc3891d85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS1.html#ga772a8780153634ddabe3d5bcc3891d85">rot</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, int N, VectorLikeX &amp;x, int incx, VectorLikeY &amp;&amp;y, int incy, FC C, FS S)</td></tr>
<tr class="memdesc:ga772a8780153634ddabe3d5bcc3891d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU apply the Givens rotation, Xrot(). <br /></td></tr>
<tr class="separator:ga772a8780153634ddabe3d5bcc3891d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe3842fe42c005e008d9e24ff18030e"><td class="memTemplParams" colspan="2">
template&lt;typename T , class VectorLike &gt; </td></tr>
<tr class="memitem:gacfe3842fe42c005e008d9e24ff18030e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS1.html#gacfe3842fe42c005e008d9e24ff18030e">rotmg</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, T &amp;D1, T &amp;D2, T &amp;X, T const &amp;Y, VectorLike &amp;&amp;param)</td></tr>
<tr class="memdesc:gacfe3842fe42c005e008d9e24ff18030e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU generate modified Givens rotation. <br /></td></tr>
<tr class="separator:gacfe3842fe42c005e008d9e24ff18030e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab76e73457051053b85dbdd6cf43dbf2c"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeX , class VectorLikeY , class VectorLikeP &gt; </td></tr>
<tr class="memitem:gab76e73457051053b85dbdd6cf43dbf2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS1.html#gab76e73457051053b85dbdd6cf43dbf2c">rotm</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, int N, VectorLikeX &amp;&amp;x, int incx, VectorLikeY &amp;&amp;y, int incy, VectorLikeP const &amp;param)</td></tr>
<tr class="memdesc:gab76e73457051053b85dbdd6cf43dbf2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU apply the Givens rotation, Xrotm(). <br /></td></tr>
<tr class="separator:gab76e73457051053b85dbdd6cf43dbf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9722549bf76bf605aa863359899c24fa"><td class="memTemplParams" colspan="2">
template&lt;typename FPA , typename FPB , class VectorLikeA , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga9722549bf76bf605aa863359899c24fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#ga9722549bf76bf605aa863359899c24fa">gemv</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char trans, int M, int N, FPA alpha, VectorLikeA const &amp;A, int lda, VectorLikeX const &amp;x, int incx, FPB beta, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga9722549bf76bf605aa863359899c24fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU-BLAS general matrix-vector multiply Xgemv(). <br /></td></tr>
<tr class="separator:ga9722549bf76bf605aa863359899c24fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeebfa232014e560fe615169ae3add535"><td class="memTemplParams" colspan="2">
template&lt;typename FSa , typename FSb , class VectorLikeA , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:gaeebfa232014e560fe615169ae3add535"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#gaeebfa232014e560fe615169ae3add535">gbmv</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char trans, int M, int N, int kl, int ku, FSa alpha, const VectorLikeA &amp;A, int lda, const VectorLikeX &amp;x, int incx, FSb beta, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:gaeebfa232014e560fe615169ae3add535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU general banded matrix-vector multiply Xgbmv(). <br /></td></tr>
<tr class="separator:gaeebfa232014e560fe615169ae3add535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55c4ca71c15dc9a2f430ba15223830d0"><td class="memTemplParams" colspan="2">
template&lt;bool conjugate = false, typename FSa , typename FSb , class VectorLikeA , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga55c4ca71c15dc9a2f430ba15223830d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#ga55c4ca71c15dc9a2f430ba15223830d0">symv</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, int N, FSa alpha, const VectorLikeA &amp;A, int lda, const VectorLikeX &amp;x, int incx, FSb beta, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga55c4ca71c15dc9a2f430ba15223830d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU symmetric or Hermitian matrix-vector multiply Xsymv(). <br /></td></tr>
<tr class="separator:ga55c4ca71c15dc9a2f430ba15223830d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6099ae27f028344bef8d64d91efcf1b"><td class="memTemplParams" colspan="2">
template&lt;bool conjugate = true, typename FSa , typename FSb , class VectorLikeA , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:gac6099ae27f028344bef8d64d91efcf1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#gac6099ae27f028344bef8d64d91efcf1b">sbmv</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, int N, int k, FSa alpha, const VectorLikeA &amp;A, int lda, const VectorLikeX &amp;x, int incx, FSb beta, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:gac6099ae27f028344bef8d64d91efcf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU symmetric or Hermitian banded matrix-vector multiply Xsbmv(). <br /></td></tr>
<tr class="separator:gac6099ae27f028344bef8d64d91efcf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4181cb9ca536b02c9ef5731380aeed44"><td class="memTemplParams" colspan="2">
template&lt;bool conjugate = false, typename FSa , typename FSb , class VectorLikeA , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga4181cb9ca536b02c9ef5731380aeed44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#ga4181cb9ca536b02c9ef5731380aeed44">spmv</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, int N, FSa alpha, const VectorLikeA &amp;A, const VectorLikeX &amp;x, int incx, FSb beta, VectorLikeY &amp;&amp;y, int incy)</td></tr>
<tr class="memdesc:ga4181cb9ca536b02c9ef5731380aeed44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU symmetric or Hermitian matrix-vector multiply Xspmv() in packed format. <br /></td></tr>
<tr class="separator:ga4181cb9ca536b02c9ef5731380aeed44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71eb5668bc438fec0923d968d47fdbfa"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeA , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga71eb5668bc438fec0923d968d47fdbfa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#ga71eb5668bc438fec0923d968d47fdbfa">trmv</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, char trans, char diag, int N, const VectorLikeA &amp;A, int lda, VectorLikeX &amp;&amp;x, int incx)</td></tr>
<tr class="memdesc:ga71eb5668bc438fec0923d968d47fdbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU triangular matrix-vector multiply Xtrmv(). <br /></td></tr>
<tr class="separator:ga71eb5668bc438fec0923d968d47fdbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70472c7a0d1bfac631e53e845636d4ca"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeA , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga70472c7a0d1bfac631e53e845636d4ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#ga70472c7a0d1bfac631e53e845636d4ca">trsv</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, char trans, char diag, int N, const VectorLikeA &amp;A, int lda, VectorLikeX &amp;&amp;x, int incx)</td></tr>
<tr class="memdesc:ga70472c7a0d1bfac631e53e845636d4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS triangular matrix-vector solve Xtrsv(). <br /></td></tr>
<tr class="separator:ga70472c7a0d1bfac631e53e845636d4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d26ea08faeace8cf62db876f36473c6"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeA , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga5d26ea08faeace8cf62db876f36473c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#ga5d26ea08faeace8cf62db876f36473c6">tpmv</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, char trans, char diag, int N, const VectorLikeA &amp;A, VectorLikeX &amp;&amp;x, int incx=1)</td></tr>
<tr class="memdesc:ga5d26ea08faeace8cf62db876f36473c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS triangular matrix-vector multiply in packed format Xtpmv(). <br /></td></tr>
<tr class="separator:ga5d26ea08faeace8cf62db876f36473c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f070e6e02fce3a163dca2b5adb37b9"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeA , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga63f070e6e02fce3a163dca2b5adb37b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#ga63f070e6e02fce3a163dca2b5adb37b9">tpsv</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, char trans, char diag, int N, const VectorLikeA &amp;A, VectorLikeX &amp;&amp;x, int incx=1)</td></tr>
<tr class="memdesc:ga63f070e6e02fce3a163dca2b5adb37b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS triangular matrix-vector solve in packed format Xtpsv(). <br /></td></tr>
<tr class="separator:ga63f070e6e02fce3a163dca2b5adb37b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cac5c0777c136c45587f0d4958400da"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeA , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga8cac5c0777c136c45587f0d4958400da"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#ga8cac5c0777c136c45587f0d4958400da">tbmv</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, char trans, char diag, int N, int k, const VectorLikeA &amp;A, int lda, VectorLikeX &amp;&amp;x, int incx)</td></tr>
<tr class="memdesc:ga8cac5c0777c136c45587f0d4958400da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU triangular banded matrix-vector multiply Xtbmv(). <br /></td></tr>
<tr class="separator:ga8cac5c0777c136c45587f0d4958400da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eaa26dd20246d3cc0764c7c5cf8c8c4"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeA , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga5eaa26dd20246d3cc0764c7c5cf8c8c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#ga5eaa26dd20246d3cc0764c7c5cf8c8c4">tbsv</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, char trans, char diag, int N, int k, const VectorLikeA &amp;A, int lda, VectorLikeX &amp;&amp;x, int incx)</td></tr>
<tr class="memdesc:ga5eaa26dd20246d3cc0764c7c5cf8c8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU triangular matrix-vector solve Xtbsv(). <br /></td></tr>
<tr class="separator:ga5eaa26dd20246d3cc0764c7c5cf8c8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga574dadeda3e3dfca769b723266d17214"><td class="memTemplParams" colspan="2">
template&lt;bool conjugate = true, typename FSa , class VectorLikeX , class VectorLikeY , class VectorLikeA &gt; </td></tr>
<tr class="memitem:ga574dadeda3e3dfca769b723266d17214"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#ga574dadeda3e3dfca769b723266d17214">ger</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, int M, int N, FSa alpha, VectorLikeX const &amp;x, int incx, VectorLikeY const &amp;y, int incy, VectorLikeA &amp;&amp;A, int lda)</td></tr>
<tr class="memdesc:ga574dadeda3e3dfca769b723266d17214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU general rank-1 update Xgerx(). <br /></td></tr>
<tr class="separator:ga574dadeda3e3dfca769b723266d17214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374b3f106aa234e105a1f8b87a1ec53a"><td class="memTemplParams" colspan="2">
template&lt;bool conjugate = false, typename FSa , class VectorLikeX , class VectorLikeA &gt; </td></tr>
<tr class="memitem:ga374b3f106aa234e105a1f8b87a1ec53a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#ga374b3f106aa234e105a1f8b87a1ec53a">syr</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, int N, FSa alpha, VectorLikeX const &amp;x, int incx, VectorLikeA &amp;&amp;A, int lda)</td></tr>
<tr class="memdesc:ga374b3f106aa234e105a1f8b87a1ec53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU symmetric or Hermitian rank-1 update Xsyr() and Xher(). <br /></td></tr>
<tr class="separator:ga374b3f106aa234e105a1f8b87a1ec53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6014636e16b5b1c8b7fae51cf8e2212"><td class="memTemplParams" colspan="2">
template&lt;bool conjugate = true, typename FSa , class VectorLikeX , class VectorLikeA &gt; </td></tr>
<tr class="memitem:gaa6014636e16b5b1c8b7fae51cf8e2212"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#gaa6014636e16b5b1c8b7fae51cf8e2212">spr</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, int N, FSa alpha, VectorLikeX const &amp;x, int incx, VectorLikeA &amp;&amp;A)</td></tr>
<tr class="memdesc:gaa6014636e16b5b1c8b7fae51cf8e2212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU symmetric or Hermitian rank-1 update using packed format Xspr() and Xhpr(). <br /></td></tr>
<tr class="separator:gaa6014636e16b5b1c8b7fae51cf8e2212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga223bd029d0a24fe379ee345e6b149068"><td class="memTemplParams" colspan="2">
template&lt;bool conjugate = false, typename FSa , class VectorLikeX , class VectorLikeY , class VectorLikeA &gt; </td></tr>
<tr class="memitem:ga223bd029d0a24fe379ee345e6b149068"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#ga223bd029d0a24fe379ee345e6b149068">syr2</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, int N, FSa alpha, VectorLikeX const &amp;x, int incx, VectorLikeY const &amp;y, int incy, VectorLikeA &amp;&amp;A, int lda)</td></tr>
<tr class="memdesc:ga223bd029d0a24fe379ee345e6b149068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU symmetric or Hermitian rank-2 update Xsyr2() and Xher2(). <br /></td></tr>
<tr class="separator:ga223bd029d0a24fe379ee345e6b149068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga011f576cd7974f9f0bfc42ea3927c076"><td class="memTemplParams" colspan="2">
template&lt;bool conjugate = false, typename FSa , class VectorLikeX , class VectorLikeY , class VectorLikeA &gt; </td></tr>
<tr class="memitem:ga011f576cd7974f9f0bfc42ea3927c076"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS2.html#ga011f576cd7974f9f0bfc42ea3927c076">spr2</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, int N, FSa alpha, VectorLikeX const &amp;x, int incx, VectorLikeY const &amp;y, int incy, VectorLikeA &amp;&amp;A)</td></tr>
<tr class="memdesc:ga011f576cd7974f9f0bfc42ea3927c076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU symmetric or Hermitian rank-2 update in packed format Xspr2() and Xhpr2(). <br /></td></tr>
<tr class="separator:ga011f576cd7974f9f0bfc42ea3927c076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3753870ba1c9a9bc8ae6afca4d747cd"><td class="memTemplParams" colspan="2">
template&lt;typename FS , class VectorLikeA , class VectorLikeB &gt; </td></tr>
<tr class="memitem:gae3753870ba1c9a9bc8ae6afca4d747cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS3.html#gae3753870ba1c9a9bc8ae6afca4d747cd">trmm</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char side, char uplo, char trans, char diag, int M, int N, FS alpha, const VectorLikeA &amp;A, int lda, VectorLikeB &amp;&amp;B, int ldb)</td></tr>
<tr class="memdesc:gae3753870ba1c9a9bc8ae6afca4d747cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU triangular matrix-matrix multiply Xtrmm(). <br /></td></tr>
<tr class="separator:gae3753870ba1c9a9bc8ae6afca4d747cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e03f33451d35d26d8b485b02a048d44"><td class="memTemplParams" colspan="2">
template&lt;typename FS , class VectorLikeA , class VectorLikeB &gt; </td></tr>
<tr class="memitem:ga0e03f33451d35d26d8b485b02a048d44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS3.html#ga0e03f33451d35d26d8b485b02a048d44">trsm</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char side, char uplo, char trans, char diag, int M, int N, FS alpha, const VectorLikeA &amp;A, int lda, VectorLikeB &amp;&amp;B, int ldb)</td></tr>
<tr class="memdesc:ga0e03f33451d35d26d8b485b02a048d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU triangular matrix-matrix solve Xtrsm(). <br /></td></tr>
<tr class="separator:ga0e03f33451d35d26d8b485b02a048d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09ff0bda671a5a3b141fe69ec86841b7"><td class="memTemplParams" colspan="2">
template&lt;bool conjugate = false, typename FPA , typename FPB , class VectorLikeA , class VectorLikeC &gt; </td></tr>
<tr class="memitem:ga09ff0bda671a5a3b141fe69ec86841b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS3.html#ga09ff0bda671a5a3b141fe69ec86841b7">syrk</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, char trans, int N, int K, FPA alpha, VectorLikeA const &amp;A, int lda, FPB beta, VectorLikeC &amp;&amp;C, int ldc)</td></tr>
<tr class="memdesc:ga09ff0bda671a5a3b141fe69ec86841b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS symmetric rank-k update Xsyrk() and Xherk(). <br /></td></tr>
<tr class="separator:ga09ff0bda671a5a3b141fe69ec86841b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cbc5114ad46f355e0abe6af14f24c2e"><td class="memTemplParams" colspan="2">
template&lt;bool conjugate = false, typename FPA , typename FPB , class VectorLikeA , class VectorLikeB , class VectorLikeC &gt; </td></tr>
<tr class="memitem:ga4cbc5114ad46f355e0abe6af14f24c2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS3.html#ga4cbc5114ad46f355e0abe6af14f24c2e">syr2k</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char uplo, char trans, int N, int K, FPA alpha, VectorLikeA const &amp;A, int lda, VectorLikeB const &amp;B, int ldb, FPB beta, VectorLikeC &amp;&amp;C, int ldc)</td></tr>
<tr class="memdesc:ga4cbc5114ad46f355e0abe6af14f24c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to BLAS symmetric rank-k update Xsyrk() and Xherk(). <br /></td></tr>
<tr class="separator:ga4cbc5114ad46f355e0abe6af14f24c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1643db144fc91719d5d121b6d41d34f4"><td class="memTemplParams" colspan="2">
template&lt;bool conjugate = false, typename FSa , typename FSb , class VectorLikeA , class VectorLikeB , class VectorLikeC &gt; </td></tr>
<tr class="memitem:ga1643db144fc91719d5d121b6d41d34f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS3.html#ga1643db144fc91719d5d121b6d41d34f4">symm</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char side, char uplo, int M, int N, FSa alpha, VectorLikeA const &amp;A, int lda, VectorLikeB const &amp;B, int ldb, FSb beta, VectorLikeC &amp;&amp;C, int ldc)</td></tr>
<tr class="memdesc:ga1643db144fc91719d5d121b6d41d34f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU symmetric or Hermitian matrix multiply Xsymm()/Xhemm(). <br /></td></tr>
<tr class="separator:ga1643db144fc91719d5d121b6d41d34f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6bc92651933dce22546d13506dfcfdc"><td class="memTemplParams" colspan="2">
template&lt;typename FPA , typename FPB , class VectorLikeA , class VectorLikeB , class VectorLikeC &gt; </td></tr>
<tr class="memitem:gac6bc92651933dce22546d13506dfcfdc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUBLAS3.html#gac6bc92651933dce22546d13506dfcfdc">gemm</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, char transa, char transb, int M, int N, int K, FPA alpha, VectorLikeA const &amp;A, int lda, VectorLikeB const &amp;B, int ldb, FPB beta, VectorLikeC &amp;&amp;C, int ldc)</td></tr>
<tr class="memdesc:gac6bc92651933dce22546d13506dfcfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to GPU general matrix multiply Xgemm(). <br /></td></tr>
<tr class="separator:gac6bc92651933dce22546d13506dfcfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dea4f29c3d5af9367e7b55c0bf9de95"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:ga8dea4f29c3d5af9367e7b55c0bf9de95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUENGINE.html#ga8dea4f29c3d5af9367e7b55c0bf9de95">new_vector</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, VectorLike const &amp;)</td></tr>
<tr class="memdesc:ga8dea4f29c3d5af9367e7b55c0bf9de95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a default vector with the default constructor.  <a href="group__HALAGPUENGINE.html#ga8dea4f29c3d5af9367e7b55c0bf9de95">More...</a><br /></td></tr>
<tr class="separator:ga8dea4f29c3d5af9367e7b55c0bf9de95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46bfd65d4dca06dd759248a8466ebe52"><td class="memTemplParams" colspan="2">
template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:ga46bfd65d4dca06dd759248a8466ebe52"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUENGINE.html#ga46bfd65d4dca06dd759248a8466ebe52">set_zero</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, size_t num_entries, VectorLike &amp;&amp;x)</td></tr>
<tr class="memdesc:ga46bfd65d4dca06dd759248a8466ebe52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite the first <b>num_entries</b> of the vector with zeros. <br /></td></tr>
<tr class="separator:ga46bfd65d4dca06dd759248a8466ebe52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga576531f108e7a5ca7f8af1b26c066a69"><td class="memTemplParams" colspan="2">
template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:ga576531f108e7a5ca7f8af1b26c066a69"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUENGINE.html#ga576531f108e7a5ca7f8af1b26c066a69">gpu_bind_vector</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;e, VectorLike &amp;x)</td></tr>
<tr class="memdesc:ga576531f108e7a5ca7f8af1b26c066a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of <a class="el" href="structhala_1_1binded__gpu__vector.html" title="A struct that wraps around a gpu_vector and a reference to a cpu vector-like. ">hala::binded_gpu_vector</a> using the device id of the engine. <br /></td></tr>
<tr class="separator:ga576531f108e7a5ca7f8af1b26c066a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e9d349ba8731b6022a65c3abaad78bd"><td class="memTemplParams" colspan="2">
template&lt;typename ArrayType &gt; </td></tr>
<tr class="memitem:ga5e9d349ba8731b6022a65c3abaad78bd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUENGINE.html#ga5e9d349ba8731b6022a65c3abaad78bd">wrap_array</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;engine, ArrayType arr[], size_t num_entries)</td></tr>
<tr class="memdesc:ga5e9d349ba8731b6022a65c3abaad78bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of <a class="el" href="classhala_1_1gpu__wrapped__array.html" title="Wrapper around C-style GPU arrays that can be passed to hala::gpu_engine templates. ">hala::gpu_wrapped_array</a>. <br /></td></tr>
<tr class="separator:ga5e9d349ba8731b6022a65c3abaad78bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19976e990331502509b0298527ab1cfc"><td class="memTemplParams" colspan="2">
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV &gt; </td></tr>
<tr class="memitem:ga19976e990331502509b0298527ab1cfc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUSPARSEILU.html#ga19976e990331502509b0298527ab1cfc">make_ilu</a> (<a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;cengine, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, char policy)</td></tr>
<tr class="memdesc:ga19976e990331502509b0298527ab1cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ILU factorization using the <a class="el" href="structhala_1_1gpu__engine.html" title="Core engine class, deals with handles and data transfer. ">gpu_engine</a>. <br /></td></tr>
<tr class="separator:ga19976e990331502509b0298527ab1cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecf398343da3b3e5ee85ba5c2d822313"><td class="memTemplParams" colspan="2">
template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:gaecf398343da3b3e5ee85ba5c2d822313"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUVECTOR.html#gaecf398343da3b3e5ee85ba5c2d822313">make_gpu_vector</a> (const VectorLike &amp;cpu_data, int gpuid=0)</td></tr>
<tr class="memdesc:gaecf398343da3b3e5ee85ba5c2d822313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classhala_1_1gpu__vector.html" title="Templated class providing functionality similar to C++ containers. ">hala::gpu_vector</a> with type matching <b>VectorLike</b>, load the data from <b>VectorLike</b> into the array. <br /></td></tr>
<tr class="separator:gaecf398343da3b3e5ee85ba5c2d822313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16584f7ab6e0afe535801f418ac98773"><td class="memTemplParams" colspan="2">
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga16584f7ab6e0afe535801f418ac98773"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUVECTOR.html#ga16584f7ab6e0afe535801f418ac98773">make_gpu_vector</a> (size_t num_entries, int gpuid=0)</td></tr>
<tr class="memdesc:ga16584f7ab6e0afe535801f418ac98773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="classhala_1_1gpu__vector.html" title="Templated class providing functionality similar to C++ containers. ">hala::gpu_vector</a> with given type and <b>num_entries</b> on the given GPU device. <br /></td></tr>
<tr class="separator:ga16584f7ab6e0afe535801f418ac98773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9c08360b2dc6a79d592b6af416ed79"><td class="memTemplParams" colspan="2">
template&lt;typename ArrayType &gt; </td></tr>
<tr class="memitem:ga6d9c08360b2dc6a79d592b6af416ed79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classhala_1_1gpu__wrapped__array.html">gpu_wrapped_array</a>&lt; ArrayType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAGPUWRAP.html#ga6d9c08360b2dc6a79d592b6af416ed79">wrap_gpu_array</a> (ArrayType arr[], size_t num_entries)</td></tr>
<tr class="memdesc:ga6d9c08360b2dc6a79d592b6af416ed79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a wrapper around the C-style GPU arrays that can be passed to HALA templates. <br /></td></tr>
<tr class="separator:ga6d9c08360b2dc6a79d592b6af416ed79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbb5e073c7548dcdfe60223b75f039a"><td class="memItemLeft" align="right" valign="top"><a id="a0cbb5e073c7548dcdfe60223b75f039a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a0cbb5e073c7548dcdfe60223b75f039a">info_from</a> (rocblas_status status)</td></tr>
<tr class="memdesc:a0cbb5e073c7548dcdfe60223b75f039a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts rocblas status into a human readable string. <br /></td></tr>
<tr class="separator:a0cbb5e073c7548dcdfe60223b75f039a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e51ef421af4ac803f2970ed095b16f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a8e51ef421af4ac803f2970ed095b16f6">check_rocm</a> (rocblas_status status, std::string const &amp;function_name)</td></tr>
<tr class="memdesc:a8e51ef421af4ac803f2970ed095b16f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if cuda returns cudaSuccess; if not, throw <b>runtime_error</b> and append <b>message</b> to the cuda error info.  <a href="#a8e51ef421af4ac803f2970ed095b16f6">More...</a><br /></td></tr>
<tr class="separator:a8e51ef421af4ac803f2970ed095b16f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ece98e7b56cfae39e940f075722fa4e"><td class="memItemLeft" align="right" valign="top"><a id="a1ece98e7b56cfae39e940f075722fa4e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a1ece98e7b56cfae39e940f075722fa4e">check_rocm</a> (hipError_t status, std::string const &amp;function_name)</td></tr>
<tr class="memdesc:a1ece98e7b56cfae39e940f075722fa4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check AMD HIP status. <br /></td></tr>
<tr class="separator:a1ece98e7b56cfae39e940f075722fa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084b2928db38d82d03429ab50e3af15c"><td class="memItemLeft" align="right" valign="top"><a id="a084b2928db38d82d03429ab50e3af15c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a084b2928db38d82d03429ab50e3af15c">check_rocm</a> (rocsparse_status status, std::string const &amp;function_name)</td></tr>
<tr class="memdesc:a084b2928db38d82d03429ab50e3af15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check AMD HIP status. <br /></td></tr>
<tr class="separator:a084b2928db38d82d03429ab50e3af15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d313e16ac90e1a7d2ed7b3f55388288"><td class="memTemplParams" colspan="2"><a id="a8d313e16ac90e1a7d2ed7b3f55388288"></a>
template&lt;typename criteria , typename Fsingle , typename Fdouble , typename Fcomplex , typename Fzomplex , class Engine , class... Inputs&gt; </td></tr>
<tr class="memitem:a8d313e16ac90e1a7d2ed7b3f55388288"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a8d313e16ac90e1a7d2ed7b3f55388288">rocm_call_backend</a> (Fsingle &amp;sfunc, Fdouble &amp;dfunc, Fcomplex &amp;cfunc, Fzomplex &amp;zfunc, std::string const &amp;function_name, Engine const &amp;engine, Inputs const &amp;...args)</td></tr>
<tr class="memdesc:a8d313e16ac90e1a7d2ed7b3f55388288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very similar to <a class="el" href="namespacehala.html#ada3048131102af6636985a61bad422e5" title="Call one of the 4 possible functions according to the criteria. ">hala::call_backend()</a>, wraps all calls with check_rocm and accepts an engine and string with function name. <br /></td></tr>
<tr class="separator:a8d313e16ac90e1a7d2ed7b3f55388288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59494ee34eae655c1fee94b66e08e0e8"><td class="memTemplParams" colspan="2"><a id="a59494ee34eae655c1fee94b66e08e0e8"></a>
template&lt;bool flag, typename criteria , typename Fsingle , typename Fdouble , typename Fcomplex , typename Fzomplex , typename Frcomplex , typename Frzomplex , class Engine , class... Inputs&gt; </td></tr>
<tr class="memitem:a59494ee34eae655c1fee94b66e08e0e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a59494ee34eae655c1fee94b66e08e0e8">rocm_call_backend6</a> (Fsingle &amp;sfunc, Fdouble &amp;dfunc, Fcomplex &amp;cfunc, Fzomplex &amp;zfunc, Frcomplex &amp;crfunc, Frzomplex &amp;zrfunc, std::string const &amp;function_name, Engine const &amp;engine, Inputs const &amp;...args)</td></tr>
<tr class="memdesc:a59494ee34eae655c1fee94b66e08e0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Very similar to <a class="el" href="namespacehala.html#ada3048131102af6636985a61bad422e5" title="Call one of the 4 possible functions according to the criteria. ">hala::call_backend()</a>, wraps all calls with check_rocm and accepts an engine and string with function name. <br /></td></tr>
<tr class="separator:a59494ee34eae655c1fee94b66e08e0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a80b31f00e6b57b9fdcfee9e2db0014"><td class="memTemplParams" colspan="2">template&lt;bool conjugate, typename scalar_type &gt; </td></tr>
<tr class="memitem:a1a80b31f00e6b57b9fdcfee9e2db0014"><td class="memTemplItemLeft" align="right" valign="top">rocblas_operation&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a1a80b31f00e6b57b9fdcfee9e2db0014">hermitian_trans</a> (char &amp;trans)</td></tr>
<tr class="memdesc:a1a80b31f00e6b57b9fdcfee9e2db0014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts trans character to one compatible with rocsparse hermitian operations.  <a href="#a1a80b31f00e6b57b9fdcfee9e2db0014">More...</a><br /></td></tr>
<tr class="separator:a1a80b31f00e6b57b9fdcfee9e2db0014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0306c1a1999c77461f60fb60786893"><td class="memTemplParams" colspan="2"><a id="a3e0306c1a1999c77461f60fb60786893"></a>
template&lt;typename scalar_type &gt; </td></tr>
<tr class="memitem:a3e0306c1a1999c77461f60fb60786893"><td class="memTemplItemLeft" align="right" valign="top">rocsparse_operation&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a3e0306c1a1999c77461f60fb60786893">trans_to_rocm_sparse</a> (char trans)</td></tr>
<tr class="memdesc:a3e0306c1a1999c77461f60fb60786893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts characters N, T, C (upper or lower) to the correct rocsparse_operation. <br /></td></tr>
<tr class="separator:a3e0306c1a1999c77461f60fb60786893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69018eee242b66f8b7fbb1fa63941874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhala_1_1rocm__struct__description.html">rocm_struct_description</a>&lt; rocsparse_mat_descr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a69018eee242b66f8b7fbb1fa63941874">make_rocsparse_general_description</a> (char diag='N')</td></tr>
<tr class="memdesc:a69018eee242b66f8b7fbb1fa63941874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method for a general matrix description.  <a href="#a69018eee242b66f8b7fbb1fa63941874">More...</a><br /></td></tr>
<tr class="separator:a69018eee242b66f8b7fbb1fa63941874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23fb8e7c8a4a7aa618ab8317a4da3a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhala_1_1rocm__struct__description.html">rocm_struct_description</a>&lt; rocsparse_mat_descr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#ae23fb8e7c8a4a7aa618ab8317a4da3a8">make_rocsparse_triangular_description</a> (char uplo, char diag)</td></tr>
<tr class="memdesc:ae23fb8e7c8a4a7aa618ab8317a4da3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method for a triangular matrix description.  <a href="#ae23fb8e7c8a4a7aa618ab8317a4da3a8">More...</a><br /></td></tr>
<tr class="separator:ae23fb8e7c8a4a7aa618ab8317a4da3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19a9aa4205df25be0bade0c586488640"><td class="memTemplParams" colspan="2">template&lt;typename FPA , class VectorLikeA , class VectorLikeX , class VectorLikeY &gt; </td></tr>
<tr class="memitem:ga19a9aa4205df25be0bade0c586488640"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAWAXBLAS.html#ga19a9aa4205df25be0bade0c586488640">batch_axpy</a> (int batch_size, FPA alphac, VectorLikeA const &amp;alpha, VectorLikeX const &amp;x, VectorLikeY &amp;&amp;y)</td></tr>
<tr class="memdesc:ga19a9aa4205df25be0bade0c586488640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the scaled vector sum of a batch of one dimensional vectors and scalars, where the vectors are stored contiguously.  <a href="group__HALAWAXBLAS.html#ga19a9aa4205df25be0bade0c586488640">More...</a><br /></td></tr>
<tr class="separator:ga19a9aa4205df25be0bade0c586488640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ea43e79bfb03934cc07d297f6726b2"><td class="memTemplParams" colspan="2">template&lt;bool conjugate = true, class VectorLikeX , class VectorLikeY , class VectorLikeR &gt; </td></tr>
<tr class="memitem:ga76ea43e79bfb03934cc07d297f6726b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAWAXBLAS.html#ga76ea43e79bfb03934cc07d297f6726b2">batch_dot</a> (int batch_size, VectorLikeX const &amp;x, VectorLikeY const &amp;y, VectorLikeR &amp;&amp;result)</td></tr>
<tr class="memdesc:ga76ea43e79bfb03934cc07d297f6726b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot-product for a batch of one dimensional vectors.  <a href="group__HALAWAXBLAS.html#ga76ea43e79bfb03934cc07d297f6726b2">More...</a><br /></td></tr>
<tr class="separator:ga76ea43e79bfb03934cc07d297f6726b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d3d4f03da29c6cc6cf4b240e6a07c27"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeA , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga9d3d4f03da29c6cc6cf4b240e6a07c27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAWAXBLAS.html#ga9d3d4f03da29c6cc6cf4b240e6a07c27">batch_scal</a> (int batch_size, VectorLikeA const &amp;alpha, VectorLikeX &amp;&amp;x)</td></tr>
<tr class="memdesc:ga9d3d4f03da29c6cc6cf4b240e6a07c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a batch of vectors by a set of constants.  <a href="group__HALAWAXBLAS.html#ga9d3d4f03da29c6cc6cf4b240e6a07c27">More...</a><br /></td></tr>
<tr class="separator:ga9d3d4f03da29c6cc6cf4b240e6a07c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27d50beba7026da717f6ebc52ac5ca6a"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX , class VectorLikeY , class VectorLikeZ &gt; </td></tr>
<tr class="memitem:ga27d50beba7026da717f6ebc52ac5ca6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAWAXBLAS.html#ga27d50beba7026da717f6ebc52ac5ca6a">vdivide</a> (VectorLikeX const &amp;x, VectorLikeY const &amp;y, VectorLikeZ &amp;&amp;z)</td></tr>
<tr class="memdesc:ga27d50beba7026da717f6ebc52ac5ca6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide the two vectors component-wise.  <a href="group__HALAWAXBLAS.html#ga27d50beba7026da717f6ebc52ac5ca6a">More...</a><br /></td></tr>
<tr class="separator:ga27d50beba7026da717f6ebc52ac5ca6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga329f68a7f474c1502564d9afe5c6c729"><td class="memTemplParams" colspan="2">template&lt;class cengine , class VectorLike &gt; </td></tr>
<tr class="memitem:ga329f68a7f474c1502564d9afe5c6c729"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAWAXBLAS.html#ga329f68a7f474c1502564d9afe5c6c729">batch_max_norm2</a> (cengine const &amp;engine, int batch_size, VectorLike const &amp;x)</td></tr>
<tr class="memdesc:ga329f68a7f474c1502564d9afe5c6c729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the norm of the largest vector in a batch.  <a href="group__HALAWAXBLAS.html#ga329f68a7f474c1502564d9afe5c6c729">More...</a><br /></td></tr>
<tr class="separator:ga329f68a7f474c1502564d9afe5c6c729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbb85d1036a69e9428cb55e311e54b1"><td class="memTemplParams" colspan="2">template&lt;class vec &gt; </td></tr>
<tr class="memitem:acdbb85d1036a69e9428cb55e311e54b1"><td class="memTemplItemLeft" align="right" valign="top">vec &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#acdbb85d1036a69e9428cb55e311e54b1">get_vec</a> (vec &amp;x)</td></tr>
<tr class="separator:acdbb85d1036a69e9428cb55e311e54b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad431721db0a8ddfb1960177fca63f929"><td class="memTemplParams" colspan="2">template&lt;class vec &gt; </td></tr>
<tr class="memitem:ad431721db0a8ddfb1960177fca63f929"><td class="memTemplItemLeft" align="right" valign="top">vec &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ad431721db0a8ddfb1960177fca63f929">get_vec</a> (std::reference_wrapper&lt; vec &gt; &amp;x)</td></tr>
<tr class="separator:ad431721db0a8ddfb1960177fca63f929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af93347509b5485cfbfd6926bd6749782"><td class="memTemplParams" colspan="2">template&lt;class ev1 , class ev2 &gt; </td></tr>
<tr class="memitem:af93347509b5485cfbfd6926bd6749782"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#af93347509b5485cfbfd6926bd6749782">check_engines</a> (ev1 const &amp;x, ev2 const &amp;y)</td></tr>
<tr class="separator:af93347509b5485cfbfd6926bd6749782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ae7eba405e49b271e1279c2ec3f170"><td class="memTemplParams" colspan="2">template&lt;class cengine , class vec &gt; </td></tr>
<tr class="memitem:gaf4ae7eba405e49b271e1279c2ec3f170"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structhala_1_1is__engine.html">is_engine</a>&lt; cengine &gt;::value, <a class="el" href="structhala_1_1engined__vector.html">engined_vector</a>&lt; cengine, vec &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAWAXENGINED.html#gaf4ae7eba405e49b271e1279c2ec3f170">bind_engine_vector</a> (cengine const &amp;e, vec &amp;x)</td></tr>
<tr class="memdesc:gaf4ae7eba405e49b271e1279c2ec3f170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a bind between the engine and the vector.  <a href="group__HALAWAXENGINED.html#gaf4ae7eba405e49b271e1279c2ec3f170">More...</a><br /></td></tr>
<tr class="separator:gaf4ae7eba405e49b271e1279c2ec3f170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7598f11a087eadfb9be908699b8e8834"><td class="memTemplParams" colspan="2">template&lt;class cengine , class vec &gt; </td></tr>
<tr class="memitem:ga7598f11a087eadfb9be908699b8e8834"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAWAXENGINED.html#ga7598f11a087eadfb9be908699b8e8834">get_engine</a> (<a class="el" href="structhala_1_1engined__vector.html">engined_vector</a>&lt; cengine, vec &gt; const &amp;x)</td></tr>
<tr class="memdesc:ga7598f11a087eadfb9be908699b8e8834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the engine associated with the vector.  <a href="group__HALAWAXENGINED.html#ga7598f11a087eadfb9be908699b8e8834">More...</a><br /></td></tr>
<tr class="separator:ga7598f11a087eadfb9be908699b8e8834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab396d1d160e3dd5bd3ba163b788b7f51"><td class="memTemplParams" colspan="2">template&lt;class ClassILU , class VectorLikeX , class VectorLikeR &gt; </td></tr>
<tr class="memitem:gab396d1d160e3dd5bd3ba163b788b7f51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAWAXSPARSE.html#gab396d1d160e3dd5bd3ba163b788b7f51">ilu_apply</a> (ClassILU const &amp;ilu, VectorLikeX const &amp;x, VectorLikeR &amp;&amp;r, int num_rhs=1)</td></tr>
<tr class="memdesc:gab396d1d160e3dd5bd3ba163b788b7f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functional overload of ILU apply.  <a href="group__HALAWAXSPARSE.html#gab396d1d160e3dd5bd3ba163b788b7f51">More...</a><br /></td></tr>
<tr class="separator:gab396d1d160e3dd5bd3ba163b788b7f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga302be77cfa2a20131a4546ee6d9a4da9"><td class="memTemplParams" colspan="2">template&lt;typename T , class VectorLikeX , class VectorLikeR &gt; </td></tr>
<tr class="memitem:ga302be77cfa2a20131a4546ee6d9a4da9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAWAXSPARSE.html#ga302be77cfa2a20131a4546ee6d9a4da9">ilu_temp_buffer</a> (<a class="el" href="structhala_1_1cpu__ilu.html">cpu_ilu</a>&lt; T &gt; const &amp;, VectorLikeX const &amp;, VectorLikeR &amp;&amp;, int=1)</td></tr>
<tr class="memdesc:ga302be77cfa2a20131a4546ee6d9a4da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functional overload of ILU that creates a temporary buffer.  <a href="group__HALAWAXSPARSE.html#ga302be77cfa2a20131a4546ee6d9a4da9">More...</a><br /></td></tr>
<tr class="separator:ga302be77cfa2a20131a4546ee6d9a4da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga108524f442e0748d505426150ce3df9a"><td class="memTemplParams" colspan="2">template&lt;typename T , class VectorLikeX , class VectorLikeR &gt; </td></tr>
<tr class="memitem:ga108524f442e0748d505426150ce3df9a"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAWAXSPARSE.html#ga108524f442e0748d505426150ce3df9a">ilu_buffer_size</a> (<a class="el" href="structhala_1_1cpu__ilu.html">cpu_ilu</a>&lt; T &gt; const &amp;ilu, VectorLikeX const &amp;x, VectorLikeR &amp;&amp;r, int num_rhs=1)</td></tr>
<tr class="memdesc:ga108524f442e0748d505426150ce3df9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functional overload of ILU that returns the buffer size.  <a href="group__HALAWAXSPARSE.html#ga108524f442e0748d505426150ce3df9a">More...</a><br /></td></tr>
<tr class="separator:ga108524f442e0748d505426150ce3df9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e4063a492511f9d6ee648c05a818a4"><td class="memTemplParams" colspan="2">template&lt;typename hscalar , typename hvectorx , typename hvectorb , typename htypea , typename htypeb , typename htypec , typename htyped , typename htypef , typename htypeg , typename htypeh , typename htypei , typename htypej , typename htypek , typename htypel , typename htypem , typename htypen &gt; </td></tr>
<tr class="memitem:a49e4063a492511f9d6ee648c05a818a4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a49e4063a492511f9d6ee648c05a818a4">solve_cg_core</a> (htypea apply_preconditioner, htypeb apply_operator, htypen apply_operator_internal, hvectorx const &amp;b, hvectorb &amp;x, htypem scalar_make, htypec scalar_division, htyped scalar_move, htypef vector_scale, htypeg vector_add, htypeh vector_sub, htypei vector_sadd, htypej vector_ssub, htypek vector_dot, htypel check_converged)</td></tr>
<tr class="separator:a49e4063a492511f9d6ee648c05a818a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4504714a7b2fc6f222683558d666f261"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikeX , class VectorLikeB &gt; </td></tr>
<tr class="memitem:ga4504714a7b2fc6f222683558d666f261"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASOLVECG.html#ga4504714a7b2fc6f222683558d666f261">solve_cg</a> (<a class="el" href="structhala_1_1stop__criteria.html">stop_criteria</a>&lt; <a class="el" href="group__HALACUSTOM.html#ga78609b70f45312e08e520b6ed736ff40">get_precision_type</a>&lt; VectorLikeV &gt;&gt; const &amp;stop, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, <a class="el" href="group__HALASOLVERS.html#ga79e339da4158ec79ddcfae6317588390">preconditioner_noe</a>&lt; VectorLikeV &gt; precon, VectorLikeB const &amp;b, VectorLikeX &amp;x)</td></tr>
<tr class="memdesc:ga4504714a7b2fc6f222683558d666f261"><td class="mdescLeft">&#160;</td><td class="mdescRight">General preconditioned conjugate-gradient solver.  <a href="group__HALASOLVECG.html#ga4504714a7b2fc6f222683558d666f261">More...</a><br /></td></tr>
<tr class="separator:ga4504714a7b2fc6f222683558d666f261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2e7082825d7bf032b07971dd96bb693"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV , class ILUclass , class VectorLikeX , class VectorLikeB &gt; </td></tr>
<tr class="memitem:gaa2e7082825d7bf032b07971dd96bb693"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASOLVECG.html#gaa2e7082825d7bf032b07971dd96bb693">solve_cg_ilu</a> (<a class="el" href="structhala_1_1stop__criteria.html">stop_criteria</a>&lt; <a class="el" href="group__HALACUSTOM.html#ga78609b70f45312e08e520b6ed736ff40">get_precision_type</a>&lt; VectorLikeV &gt;&gt; const &amp;stop, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, ILUclass const &amp;ilu, VectorLikeB const &amp;b, VectorLikeX &amp;x)</td></tr>
<tr class="memdesc:gaa2e7082825d7bf032b07971dd96bb693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conjugate-gradient solver with ILU preconditioner, single right-hand-side.  <a href="group__HALASOLVECG.html#gaa2e7082825d7bf032b07971dd96bb693">More...</a><br /></td></tr>
<tr class="separator:gaa2e7082825d7bf032b07971dd96bb693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22db1f1386748881ce81fb6ef0627690"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikeX , class VectorLikeB &gt; </td></tr>
<tr class="memitem:ga22db1f1386748881ce81fb6ef0627690"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASOLVECGBATCH.html#ga22db1f1386748881ce81fb6ef0627690">solve_batch_cg</a> (<a class="el" href="structhala_1_1stop__criteria.html">stop_criteria</a>&lt; <a class="el" href="group__HALACUSTOM.html#ga78609b70f45312e08e520b6ed736ff40">get_precision_type</a>&lt; VectorLikeV &gt;&gt; const &amp;stop, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, <a class="el" href="group__HALASOLVERS.html#ga79e339da4158ec79ddcfae6317588390">preconditioner_noe</a>&lt; VectorLikeV &gt; precon, VectorLikeB const &amp;B, VectorLikeX &amp;X)</td></tr>
<tr class="memdesc:ga22db1f1386748881ce81fb6ef0627690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conjugate-Gradient method with multiple right-hand sides.  <a href="group__HALASOLVECGBATCH.html#ga22db1f1386748881ce81fb6ef0627690">More...</a><br /></td></tr>
<tr class="separator:ga22db1f1386748881ce81fb6ef0627690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8237b0b0cdbe75523c2c9f2c2515f1"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV , class ILUclass , class VectorLikeX , class VectorLikeB &gt; </td></tr>
<tr class="memitem:gaee8237b0b0cdbe75523c2c9f2c2515f1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASOLVECGBATCH.html#gaee8237b0b0cdbe75523c2c9f2c2515f1">solve_batch_cg_ilu</a> (<a class="el" href="structhala_1_1stop__criteria.html">stop_criteria</a>&lt; <a class="el" href="group__HALACUSTOM.html#ga78609b70f45312e08e520b6ed736ff40">get_precision_type</a>&lt; VectorLikeV &gt;&gt; const &amp;stop, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, ILUclass const &amp;ilu, VectorLikeB const &amp;B, VectorLikeX &amp;X)</td></tr>
<tr class="memdesc:gaee8237b0b0cdbe75523c2c9f2c2515f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batch Conjugate-Gradient method with ILU preconditioner.  <a href="group__HALASOLVECGBATCH.html#gaee8237b0b0cdbe75523c2c9f2c2515f1">More...</a><br /></td></tr>
<tr class="separator:gaee8237b0b0cdbe75523c2c9f2c2515f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf3133c79ea91bccde8071a2a1998ce"><td class="memTemplParams" colspan="2">template&lt;class VectorLike , class VectorLikeResult &gt; </td></tr>
<tr class="memitem:a8bf3133c79ea91bccde8071a2a1998ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a8bf3133c79ea91bccde8071a2a1998ce">krylov_project</a> (<a class="el" href="structhala_1_1cpu__engine.html">cpu_engine</a> const &amp;, int num_rows, int num_basis, VectorLike &amp;r, VectorLike const &amp;W, VectorLikeResult &amp;coeffs)</td></tr>
<tr class="separator:a8bf3133c79ea91bccde8071a2a1998ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8318e46d881be063f0410a19e96f9bfe"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeX , class VectorLikeW , class VectorLikeCoeff &gt; </td></tr>
<tr class="memitem:a8318e46d881be063f0410a19e96f9bfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a8318e46d881be063f0410a19e96f9bfe">krylov_combine</a> (<a class="el" href="structhala_1_1cpu__engine.html">cpu_engine</a> const &amp;, int num_rows, int num_basis, VectorLikeW &amp;W, VectorLikeCoeff const &amp;coeffs, VectorLikeX &amp;&amp;x)</td></tr>
<tr class="separator:a8318e46d881be063f0410a19e96f9bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f596d6e84d3c048023b11c6d56a0a1f"><td class="memTemplParams" colspan="2">template&lt;class compute_engine , class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikeX , class VectorLikeB &gt; </td></tr>
<tr class="memitem:ga2f596d6e84d3c048023b11c6d56a0a1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehala.html#acb09081de2bccbc9add2b253d4793368">hala_int</a>&lt; compute_engine &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASOLVEGMRES.html#ga2f596d6e84d3c048023b11c6d56a0a1f">solve_gmres</a> (compute_engine const &amp;engine, <a class="el" href="structhala_1_1stop__criteria.html">stop_criteria</a>&lt; <a class="el" href="group__HALACUSTOM.html#ga78609b70f45312e08e520b6ed736ff40">get_precision_type</a>&lt; VectorLikeV &gt;&gt; const &amp;stop, int restart, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, <a class="el" href="group__HALASOLVERS.html#ga4e42c8118b1a08628124f28874d411cf">preconditioner</a>&lt; compute_engine, VectorLikeV &gt; precon, VectorLikeB const &amp;b, VectorLikeX &amp;x)</td></tr>
<tr class="memdesc:ga2f596d6e84d3c048023b11c6d56a0a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">General restarted preconditioned Minimum RESidula (GMRES) method, base template.  <a href="group__HALASOLVEGMRES.html#ga2f596d6e84d3c048023b11c6d56a0a1f">More...</a><br /></td></tr>
<tr class="separator:ga2f596d6e84d3c048023b11c6d56a0a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cd7fcc796fad467b62159e72a1ca792"><td class="memTemplParams" colspan="2">template&lt;class compute_engine , class VectorLikeP , class VectorLikeI , class VectorLikeV , class ILUclass , class VectorLikeX , class VectorLikeB &gt; </td></tr>
<tr class="memitem:ga1cd7fcc796fad467b62159e72a1ca792"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacehala.html#acb09081de2bccbc9add2b253d4793368">hala_int</a>&lt; compute_engine &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASOLVEGMRES.html#ga1cd7fcc796fad467b62159e72a1ca792">solve_gmres_ilu</a> (compute_engine const &amp;engine, <a class="el" href="structhala_1_1stop__criteria.html">stop_criteria</a>&lt; <a class="el" href="group__HALACUSTOM.html#ga78609b70f45312e08e520b6ed736ff40">get_precision_type</a>&lt; VectorLikeV &gt;&gt; const &amp;stop, int restart, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, ILUclass const &amp;ilu, VectorLikeB const &amp;b, VectorLikeX &amp;x)</td></tr>
<tr class="memdesc:ga1cd7fcc796fad467b62159e72a1ca792"><td class="mdescLeft">&#160;</td><td class="mdescRight">General restarted Minimum RESidula (GMRES) method with ILU preconditioner.  <a href="group__HALASOLVEGMRES.html#ga1cd7fcc796fad467b62159e72a1ca792">More...</a><br /></td></tr>
<tr class="separator:ga1cd7fcc796fad467b62159e72a1ca792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2de04e04f6c008a165b35da8f9ff19af"><td class="memTemplParams" colspan="2">
template&lt;typename VectorLikeP , typename VectorLikeI , typename VectorLikeV &gt; </td></tr>
<tr class="memitem:ga2de04e04f6c008a165b35da8f9ff19af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACHOLMOD.html#ga2de04e04f6c008a165b35da8f9ff19af">cholmod_factorize_spd</a> (VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals)</td></tr>
<tr class="memdesc:ga2de04e04f6c008a165b35da8f9ff19af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize the symmetric positive definite sparse matrix and return appropriate <b><a class="el" href="classhala_1_1cholmod__factor.html" title="Wrapper around a factorization of a sparse matrix using the Cholmod library. ">hala::cholmod_factor</a></b>. <br /></td></tr>
<tr class="separator:ga2de04e04f6c008a165b35da8f9ff19af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97190065e592682890abad254f49cb39"><td class="memTemplParams" colspan="2">
template&lt;typename VectorLikeP , typename VectorLikeI , typename VectorLikeV &gt; </td></tr>
<tr class="memitem:ga97190065e592682890abad254f49cb39"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACHOLMOD.html#ga97190065e592682890abad254f49cb39">cholmod_factorize_gen</a> (VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals)</td></tr>
<tr class="memdesc:ga97190065e592682890abad254f49cb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorize the general sparse matrix and return appropriate <b><a class="el" href="classhala_1_1cholmod__factor.html" title="Wrapper around a factorization of a sparse matrix using the Cholmod library. ">hala::cholmod_factor</a></b>. <br /></td></tr>
<tr class="separator:ga97190065e592682890abad254f49cb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e05fbd87f05b4cfd4886b3895d6ce5"><td class="memTemplParams" colspan="2">template&lt;typename T , regtype R&gt; </td></tr>
<tr class="memitem:gad4e05fbd87f05b4cfd4886b3895d6ce5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhala_1_1aligned__iterator.html">aligned_iterator</a>&lt; T, R, <a class="el" href="group__HALAALALLOC.html#gadb6d5e51fe0f4ebf2e5ff5c54bda1b0e">aligned_vector</a>&lt; T, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAALALLOC.html#gad4e05fbd87f05b4cfd4886b3895d6ce5">mmbegin</a> (<a class="el" href="group__HALAALALLOC.html#gadb6d5e51fe0f4ebf2e5ff5c54bda1b0e">aligned_vector</a>&lt; T, R &gt; &amp;x)</td></tr>
<tr class="memdesc:gad4e05fbd87f05b4cfd4886b3895d6ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new aligned iterator starting from the beginning.  <a href="group__HALAALALLOC.html#gad4e05fbd87f05b4cfd4886b3895d6ce5">More...</a><br /></td></tr>
<tr class="separator:gad4e05fbd87f05b4cfd4886b3895d6ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420a685902b4fc1e4fb75ffeeeecd21c"><td class="memTemplParams" colspan="2">template&lt;typename T , regtype R&gt; </td></tr>
<tr class="memitem:ga420a685902b4fc1e4fb75ffeeeecd21c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhala_1_1aligned__iterator.html">aligned_iterator</a>&lt; T, R, <a class="el" href="group__HALAALALLOC.html#gadb6d5e51fe0f4ebf2e5ff5c54bda1b0e">aligned_vector</a>&lt; T, R &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAALALLOC.html#ga420a685902b4fc1e4fb75ffeeeecd21c">mmend</a> (<a class="el" href="group__HALAALALLOC.html#gadb6d5e51fe0f4ebf2e5ff5c54bda1b0e">aligned_vector</a>&lt; T, R &gt; &amp;x)</td></tr>
<tr class="memdesc:ga420a685902b4fc1e4fb75ffeeeecd21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-const aligned iterator pointing to the first non-aligned strip.  <a href="group__HALAALALLOC.html#ga420a685902b4fc1e4fb75ffeeeecd21c">More...</a><br /></td></tr>
<tr class="separator:ga420a685902b4fc1e4fb75ffeeeecd21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d5c19b35dc4fb6098208fadb43a8239"><td class="memTemplParams" colspan="2">template&lt;typename T , regtype R&gt; </td></tr>
<tr class="memitem:ga6d5c19b35dc4fb6098208fadb43a8239"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAALALLOC.html#ga6d5c19b35dc4fb6098208fadb43a8239">mmrem</a> (<a class="el" href="group__HALAALALLOC.html#gadb6d5e51fe0f4ebf2e5ff5c54bda1b0e">aligned_vector</a>&lt; T, R &gt; &amp;x)</td></tr>
<tr class="memdesc:ga6d5c19b35dc4fb6098208fadb43a8239"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new ordinary iterator pointing to the first of the remaining non-aligned entries.  <a href="group__HALAALALLOC.html#ga6d5c19b35dc4fb6098208fadb43a8239">More...</a><br /></td></tr>
<tr class="separator:ga6d5c19b35dc4fb6098208fadb43a8239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeabba0ac09bef59236ff72264fa06111"><td class="memTemplParams" colspan="2">template&lt;regtype R = default_regtype, class VectorIterator , typename T  = typename std::iterator_traits&lt;VectorIterator&gt;::value_type&gt; </td></tr>
<tr class="memitem:gaeabba0ac09bef59236ff72264fa06111"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAALALLOC.html#gaeabba0ac09bef59236ff72264fa06111">mmadvance</a> (VectorIterator &amp;a)</td></tr>
<tr class="memdesc:gaeabba0ac09bef59236ff72264fa06111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance an iterator by one stride.  <a href="group__HALAALALLOC.html#gaeabba0ac09bef59236ff72264fa06111">More...</a><br /></td></tr>
<tr class="separator:gaeabba0ac09bef59236ff72264fa06111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11acc3bbe4ad9d8c317a1772604207ef"><td class="memTemplParams" colspan="2">
template&lt;regtype R = default_regtype, class VectorLike &gt; </td></tr>
<tr class="memitem:ga11acc3bbe4ad9d8c317a1772604207ef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAALALLOC.html#ga11acc3bbe4ad9d8c317a1772604207ef">make_aligned</a> (VectorLike const &amp;x)</td></tr>
<tr class="memdesc:ga11acc3bbe4ad9d8c317a1772604207ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy <b>x</b> into a std::vector using the <b><a class="el" href="classhala_1_1aligned__allocator.html" title="Allocator that aligns memory to the selected register. ">aligned_allocator</a></b>, copy is done either with BLAS xcopy or std::copy. <br /></td></tr>
<tr class="separator:ga11acc3bbe4ad9d8c317a1772604207ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14f5262dde3f5ac172846b78f6549876"><td class="memTemplParams" colspan="2">template&lt;regtype R = default_regtype, typename T &gt; </td></tr>
<tr class="memitem:ga14f5262dde3f5ac172846b78f6549876"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhala_1_1bind__pack.html">bind_pack</a>&lt; T, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga14f5262dde3f5ac172846b78f6549876">mmbind</a> (T *address)</td></tr>
<tr class="memdesc:ga14f5262dde3f5ac172846b78f6549876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the address to a <a class="el" href="structhala_1_1bind__pack.html" title="Binds a memory slice to an address, constructor reads from the address, destructor writes back...">hala::bind_pack</a>, multiple overloads are provided.  <a href="group__HALAVEX.html#ga14f5262dde3f5ac172846b78f6549876">More...</a><br /></td></tr>
<tr class="separator:ga14f5262dde3f5ac172846b78f6549876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e650c4e0fd090f77d7a5f34b75724a4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__HALAVEX.html#ga5cf9392711eaa1cd0f3ba628585d4bee">regtype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#a1e650c4e0fd090f77d7a5f34b75724a4">get_default_regtype</a> ()</td></tr>
<tr class="separator:a1e650c4e0fd090f77d7a5f34b75724a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa58f7caa6f8fb27e8cb6d9258ad01c"><td class="memTemplParams" colspan="2"><a id="aafa58f7caa6f8fb27e8cb6d9258ad01c"></a>
template&lt;typename &gt; </td></tr>
<tr class="memitem:aafa58f7caa6f8fb27e8cb6d9258ad01c"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#aafa58f7caa6f8fb27e8cb6d9258ad01c">get_size</a> ()</td></tr>
<tr class="memdesc:aafa58f7caa6f8fb27e8cb6d9258ad01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the size of the types, just a helper to define the stride. <br /></td></tr>
<tr class="separator:aafa58f7caa6f8fb27e8cb6d9258ad01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a1fe24400d5cf065ab88cfd1a2b8a1"><td class="memTemplParams" colspan="2"><a id="af1a1fe24400d5cf065ab88cfd1a2b8a1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af1a1fe24400d5cf065ab88cfd1a2b8a1"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#af1a1fe24400d5cf065ab88cfd1a2b8a1">get_size&lt; float &gt;</a> ()</td></tr>
<tr class="memdesc:af1a1fe24400d5cf065ab88cfd1a2b8a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Float is considered one unit of size. <br /></td></tr>
<tr class="separator:af1a1fe24400d5cf065ab88cfd1a2b8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef5be821f2b5b95dc699b29767c40ca"><td class="memTemplParams" colspan="2"><a id="aaef5be821f2b5b95dc699b29767c40ca"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aaef5be821f2b5b95dc699b29767c40ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#aaef5be821f2b5b95dc699b29767c40ca">get_size&lt; double &gt;</a> ()</td></tr>
<tr class="memdesc:aaef5be821f2b5b95dc699b29767c40ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double is two units. <br /></td></tr>
<tr class="separator:aaef5be821f2b5b95dc699b29767c40ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819a344d34dea2fae55d0bc0d0dd8ff8"><td class="memTemplParams" colspan="2"><a id="a819a344d34dea2fae55d0bc0d0dd8ff8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a819a344d34dea2fae55d0bc0d0dd8ff8"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#a819a344d34dea2fae55d0bc0d0dd8ff8">get_size&lt; std::complex&lt; float &gt; &gt;</a> ()</td></tr>
<tr class="memdesc:a819a344d34dea2fae55d0bc0d0dd8ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex-float float is two units. <br /></td></tr>
<tr class="separator:a819a344d34dea2fae55d0bc0d0dd8ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27042a673b3d6d161d297b45e57f1a2"><td class="memTemplParams" colspan="2"><a id="ad27042a673b3d6d161d297b45e57f1a2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ad27042a673b3d6d161d297b45e57f1a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehala.html#ad27042a673b3d6d161d297b45e57f1a2">get_size&lt; std::complex&lt; double &gt; &gt;</a> ()</td></tr>
<tr class="memdesc:ad27042a673b3d6d161d297b45e57f1a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complex-double if 4 units. <br /></td></tr>
<tr class="separator:ad27042a673b3d6d161d297b45e57f1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cf5950d80ce3fade6aad23d8879ac99"><td class="memTemplParams" colspan="2">
template&lt;typename T , regtype R&gt; </td></tr>
<tr class="memitem:ga2cf5950d80ce3fade6aad23d8879ac99"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga2cf5950d80ce3fade6aad23d8879ac99">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structhala_1_1mmpack.html">mmpack</a>&lt; T, R &gt; &amp;s)</td></tr>
<tr class="memdesc:ga2cf5950d80ce3fade6aad23d8879ac99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs all entries of the vector to the stream. <br /></td></tr>
<tr class="separator:ga2cf5950d80ce3fade6aad23d8879ac99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff34187b76d7df81181126329c462c3"><td class="memTemplParams" colspan="2">
template&lt;typename T , regtype R = default_regtype&gt; </td></tr>
<tr class="memitem:gaeff34187b76d7df81181126329c462c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhala_1_1mmpack.html">mmpack</a>&lt; T, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#gaeff34187b76d7df81181126329c462c3">mmzero</a> ()</td></tr>
<tr class="memdesc:gaeff34187b76d7df81181126329c462c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a slice filled with zeros. <br /></td></tr>
<tr class="separator:gaeff34187b76d7df81181126329c462c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c95da1acd7a0b8e27a8db06391f61a8"><td class="memTemplParams" colspan="2">template&lt;regtype R = default_regtype, typename T &gt; </td></tr>
<tr class="memitem:ga5c95da1acd7a0b8e27a8db06391f61a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhala_1_1mmpack.html">mmpack</a>&lt; T, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga5c95da1acd7a0b8e27a8db06391f61a8">mmload</a> (T const *a)</td></tr>
<tr class="memdesc:ga5c95da1acd7a0b8e27a8db06391f61a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a slice filled with the data from <b>a</b>, multiple modes are supported.  <a href="group__HALAVEX.html#ga5c95da1acd7a0b8e27a8db06391f61a8">More...</a><br /></td></tr>
<tr class="separator:ga5c95da1acd7a0b8e27a8db06391f61a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:adef045f05b6ffe8417261fe6b4a4eec9"><td class="memItemLeft" align="right" valign="top"><a id="adef045f05b6ffe8417261fe6b4a4eec9"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacehala.html#adef045f05b6ffe8417261fe6b4a4eec9">assume_output</a> = true</td></tr>
<tr class="memdesc:adef045f05b6ffe8417261fe6b4a4eec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks a variable as output only, allows for expressive calls to <b><a class="el" href="namespacehala.html#a22a221a072d52df2fc701b26836835bd" title="If x is strictly used as output and if the size is insufficient, then resize it; otherwise call asser...">check_set_size()</a></b>. <br /></td></tr>
<tr class="separator:adef045f05b6ffe8417261fe6b4a4eec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d9da2ddaf6fd95898e64516d3a0e743"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__HALAVEX.html#ga5cf9392711eaa1cd0f3ba628585d4bee">regtype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga5d9da2ddaf6fd95898e64516d3a0e743">default_regtype</a> = <a class="el" href="namespacehala.html#a1e650c4e0fd090f77d7a5f34b75724a4">get_default_regtype</a>()</td></tr>
<tr class="memdesc:ga5d9da2ddaf6fd95898e64516d3a0e743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default register type for vectorization, different for each system.  <a href="group__HALAVEX.html#ga5d9da2ddaf6fd95898e64516d3a0e743">More...</a><br /></td></tr>
<tr class="separator:ga5d9da2ddaf6fd95898e64516d3a0e743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae94acb9514813ca67a7517f20ecc090e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structhala_1_1define__unaligned.html">define_unaligned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#gae94acb9514813ca67a7517f20ecc090e">unaligned</a></td></tr>
<tr class="memdesc:gae94acb9514813ca67a7517f20ecc090e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for expressive calls to hala::vex when reading/writing from/to unaligned memory.  <a href="group__HALAVEX.html#gae94acb9514813ca67a7517f20ecc090e">More...</a><br /></td></tr>
<tr class="separator:gae94acb9514813ca67a7517f20ecc090e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaebcc7db0dc6bf8da3ac3ae45847984e"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="structhala_1_1define__aligned.html">define_aligned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#gaaebcc7db0dc6bf8da3ac3ae45847984e">aligned</a></td></tr>
<tr class="memdesc:gaaebcc7db0dc6bf8da3ac3ae45847984e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for expressive calls to hala::vex when reading/writing from/to unaligned memory, see <a class="el" href="group__HALAVEX.html#gae94acb9514813ca67a7517f20ecc090e" title="Allows for expressive calls to hala::vex when reading/writing from/to unaligned memory. ">hala::unaligned</a>. <br /></td></tr>
<tr class="separator:gaaebcc7db0dc6bf8da3ac3ae45847984e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2023aad27a4f5dbaece48b2c57bd90"><td class="memItemLeft" align="right" valign="top">
constexpr <a class="el" href="structhala_1_1define__single.html">define_single</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga7a2023aad27a4f5dbaece48b2c57bd90">single</a></td></tr>
<tr class="memdesc:ga7a2023aad27a4f5dbaece48b2c57bd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for expressive calls to hala::vex when reading/writing a single entry from an array. <br /></td></tr>
<tr class="separator:ga7a2023aad27a4f5dbaece48b2c57bd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Master namespace encapsulating all HALA capabilities. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ac0ae1ffeb6a5b4ccaa1628d44c76d362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ae1ffeb6a5b4ccaa1628d44c76d362">&#9670;&nbsp;</a></span>get_vdefault</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class engine , class VectorLike &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehala.html#ac0ae1ffeb6a5b4ccaa1628d44c76d362">hala::get_vdefault</a> = typedef typename <a class="el" href="structhala_1_1define__vdefault.html">define_vdefault</a>&lt;engine, typename <a class="el" href="structhala_1_1define__type.html">define_type</a>&lt;VectorLike&gt;::value_type&gt;::vector</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb09081de2bccbc9add2b253d4793368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb09081de2bccbc9add2b253d4793368">&#9670;&nbsp;</a></span>hala_int</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class compute_engine &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehala.html#acb09081de2bccbc9add2b253d4793368">hala::hala_int</a> = typedef int</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a37f4d8a83828612055f625f0523ad667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f4d8a83828612055f625f0523ad667">&#9670;&nbsp;</a></span>copy_direction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacehala.html#a37f4d8a83828612055f625f0523ad667">hala::copy_direction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a37f4d8a83828612055f625f0523ad667a2b5f960e5534a6b7454f84eff0c00338"></a>host2device&#160;</td><td class="fielddoc"><p>Copy from host to device. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37f4d8a83828612055f625f0523ad667ad22e421f7bf867f47424129321dbc6d2"></a>device2device&#160;</td><td class="fielddoc"><p>Copy from device to device. </p>
</td></tr>
<tr><td class="fieldname"><a id="a37f4d8a83828612055f625f0523ad667a626599cea05648790c546cb69e0fd765"></a>device2host&#160;</td><td class="fielddoc"><p>Copy from device to host. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7bca3847ab0f6794e00289160ab4a83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bca3847ab0f6794e00289160ab4a83d">&#9670;&nbsp;</a></span>check_trans()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hala::check_trans </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <b>trans</b> is either lower or upper case N, T, or C. </p>

</div>
</div>
<a id="a98850706b7be2eb74266c994d1030a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98850706b7be2eb74266c994d1030a37">&#9670;&nbsp;</a></span>hala_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntA , typename IntB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t hala::hala_size </td>
          <td>(</td>
          <td class="paramtype">IntA&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntB&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22a221a072d52df2fc701b26836835bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a221a072d52df2fc701b26836835bd">&#9670;&nbsp;</a></span>check_set_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLike , typename SizeType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::check_set_size </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLike &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>required_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If <b>x</b> is strictly used as output and if the size is insufficient, then resize it; otherwise call assert <a class="el" href="namespacehala.html#ac5f569cff6185ec959911b50370e6af9" title="Return true if get_size(x) is no less than required_size, also calls static cast to size_t to avoid e...">check_size()</a>. </p>
<p>In many cases a vector is used purely as output, e.g., when calling <a class="el" href="group__HALABLAS3.html#gae98fae51e118dc3682284a5d001cd946" title="Wrapper to BLAS general matrix multiply xgemm(). ">hala::gemm()</a> with beta parameter equal to zero. If the input entries of the vector will not be used, then the vector is strictly an output, even if the vector has insufficient size it can be simply resized. If the vector is not strictly and output, then this is equivalent to <a class="el" href="namespacehala.html#ac5f569cff6185ec959911b50370e6af9" title="Return true if get_size(x) is no less than required_size, also calls static cast to size_t to avoid e...">hala::check_size()</a>. </p>

</div>
</div>
<a id="af7588344969e24ca01cae74737af4a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7588344969e24ca01cae74737af4a81">&#9670;&nbsp;</a></span>check_set_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLike , typename SizeTypeA , typename SizeTypeB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::check_set_size </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLike &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeTypeA&#160;</td>
          <td class="paramname"><em>required_sizeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeTypeB&#160;</td>
          <td class="paramname"><em>required_sizeB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload using required size as the product of two numbers. </p>
<p>Identical to <a class="el" href="namespacehala.html#a22a221a072d52df2fc701b26836835bd" title="If x is strictly used as output and if the size is insufficient, then resize it; otherwise call asser...">hala::check_set_size()</a> with <a class="el" href="namespacehala.html#a98850706b7be2eb74266c994d1030a37">hala::hala_size()</a> in place of the required size. </p>

</div>
</div>
<a id="a6b8da04eaa2d4b55fa0075c08b9bfef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8da04eaa2d4b55fa0075c08b9bfef3">&#9670;&nbsp;</a></span>pntr_check_set_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FPB , typename VectorLike , typename IntA , typename IntB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; !std::is_pointer&lt;FPB&gt;::value &gt; hala::pntr_check_set_size </td>
          <td>(</td>
          <td class="paramtype">FPB&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLike &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntA&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntB&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If <b>beta</b> is not a pointer, then check if it is zero and resize C if necessary. </p>
<p>Resize <b>C</b> to <b>M</b> by <b>N</b> if beta is zero, i.e., <b>C</b> is pure output. Handles the case when <b>beta</b> is not a pointer and can be used to compare to zero. </p>

</div>
</div>
<a id="ada3048131102af6636985a61bad422e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada3048131102af6636985a61bad422e5">&#9670;&nbsp;</a></span>call_backend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename criteria , typename Fsingle , typename Fdouble , typename Fcomplex , typename Fzomplex , class... Inputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::call_backend </td>
          <td>(</td>
          <td class="paramtype">Fsingle &amp;&#160;</td>
          <td class="paramname"><em>sfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fdouble &amp;&#160;</td>
          <td class="paramname"><em>dfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fcomplex &amp;&#160;</td>
          <td class="paramname"><em>cfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fzomplex &amp;&#160;</td>
          <td class="paramname"><em>zfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Inputs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call one of the 4 possible functions according to the <b>criteria</b>. </p>
<p>The 4 inputs Xfunc correspond to BLAS naming conventions for single, double, complex and double-complex precision. The <b>criteria</b> is tested for each type using is_float() ... is_dcomplex() and the corresponding function is called with <b>args</b>. </p>

</div>
</div>
<a id="a0830dc4e08216100f6642e74fe261033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0830dc4e08216100f6642e74fe261033">&#9670;&nbsp;</a></span>call_backend2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename criteria , typename Fsingle , typename Fdouble , class... Inputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::call_backend2 </td>
          <td>(</td>
          <td class="paramtype">Fsingle &amp;&#160;</td>
          <td class="paramname"><em>sfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fdouble &amp;&#160;</td>
          <td class="paramname"><em>dfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Inputs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call one of the 2 possible functions according to the <b>criteria</b>. </p>
<p>Call the first or second function depending whether <b>criteria</b> is <b>float</b> or <b>double</b>. </p>

</div>
</div>
<a id="ae7db1d64d1b8f41150879e541ba0444b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7db1d64d1b8f41150879e541ba0444b">&#9670;&nbsp;</a></span>call_backend6()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool flag, typename criteria , typename Fsingle , typename Fdouble , typename Fcomplex , typename Fzomplex , typename Frcomplex , typename Frzomplex , class... Inputs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::call_backend6 </td>
          <td>(</td>
          <td class="paramtype">Fsingle &amp;&#160;</td>
          <td class="paramname"><em>sfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fdouble &amp;&#160;</td>
          <td class="paramname"><em>dfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fcomplex &amp;&#160;</td>
          <td class="paramname"><em>cfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fzomplex &amp;&#160;</td>
          <td class="paramname"><em>zfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Frcomplex &amp;&#160;</td>
          <td class="paramname"><em>crfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Frzomplex &amp;&#160;</td>
          <td class="paramname"><em>zrfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Inputs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call one of the 6 possible functions according to the <b>criteria</b>. </p>
<p>Generates two call to the backend corresponding to the symmetric vs. conjugate-symmetric (Hermitian) cases.</p><ul>
<li><b>flags</b> is true, then use the first 4 functions</li>
<li><b>flags</b> is false, then use the first 2 and the last 2 functions </li>
</ul>

</div>
</div>
<a id="a512ac4265c71ac5a1da06f901d1ad077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512ac4265c71ac5a1da06f901d1ad077">&#9670;&nbsp;</a></span>dot_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool conjugate, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T hala::dot_array </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>y</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>incy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af6faa5a4486553a0c0b151443265fbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6faa5a4486553a0c0b151443265fbd3">&#9670;&nbsp;</a></span>geqr_query_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeA &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;int, int&gt; hala::geqr_query_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>query_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeA &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d2d5578205f2f1548f4a5921daadb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2d5578205f2f1548f4a5921daadb1d">&#9670;&nbsp;</a></span>lapack_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::lapack_check </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b4a541134b7e2d59b1f1929f22ff2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4a541134b7e2d59b1f1929f22ff2bc">&#9670;&nbsp;</a></span>dense_convert_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::dense_convert_array </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>pntr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>indx</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>result</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts spares matrix to dense format, used raw-arrays. </p>
<p>Used by <a class="el" href="namespacehala.html#a5c6054d9977f5b91df6fcfe7e9d55f9a" title="Converts spares matrix to dense format, useful for testing and debugging. ">hala::dense_convert()</a>. </p>

</div>
</div>
<a id="a5c6054d9977f5b91df6fcfe7e9d55f9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6054d9977f5b91df6fcfe7e9d55f9a">&#9670;&nbsp;</a></span>dense_convert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hala::dense_convert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeP const &amp;&#160;</td>
          <td class="paramname"><em>pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeI const &amp;&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeV const &amp;&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts spares matrix to dense format, useful for testing and debugging. </p>
<p>Takes a sparse matrix defined by <b>pntr</b>, <b>indx</b>, and <b>vals</b> with given <b>num_rows</b> and <b>num_cols</b> and converts it to a vector containing the dense matrix. The result is the same type as <b>VectorLikeV</b>. </p>

</div>
</div>
<a id="a59cfc470b7eb47eec706f6b7c958e8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cfc470b7eb47eec706f6b7c958e8b1">&#9670;&nbsp;</a></span>sparse_gemv_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , char trans&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::sparse_gemv_array </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>pntr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>indx</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>x</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs sparse matrix-vector multiply using raw-arrays. </p>
<p>Uses raw-array interface assuming the arrays have the right dimensions. </p>

</div>
</div>
<a id="a0c0517f0f70150c395e903fc99d8b365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0517f0f70150c395e903fc99d8b365">&#9670;&nbsp;</a></span>sparse_gemm_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::sparse_gemm_array </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>transa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>transb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>pntr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>indx</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>B</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>C</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ldc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs sparse matrix-matrix multiply using raw-arrays. </p>
<p>Uses raw-array interface assuming the arrays have the right dimensions. </p>

</div>
</div>
<a id="adc19093fe089f6e0a7941a06fa9607b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc19093fe089f6e0a7941a06fa9607b6">&#9670;&nbsp;</a></span>split_pattern_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool set_pntrs, typename T  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::split_pattern_array </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>pntr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>indx</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>diag</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>upper_pntr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>upper_indx</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lower_pntr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lower_indx</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the patter into upper and lower portions using raw-arrays. </p>
<p>Uses raw-array interface assuming the arrays have the right dimensions. </p>

</div>
</div>
<a id="a3e58bea37d6c3aaaec2745b2b1b7bcec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e58bea37d6c3aaaec2745b2b1b7bcec">&#9670;&nbsp;</a></span>factorize_ilu_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::factorize_ilu_array </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>pntr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>indx</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>diag</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ilu</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs ILU factorization using raw-arrays. </p>
<p>Uses raw-array interface assuming the arrays have the right dimensions. </p>

</div>
</div>
<a id="aae7ee374f6d403d167bd5a9b415b7b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7ee374f6d403d167bd5a9b415b7b6f">&#9670;&nbsp;</a></span>apply_ilu_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::apply_ilu_array </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>pntr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>indx</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>diag</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>ilu</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies ILU factorization on a vector. </p>
<p>Uses raw-array interface assuming the arrays have the right dimensions. </p>

</div>
</div>
<a id="a79058435b69a018c2f46951ea133cbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79058435b69a018c2f46951ea133cbfd">&#9670;&nbsp;</a></span>sparse_trsv_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;char diag, typename T , typename Tindex  = int&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::sparse_trsv_array </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tindex&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tindex const&#160;</td>
          <td class="paramname"><em>pntr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tindex const&#160;</td>
          <td class="paramname"><em>indx</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>b</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a sparse triangular system of equations, raw-array version. </p>
<p>Uses raw-array interface assuming the arrays have the right dimensions. </p>

</div>
</div>
<a id="a5f73e200007af75788e806bf73ed7115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f73e200007af75788e806bf73ed7115">&#9670;&nbsp;</a></span>check_cuda()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::check_cuda </td>
          <td>(</td>
          <td class="paramtype">cudaError_t&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>function_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if cuda returns cudaSuccess; if not, throw <b>runtime_error</b> and append <b>message</b> to the cuda error info. </p>
<p>Overloads are provided for cuBlas and cuSparse status messages. </p>

</div>
</div>
<a id="a5a0f77f3fb8ed52640f603cc1d52cb60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0f77f3fb8ed52640f603cc1d52cb60">&#9670;&nbsp;</a></span>trans_to_gpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rocblas_operation hala::trans_to_gpu </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>trans</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts characters N, T, C (upper or lower) to the correct cublasOperation_t. </p>
<p>Converts characters N, T, C (upper or lower) to the correct rocblas_operation. </p>

</div>
</div>
<a id="a707d6276ce6249e6e9e2c037de99f0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707d6276ce6249e6e9e2c037de99f0fb">&#9670;&nbsp;</a></span>side_to_gpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rocblas_side hala::side_to_gpu </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts characters L, R (upper or lower) to the correct cublasSideMode_t. </p>
<p>Converts characters L, R (upper or lower) to the correct rocblas_side. </p>

</div>
</div>
<a id="a81e2db7908b19d61ec45aac104a50258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e2db7908b19d61ec45aac104a50258">&#9670;&nbsp;</a></span>uplo_to_gpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rocblas_fill hala::uplo_to_gpu </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts characters U, L (upper or lower) to the correct cublasFillMode_t. </p>
<p>Converts characters U, L (upper or lower) to the correct rocblas_fill. </p>

</div>
</div>
<a id="a4f9d16244639678a33eacc1d2cee1035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9d16244639678a33eacc1d2cee1035">&#9670;&nbsp;</a></span>diag_to_gpu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">rocblas_diagonal hala::diag_to_gpu </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts characters U, N (upper or lower) to the correct cublasDiagType_t. </p>
<p>Converts characters U, N (upper or lower) to the correct rocblas_diagonal. </p>

</div>
</div>
<a id="a8ef9fc84ecbd6ccdb77c45a783da0f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef9fc84ecbd6ccdb77c45a783da0f2c">&#9670;&nbsp;</a></span>make_cuda_mat_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto hala::make_cuda_mat_description </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates sparse matrix description. </p>
<p>Note that this is internal API and doesn't come with assert() checks, the uplo and diag can be other letters in which case they will not be set.</p><ul>
<li><b>type</b> is 'G' for general or anything else for triangular, e.g., 'T'</li>
<li><b>uplo</b> sets upper or lower fill mode, but can be something else to skip the mode, e.g., 'S'</li>
<li><b>diag</b> sets unit/non-unit diagonal, but can be something else to skip the mode, e.g., 'S' </li>
</ul>

</div>
</div>
<a id="a9719886301e1e15b7ea4c46c03ea270f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9719886301e1e15b7ea4c46c03ea270f">&#9670;&nbsp;</a></span>make_sparse_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hala::make_sparse_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_nz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeP const &amp;&#160;</td>
          <td class="paramname"><em>pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeI const &amp;&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeV const &amp;&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory method, creates a <a class="el" href="structhala_1_1gpu__sparse__matrix.html" title="Wrapper around sparse matrix data associated with the GPU device. ">hala::gpu_sparse_matrix</a> wrapper with the given matrix parameters. </p>
<p>This overload can be used with raw-array data. </p>

</div>
</div>
<a id="ae19ec0922c8fb1fdbd02a42e7f2582e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae19ec0922c8fb1fdbd02a42e7f2582e1">&#9670;&nbsp;</a></span>make_sparse_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hala::make_sparse_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhala_1_1gpu__engine.html">gpu_engine</a> const &amp;&#160;</td>
          <td class="paramname"><em>engine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeP const &amp;&#160;</td>
          <td class="paramname"><em>pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeI const &amp;&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeV const &amp;&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory method, creates a <a class="el" href="structhala_1_1gpu__sparse__matrix.html" title="Wrapper around sparse matrix data associated with the GPU device. ">hala::gpu_sparse_matrix</a> wrapper where most of the dimensions are inferred from the vector sizes. </p>
<p>This overload cannot be used with raw-arrays. </p>

</div>
</div>
<a id="a8e51ef421af4ac803f2970ed095b16f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e51ef421af4ac803f2970ed095b16f6">&#9670;&nbsp;</a></span>check_rocm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void hala::check_rocm </td>
          <td>(</td>
          <td class="paramtype">rocblas_status&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>function_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if cuda returns cudaSuccess; if not, throw <b>runtime_error</b> and append <b>message</b> to the cuda error info. </p>
<p>Overloads are provided for cuBlas and cuSparse status messages. </p>

</div>
</div>
<a id="a1a80b31f00e6b57b9fdcfee9e2db0014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a80b31f00e6b57b9fdcfee9e2db0014">&#9670;&nbsp;</a></span>hermitian_trans()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool conjugate, typename scalar_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">rocblas_operation hala::hermitian_trans </td>
          <td>(</td>
          <td class="paramtype">char &amp;&#160;</td>
          <td class="paramname"><em>trans</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts trans character to one compatible with rocsparse hermitian operations. </p>
<p>Several Hermitian operations, e.g., <a class="el" href="group__HALABLAS3.html#ga85ff3bcfb9b27d8e49526edce35051a2" title="Wrapper to BLAS symmetric or Hermitian rank-k matrix update xsyrk()/xherk(). ">hala::syrk()</a>, use a trans character to indicate a side of an operation and not necessarily the conjugate vs. non-conjugate component of the transpose. But this hinters writing generic code, since different character has to be passed in based on the scalar-type. This method corrects for that. </p>

</div>
</div>
<a id="a69018eee242b66f8b7fbb1fa63941874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69018eee242b66f8b7fbb1fa63941874">&#9670;&nbsp;</a></span>make_rocsparse_general_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhala_1_1rocm__struct__description.html">rocm_struct_description</a>&lt;rocsparse_mat_descr&gt; hala::make_rocsparse_general_description </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em> = <code>'N'</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method for a general matrix description. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diag</td><td>specifies whether the matrix is uint or non-unit diagonal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae23fb8e7c8a4a7aa618ab8317a4da3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23fb8e7c8a4a7aa618ab8317a4da3a8">&#9670;&nbsp;</a></span>make_rocsparse_triangular_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhala_1_1rocm__struct__description.html">rocm_struct_description</a>&lt;rocsparse_mat_descr&gt; hala::make_rocsparse_triangular_description </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method for a triangular matrix description. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uplo</td><td>specifies whether the matrix has upper or lower fill </td></tr>
    <tr><td class="paramname">diag</td><td>specifies whether the matrix is uint or non-unit diagonal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdbb85d1036a69e9428cb55e311e54b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbb85d1036a69e9428cb55e311e54b1">&#9670;&nbsp;</a></span>get_vec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vec&amp; hala::get_vec </td>
          <td>(</td>
          <td class="paramtype">vec &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad431721db0a8ddfb1960177fca63f929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad431721db0a8ddfb1960177fca63f929">&#9670;&nbsp;</a></span>get_vec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vec&amp; hala::get_vec </td>
          <td>(</td>
          <td class="paramtype">std::reference_wrapper&lt; vec &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af93347509b5485cfbfd6926bd6749782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af93347509b5485cfbfd6926bd6749782">&#9670;&nbsp;</a></span>check_engines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ev1 , class ev2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool hala::check_engines </td>
          <td>(</td>
          <td class="paramtype">ev1 const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev2 const &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49e4063a492511f9d6ee648c05a818a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e4063a492511f9d6ee648c05a818a4">&#9670;&nbsp;</a></span>solve_cg_core()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename hscalar , typename hvectorx , typename hvectorb , typename htypea , typename htypeb , typename htypec , typename htyped , typename htypef , typename htypeg , typename htypeh , typename htypei , typename htypej , typename htypek , typename htypel , typename htypem , typename htypen &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int hala::solve_cg_core </td>
          <td>(</td>
          <td class="paramtype">htypea&#160;</td>
          <td class="paramname"><em>apply_preconditioner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htypeb&#160;</td>
          <td class="paramname"><em>apply_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htypen&#160;</td>
          <td class="paramname"><em>apply_operator_internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hvectorx const &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hvectorb &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htypem&#160;</td>
          <td class="paramname"><em>scalar_make</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htypec&#160;</td>
          <td class="paramname"><em>scalar_division</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htyped&#160;</td>
          <td class="paramname"><em>scalar_move</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htypef&#160;</td>
          <td class="paramname"><em>vector_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htypeg&#160;</td>
          <td class="paramname"><em>vector_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htypeh&#160;</td>
          <td class="paramname"><em>vector_sub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htypei&#160;</td>
          <td class="paramname"><em>vector_sadd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htypej&#160;</td>
          <td class="paramname"><em>vector_ssub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htypek&#160;</td>
          <td class="paramname"><em>vector_dot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htypel&#160;</td>
          <td class="paramname"><em>check_converged</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bf3133c79ea91bccde8071a2a1998ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf3133c79ea91bccde8071a2a1998ce">&#9670;&nbsp;</a></span>krylov_project()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLike , class VectorLikeResult &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::krylov_project </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhala_1_1cpu__engine.html">cpu_engine</a> const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLike &amp;&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLike const &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeResult &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8318e46d881be063f0410a19e96f9bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8318e46d881be063f0410a19e96f9bfe">&#9670;&nbsp;</a></span>krylov_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeX , class VectorLikeW , class VectorLikeCoeff &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::krylov_combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhala_1_1cpu__engine.html">cpu_engine</a> const &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeW &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeCoeff const &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeX &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e650c4e0fd090f77d7a5f34b75724a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e650c4e0fd090f77d7a5f34b75724a4">&#9670;&nbsp;</a></span>get_default_regtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__HALAVEX.html#ga5cf9392711eaa1cd0f3ba628585d4bee">regtype</a> hala::get_default_regtype </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="navelem"><a class="el" href="namespacehala.html">hala</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div> -->
</body>
</html>
