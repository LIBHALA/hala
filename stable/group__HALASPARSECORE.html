<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HALA: Handy Accelerated Linear Algebra v1.0: Core Sparse Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hala.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"/>
                </a> 1.8.13
    </div>
   <div id="projectname">HALA: Handy Accelerated Linear Algebra v1.0
   <!--         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 -->
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__HALASPARSECORE.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Core Sparse Operations<div class="ingroups"><a class="el" href="group__HALASPARSE.html">HALA Sparse Matrix Templates</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Core Sparse Operations:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__HALASPARSECORE.png" border="0" alt="" usemap="#group____HALASPARSECORE"/>
<map name="group____HALASPARSECORE" id="group____HALASPARSECORE">
<area shape="rect" id="node1" href="group__HALASPARSE.html" title="HALA Sparse Matrix\l Templates" alt="" coords="5,5,148,47"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga246bb6436c73aec65eb6a6a268238572"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeD &gt; </td></tr>
<tr class="memitem:ga246bb6436c73aec65eb6a6a268238572"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#ga246bb6436c73aec65eb6a6a268238572">hala::get_diagonal_index</a> (VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeD &amp;diag)</td></tr>
<tr class="memdesc:ga246bb6436c73aec65eb6a6a268238572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills <b>diag</b> with the indexes in <b>indx</b> of the diagonal entries of the matrix.  <a href="group__HALASPARSECORE.html#ga246bb6436c73aec65eb6a6a268238572">More...</a><br /></td></tr>
<tr class="separator:ga246bb6436c73aec65eb6a6a268238572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa61b115510b4207b10484f11a99da681"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeD , class VectorLikePU , class VectorLikeIU , class VectorLikePL , class VectorLikeIL &gt; </td></tr>
<tr class="memitem:gaa61b115510b4207b10484f11a99da681"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#gaa61b115510b4207b10484f11a99da681">hala::split_pattern</a> (VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeD const &amp;diag, VectorLikePU &amp;upper_pntr, VectorLikeIU &amp;upper_indx, VectorLikePL &amp;lower_pntr, VectorLikeIL &amp;lower_indx)</td></tr>
<tr class="memdesc:gaa61b115510b4207b10484f11a99da681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the patter into upper and lower portions, i.e., make two sparse matrices.  <a href="group__HALASPARSECORE.html#gaa61b115510b4207b10484f11a99da681">More...</a><br /></td></tr>
<tr class="separator:gaa61b115510b4207b10484f11a99da681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade2b1775c44a1d08d4c634b89141ac87"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeV , class VectorLikePU , class VectorLikePL , class VectorLikeVU , class VectorLikeVL &gt; </td></tr>
<tr class="memitem:gade2b1775c44a1d08d4c634b89141ac87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#gade2b1775c44a1d08d4c634b89141ac87">hala::split_values</a> (char uplo, char diag, VectorLikeP const &amp;pntr, VectorLikeV const &amp;vals, VectorLikePU const &amp;upper_pntr, VectorLikePL const &amp;lower_pntr, VectorLikeVU &amp;upper_vals, VectorLikeVL &amp;lower_vals)</td></tr>
<tr class="memdesc:gade2b1775c44a1d08d4c634b89141ac87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the values assuming the pattern has been split already.  <a href="group__HALASPARSECORE.html#gade2b1775c44a1d08d4c634b89141ac87">More...</a><br /></td></tr>
<tr class="separator:gade2b1775c44a1d08d4c634b89141ac87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf22a8e9b2aed8341f4fecabfa73117"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikePU , class VectorLikeIU , class VectorLikeVU , class VectorLikePL , class VectorLikeIL , class VectorLikeVL &gt; </td></tr>
<tr class="memitem:gaadf22a8e9b2aed8341f4fecabfa73117"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#gaadf22a8e9b2aed8341f4fecabfa73117">hala::split_matrix</a> (char uplo, char diag, VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, VectorLikePU &amp;upper_pntr, VectorLikeIU &amp;upper_indx, VectorLikeVU &amp;upper_vals, VectorLikePL &amp;lower_pntr, VectorLikeIL &amp;lower_indx, VectorLikeVL &amp;lower_vals)</td></tr>
<tr class="memdesc:gaadf22a8e9b2aed8341f4fecabfa73117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split both the pattern and values into two matrices, see <b><a class="el" href="group__HALASPARSECORE.html#gade2b1775c44a1d08d4c634b89141ac87" title="Split the values assuming the pattern has been split already. ">hala::split_values()</a></b>.  <a href="group__HALASPARSECORE.html#gaadf22a8e9b2aed8341f4fecabfa73117">More...</a><br /></td></tr>
<tr class="separator:gaadf22a8e9b2aed8341f4fecabfa73117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9c617c6608d9cf8c765ae5cfdc9567"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikeD , class VectorLikeILU &gt; </td></tr>
<tr class="memitem:gaec9c617c6608d9cf8c765ae5cfdc9567"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#gaec9c617c6608d9cf8c765ae5cfdc9567">hala::factorize_ilu</a> (VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, VectorLikeD const &amp;diag, VectorLikeILU &amp;ilu)</td></tr>
<tr class="memdesc:gaec9c617c6608d9cf8c765ae5cfdc9567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the incomplete Lower-Upper factorization of a sparse matrix.  <a href="group__HALASPARSECORE.html#gaec9c617c6608d9cf8c765ae5cfdc9567">More...</a><br /></td></tr>
<tr class="separator:gaec9c617c6608d9cf8c765ae5cfdc9567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6dfccd47336e4ff8669f1bcdd77d51f"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikeD , class VectorLikeILU &gt; </td></tr>
<tr class="memitem:gaf6dfccd47336e4ff8669f1bcdd77d51f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#gaf6dfccd47336e4ff8669f1bcdd77d51f">hala::factorize_ilu</a> (VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeV const &amp;vals, VectorLikeD &amp;diag, VectorLikeILU &amp;ilu)</td></tr>
<tr class="memdesc:gaf6dfccd47336e4ff8669f1bcdd77d51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that will call <a class="el" href="group__HALASPARSECORE.html#ga246bb6436c73aec65eb6a6a268238572" title="Fills diag with the indexes in indx of the diagonal entries of the matrix. ">hala::get_diagonal_index()</a> if the <b>diag</b> has incorrect size.  <a href="group__HALASPARSECORE.html#gaf6dfccd47336e4ff8669f1bcdd77d51f">More...</a><br /></td></tr>
<tr class="separator:gaf6dfccd47336e4ff8669f1bcdd77d51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72909210b2ef6cac3bf8223aaa9190ce"><td class="memTemplParams" colspan="2">template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeD , class VectorLikeILU , class VectorLikeX &gt; </td></tr>
<tr class="memitem:ga72909210b2ef6cac3bf8223aaa9190ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#ga72909210b2ef6cac3bf8223aaa9190ce">hala::apply_ilu</a> (VectorLikeP const &amp;pntr, VectorLikeI const &amp;indx, VectorLikeD &amp;diag, VectorLikeILU const &amp;ilu, VectorLikeX &amp;&amp;x)</td></tr>
<tr class="memdesc:ga72909210b2ef6cac3bf8223aaa9190ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that will call <a class="el" href="group__HALASPARSECORE.html#ga246bb6436c73aec65eb6a6a268238572" title="Fills diag with the indexes in indx of the diagonal entries of the matrix. ">hala::get_diagonal_index()</a> if the <b>diag</b> has incorrect size.  <a href="group__HALASPARSECORE.html#ga72909210b2ef6cac3bf8223aaa9190ce">More...</a><br /></td></tr>
<tr class="separator:ga72909210b2ef6cac3bf8223aaa9190ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d4940ff254848469afbed96b811cabb"><td class="memTemplParams" colspan="2">template&lt;typename Tindex , typename T &gt; </td></tr>
<tr class="memitem:ga7d4940ff254848469afbed96b811cabb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALASPARSECORE.html#ga7d4940ff254848469afbed96b811cabb">hala::split_values_array</a> (Tindex num_rows, char uplo, char diag, Tindex const pntr[], T const vals[], Tindex const upper_pntr[], Tindex const lower_pntr[], T upper_vals[], T lower_vals[])</td></tr>
<tr class="memdesc:ga7d4940ff254848469afbed96b811cabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the values assuming the pattern has been split already, uses raw-arrays.  <a href="group__HALASPARSECORE.html#ga7d4940ff254848469afbed96b811cabb">More...</a><br /></td></tr>
<tr class="separator:ga7d4940ff254848469afbed96b811cabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>Core Operations</dt><dd>The core linear sparse operations include the matrix vector product, pattern partition and factorization. </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga246bb6436c73aec65eb6a6a268238572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga246bb6436c73aec65eb6a6a268238572">&#9670;&nbsp;</a></span>get_diagonal_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::get_diagonal_index </td>
          <td>(</td>
          <td class="paramtype">VectorLikeP const &amp;&#160;</td>
          <td class="paramname"><em>pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeI const &amp;&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeD &amp;&#160;</td>
          <td class="paramname"><em>diag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills <b>diag</b> with the indexes in <b>indx</b> of the diagonal entries of the matrix. </p>
<p>On exit, indx[diag[i]] = i, and pntr[i] &lt;= diag[i] &lt; pntr[i+1].</p><ul>
<li>This assumes that the diagonal entry is included in the pattern (even if it is numerically zero) </li>
</ul>

</div>
</div>
<a id="gaa61b115510b4207b10484f11a99da681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa61b115510b4207b10484f11a99da681">&#9670;&nbsp;</a></span>split_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeD , class VectorLikePU , class VectorLikeIU , class VectorLikePL , class VectorLikeIL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::split_pattern </td>
          <td>(</td>
          <td class="paramtype">VectorLikeP const &amp;&#160;</td>
          <td class="paramname"><em>pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeI const &amp;&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeD const &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikePU &amp;&#160;</td>
          <td class="paramname"><em>upper_pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeIU &amp;&#160;</td>
          <td class="paramname"><em>upper_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikePL &amp;&#160;</td>
          <td class="paramname"><em>lower_pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeIL &amp;&#160;</td>
          <td class="paramname"><em>lower_indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the patter into upper and lower portions, i.e., make two sparse matrices. </p>
<p>Split the pattern defined by <b>pntr</b>, <b>indx</b> with pre-computed diagonal <b>diag</b>, effectively makes two sparse matrices. The diagonal entries will be included in both patterns. </p>

</div>
</div>
<a id="gade2b1775c44a1d08d4c634b89141ac87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade2b1775c44a1d08d4c634b89141ac87">&#9670;&nbsp;</a></span>split_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeP , class VectorLikeV , class VectorLikePU , class VectorLikePL , class VectorLikeVU , class VectorLikeVL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::split_values </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeP const &amp;&#160;</td>
          <td class="paramname"><em>pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeV const &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikePU const &amp;&#160;</td>
          <td class="paramname"><em>upper_pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikePL const &amp;&#160;</td>
          <td class="paramname"><em>lower_pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeVU &amp;&#160;</td>
          <td class="paramname"><em>upper_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeVL &amp;&#160;</td>
          <td class="paramname"><em>lower_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the values assuming the pattern has been split already. </p>
<p>Split the values in <b>vals</b> into the lower and upper portions of the patterns defined by <b>upper_pntr</b> and <b>lower_pntr</b>. Assumes the order of the indexes matches the order used in <a class="el" href="group__HALASPARSECORE.html#gaa61b115510b4207b10484f11a99da681" title="Split the patter into upper and lower portions, i.e., make two sparse matrices. ">hala::split_pattern()</a>.</p><ul>
<li><b>uplo</b> is lower or upper case 'U' or 'L' indicates which section should get the diagonal entry</li>
<li><b>diag</b> is 'U' or 'N' indicates whether the other entry should be set to 1 (Unit) or 0 (non-Unit) </li>
</ul>

</div>
</div>
<a id="gaadf22a8e9b2aed8341f4fecabfa73117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadf22a8e9b2aed8341f4fecabfa73117">&#9670;&nbsp;</a></span>split_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikePU , class VectorLikeIU , class VectorLikeVU , class VectorLikePL , class VectorLikeIL , class VectorLikeVL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::split_matrix </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeP const &amp;&#160;</td>
          <td class="paramname"><em>pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeI const &amp;&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeV const &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikePU &amp;&#160;</td>
          <td class="paramname"><em>upper_pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeIU &amp;&#160;</td>
          <td class="paramname"><em>upper_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeVU &amp;&#160;</td>
          <td class="paramname"><em>upper_vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikePL &amp;&#160;</td>
          <td class="paramname"><em>lower_pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeIL &amp;&#160;</td>
          <td class="paramname"><em>lower_indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeVL &amp;&#160;</td>
          <td class="paramname"><em>lower_vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split both the pattern and values into two matrices, see <b><a class="el" href="group__HALASPARSECORE.html#gade2b1775c44a1d08d4c634b89141ac87" title="Split the values assuming the pattern has been split already. ">hala::split_values()</a></b>. </p>
<p>Converts a single matrix into two matrices containing the upper and lower parts. The call effectively combines a call to <a class="el" href="group__HALASPARSECORE.html#gaa61b115510b4207b10484f11a99da681" title="Split the patter into upper and lower portions, i.e., make two sparse matrices. ">hala::split_pattern()</a> followed by <a class="el" href="group__HALASPARSECORE.html#gade2b1775c44a1d08d4c634b89141ac87" title="Split the values assuming the pattern has been split already. ">hala::split_values()</a>. </p>

</div>
</div>
<a id="gaec9c617c6608d9cf8c765ae5cfdc9567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec9c617c6608d9cf8c765ae5cfdc9567">&#9670;&nbsp;</a></span>factorize_ilu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikeD , class VectorLikeILU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::factorize_ilu </td>
          <td>(</td>
          <td class="paramtype">VectorLikeP const &amp;&#160;</td>
          <td class="paramname"><em>pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeI const &amp;&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeV const &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeD const &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeILU &amp;&#160;</td>
          <td class="paramname"><em>ilu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the incomplete Lower-Upper factorization of a sparse matrix. </p>
<p>Assuming that the matrix is a diagonally dominant and non-singular, this will compute the incomplete factorization. </p>

</div>
</div>
<a id="gaf6dfccd47336e4ff8669f1bcdd77d51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6dfccd47336e4ff8669f1bcdd77d51f">&#9670;&nbsp;</a></span>factorize_ilu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeV , class VectorLikeD , class VectorLikeILU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::factorize_ilu </td>
          <td>(</td>
          <td class="paramtype">VectorLikeP const &amp;&#160;</td>
          <td class="paramname"><em>pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeI const &amp;&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeV const &amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeD &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeILU &amp;&#160;</td>
          <td class="paramname"><em>ilu</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that will call <a class="el" href="group__HALASPARSECORE.html#ga246bb6436c73aec65eb6a6a268238572" title="Fills diag with the indexes in indx of the diagonal entries of the matrix. ">hala::get_diagonal_index()</a> if the <b>diag</b> has incorrect size. </p>
<p>If the <b>diag</b> is not a const vector and the values have not been computed already, then call <a class="el" href="group__HALASPARSECORE.html#ga246bb6436c73aec65eb6a6a268238572" title="Fills diag with the indexes in indx of the diagonal entries of the matrix. ">hala::get_diagonal_index()</a> and then factorize as if using a const vector. The test whether <b>diag</b> has been computed is done by checking the size. </p>

</div>
</div>
<a id="ga72909210b2ef6cac3bf8223aaa9190ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72909210b2ef6cac3bf8223aaa9190ce">&#9670;&nbsp;</a></span>apply_ilu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLikeP , class VectorLikeI , class VectorLikeD , class VectorLikeILU , class VectorLikeX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::apply_ilu </td>
          <td>(</td>
          <td class="paramtype">VectorLikeP const &amp;&#160;</td>
          <td class="paramname"><em>pntr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeI const &amp;&#160;</td>
          <td class="paramname"><em>indx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeD &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeILU const &amp;&#160;</td>
          <td class="paramname"><em>ilu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLikeX &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload that will call <a class="el" href="group__HALASPARSECORE.html#ga246bb6436c73aec65eb6a6a268238572" title="Fills diag with the indexes in indx of the diagonal entries of the matrix. ">hala::get_diagonal_index()</a> if the <b>diag</b> has incorrect size. </p>
<p>If the <b>diag</b> is not a const vector and the values have not been computed already, then call <a class="el" href="group__HALASPARSECORE.html#ga246bb6436c73aec65eb6a6a268238572" title="Fills diag with the indexes in indx of the diagonal entries of the matrix. ">hala::get_diagonal_index()</a> and then factorize as if using a const vector. The test whether <b>diag</b> has been computed is done by checking the size. </p>

</div>
</div>
<a id="ga7d4940ff254848469afbed96b811cabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d4940ff254848469afbed96b811cabb">&#9670;&nbsp;</a></span>split_values_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tindex , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::split_values_array </td>
          <td>(</td>
          <td class="paramtype">Tindex&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>uplo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tindex const&#160;</td>
          <td class="paramname"><em>pntr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const&#160;</td>
          <td class="paramname"><em>vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tindex const&#160;</td>
          <td class="paramname"><em>upper_pntr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tindex const&#160;</td>
          <td class="paramname"><em>lower_pntr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>upper_vals</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>lower_vals</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the values assuming the pattern has been split already, uses raw-arrays. </p>
<p>Uses raw-array interface assuming the arrays have the right dimensions. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div> -->
</body>
</html>
