<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HALA: Handy Accelerated Linear Algebra v1.0: HALA Support for Custom Vector Class</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hala.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"/>
                </a> 1.8.13
    </div>
   <div id="projectname">HALA: Handy Accelerated Linear Algebra v1.0
   <!--         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 -->
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__HALACUSTOM.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">HALA Support for Custom Vector Class</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for HALA Support for Custom Vector Class:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__HALACUSTOM.png" border="0" alt="" usemap="#group____HALACUSTOM"/>
<map name="group____HALACUSTOM" id="group____HALACUSTOM">
<area shape="rect" id="node2" href="group__HALAARRAY.html" title="Array Wrapper" alt="" coords="258,5,365,32"/>
<area shape="rect" id="node3" href="group__HALACTYPES.html" title="Custom Type Definitions" alt="" coords="228,56,395,83"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__HALACTYPES"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALACTYPES.html">Custom Type Definitions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__HALAARRAY"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALAARRAY.html">Array Wrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__type.html">hala::define_type&lt; VectorLike &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template that defined the type of the vector variable.  <a href="structhala_1_1define__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__size.html">hala::define_size&lt; VectorLike &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template that defines the size of the vector.  <a href="structhala_1_1define__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__resize.html">hala::define_resize&lt; VectorLike &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template that defines how to resize of the vector.  <a href="structhala_1_1define__resize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1define__data.html">hala::define_data&lt; VectorLike &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct with a single function that returns a raw pointer to the internal contiguous data stored in the vector, uses <b></b>.<a class="el" href="structhala_1_1define__data.html#a8a7fd5a50422be19c88638aa37b953dc" title="Returns a raw pointer to the internal data of the VectorLike. ">data()</a> method.  <a href="structhala_1_1define__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab93c1d2ec9a0e8222f141d16c56a1b58"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:gab93c1d2ec9a0e8222f141d16c56a1b58"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACUSTOM.html#gab93c1d2ec9a0e8222f141d16c56a1b58">hala::get_scalar_type</a> = typename <a class="el" href="structhala_1_1define__type.html">define_type</a>&lt; std::remove_reference_t&lt; VectorLike &gt; &gt;::value_type</td></tr>
<tr class="memdesc:gab93c1d2ec9a0e8222f141d16c56a1b58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to the scalar type of a vector-like class.  <a href="group__HALACUSTOM.html#gab93c1d2ec9a0e8222f141d16c56a1b58">More...</a><br /></td></tr>
<tr class="separator:gab93c1d2ec9a0e8222f141d16c56a1b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb090a328015649aed8ed8bb9b5e4980"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:gaeb090a328015649aed8ed8bb9b5e4980"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACUSTOM.html#gaeb090a328015649aed8ed8bb9b5e4980">hala::get_standard_type</a> = typename <a class="el" href="structhala_1_1define__standard__type.html">define_standard_type</a>&lt; typename <a class="el" href="structhala_1_1define__type.html">define_type</a>&lt; VectorLike &gt;::value_type &gt;::value_type</td></tr>
<tr class="memdesc:gaeb090a328015649aed8ed8bb9b5e4980"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to the standard equivalent for the scalar type of a vector-like class.  <a href="group__HALACUSTOM.html#gaeb090a328015649aed8ed8bb9b5e4980">More...</a><br /></td></tr>
<tr class="separator:gaeb090a328015649aed8ed8bb9b5e4980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78609b70f45312e08e520b6ed736ff40"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:ga78609b70f45312e08e520b6ed736ff40"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACUSTOM.html#ga78609b70f45312e08e520b6ed736ff40">hala::get_precision_type</a> = typename <a class="el" href="structhala_1_1define__standard__precision.html">define_standard_precision</a>&lt; typename <a class="el" href="structhala_1_1define__type.html">define_type</a>&lt; VectorLike &gt;::value_type &gt;::value_type</td></tr>
<tr class="memdesc:ga78609b70f45312e08e520b6ed736ff40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to the base precision type of a vector, e.g., <b>float</b> and <b>std::complex&lt;float&gt;</b> map to float.  <a href="group__HALACUSTOM.html#ga78609b70f45312e08e520b6ed736ff40">More...</a><br /></td></tr>
<tr class="separator:ga78609b70f45312e08e520b6ed736ff40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacb23ab0a92ecead8007cf9aa8dc972db"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:gacb23ab0a92ecead8007cf9aa8dc972db"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACUSTOM.html#gacb23ab0a92ecead8007cf9aa8dc972db">hala::get_size</a> (VectorLike const &amp;x)</td></tr>
<tr class="memdesc:gacb23ab0a92ecead8007cf9aa8dc972db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of entries in the vector, if <b>VectorLike</b> does not have <b></b>.size() method, then the template must be specialized.  <a href="group__HALACUSTOM.html#gacb23ab0a92ecead8007cf9aa8dc972db">More...</a><br /></td></tr>
<tr class="separator:gacb23ab0a92ecead8007cf9aa8dc972db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga957f659d97426f04b2060bceb9d90fee"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:ga957f659d97426f04b2060bceb9d90fee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACUSTOM.html#ga957f659d97426f04b2060bceb9d90fee">hala::set_size</a> (size_t new_size, VectorLike &amp;x)</td></tr>
<tr class="memdesc:ga957f659d97426f04b2060bceb9d90fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set new size for the <b>VectorLike</b>, called only if <b>get_size(x)</b> is not sufficient and it uses <b></b>.resize() method.  <a href="group__HALACUSTOM.html#ga957f659d97426f04b2060bceb9d90fee">More...</a><br /></td></tr>
<tr class="separator:ga957f659d97426f04b2060bceb9d90fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeee2b3b81522284482c1196d20ed0635"><td class="memTemplParams" colspan="2">template&lt;class VectorLike &gt; </td></tr>
<tr class="memitem:gaeee2b3b81522284482c1196d20ed0635"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALACUSTOM.html#gaeee2b3b81522284482c1196d20ed0635">hala::get_data</a> (VectorLike &amp;x)</td></tr>
<tr class="memdesc:gaeee2b3b81522284482c1196d20ed0635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a raw pointer to the internal contiguous array stored in the <b>VectorLike</b>.  <a href="group__HALACUSTOM.html#gaeee2b3b81522284482c1196d20ed0635">More...</a><br /></td></tr>
<tr class="separator:gaeee2b3b81522284482c1196d20ed0635"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Several templates that can be fully or partially specialized to allow interoperability between HALA wrappers and a user defined vector class.</p><ul>
<li>HALA provides builtin support for std::vector, std::valarray containers as well as the included hala::cuda_vector and the variations of HALA raw-array wrappers.</li>
<li>Classes that define <b>value_type</b>, and have <b>size()</b> and <b>data()</b> methods similar to std::vector will be supported automatically.</li>
<li>If a vector has a <b>resize()</b> method, it will be used to adjust the size of the vector in calls where the vector is a <em>pure</em> output, for example <div class="fragment"><div class="line"><a class="code" href="group__HALABLAS1.html#ga199fd708ca4ff8b2c65b6ee47491b37d">hala::vcopy</a>(x, y);             <span class="comment">// y is purely an output</span></div><div class="line"><a class="code" href="group__HALABLAS2.html#ga925bf0c14261ed419bb931e85658f6eb">hala::gemv</a>(<span class="charliteral">&#39;N&#39;</span>, M, N, 1.0, A, x, 0.0, y); <span class="comment">// y is purely an output</span></div><div class="line"><a class="code" href="group__HALABLAS2.html#ga925bf0c14261ed419bb931e85658f6eb">hala::gemv</a>(<span class="charliteral">&#39;N&#39;</span>, M, N, 1.0, A, x, 1.0, y); <span class="comment">// y is used as both input and output</span></div></div><!-- fragment --></li>
<li>Vector classes that lack the three mandatory methods/types or the methods do something else (e.g., resize() returns a vector with entries in a different precision or value type has cv qualifiers), require specialization of several HALA templates.</li>
</ul>
<dl class="section user"><dt>Templates to Specialize</dt><dd></dd></dl>
<p>In order to call the method for the correct scalar type or precision, the struct <a class="el" href="structhala_1_1define__type.html" title="Template that defined the type of the vector variable. ">hala::define_type</a> must be specialized. The struct has a single type member <b>value_type</b> which should specify the content of the vector.</p>
<p>Sanity checks in debug mode and inferring the vector sizes is done with struct <a class="el" href="structhala_1_1define__size.html" title="Template that defines the size of the vector. ">hala::define_size</a>. The struct has a single member <a class="el" href="structhala_1_1define__size.html#abd3b8dd161eefb2c36bc3fbe80481fd3" title="Simple method that returns the size of the VectorLike, allows partial and full specializations for cu...">hala::define_size::size()</a> that accepts a const vector and returns the number of elements. The struct allows for either partial or full specialization; alternatively, the <a class="el" href="group__HALACUSTOM.html#gacb23ab0a92ecead8007cf9aa8dc972db" title="Returns the number of entries in the vector, if VectorLike does not have .size() method, then the template must be specialized. ">hala::get_size()</a> function can be fully specialized to avoid dealing with the struct.</p>
<p>In some cases, vectors serve as pure output parameters, e.g., computing \( y = \alpha A x + \beta y \) with <b>beta</b> equal to zero. In such scenario, if the size of the output vector size is insufficient, HALA will resize the vector to the minimum required. The resize algorithm can be done with either specialization of struct <a class="el" href="structhala_1_1define__resize.html" title="Template that defines how to resize of the vector. ">hala::define_resize</a> or function <a class="el" href="group__HALACUSTOM.html#ga957f659d97426f04b2060bceb9d90fee" title="Set new size for the VectorLike, called only if get_size(x) is not sufficient and it uses ...">hala::set_size()</a>. <b>Note:</b> that if the provided size is sufficient, resize will never be called.</p>
<p>The libraries wrapped by HALA accept raw pointers to data, which is accessed through the struct <a class="el" href="structhala_1_1define__data.html" title="Struct with a single function that returns a raw pointer to the internal contiguous data stored in th...">hala::define_data</a>, which contains a single method <a class="el" href="structhala_1_1define__data.html#a8a7fd5a50422be19c88638aa37b953dc" title="Returns a raw pointer to the internal data of the VectorLike. ">hala::define_data::data()</a>. The struct has to be specialized for any vector class that does not have a <b>data()</b> method. As an alternative, the <b><a class="el" href="group__HALACUSTOM.html#gaeee2b3b81522284482c1196d20ed0635" title="Returns a raw pointer to the internal contiguous array stored in the VectorLike. ">hala::get_data()</a></b> function can also be specialized.</p>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Specialization for a very simple vector class: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="hala_8hpp.html">hala.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// simple class that automatically allocates and deallocates data</span></div><div class="line"><span class="comment">// this is the most basic example, anything less will be just a raw pointer</span></div><div class="line"><span class="comment">// raw-pointers are handled with hala::wrap_array</span></div><div class="line"><span class="keyword">struct </span>FooVector{</div><div class="line">    FooVector(<span class="keywordtype">size_t</span> allocate_size) :</div><div class="line">        pointer(new double[allocate_size]), num_entries(allocate_size){}</div><div class="line">    ~FooVector(){ <span class="keyword">delete</span>[] pointer; }</div><div class="line">    <span class="keywordtype">double</span> *pointer;</div><div class="line">    <span class="keywordtype">size_t</span> num_entries;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacehala.html">hala</a>{</div><div class="line">    <span class="comment">// specializations needed to use FooVector in HALA templates</span></div><div class="line">    <span class="comment">// note that some specializations require both const and non-const FooVector</span></div><div class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>define_type&lt;FooVector&gt;{</div><div class="line">        <span class="keyword">using</span> value_type = double;</div><div class="line">    };</div><div class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>define_type&lt;FooVector const&gt;{</div><div class="line">        <span class="keyword">using</span> value_type = double;</div><div class="line">    };</div><div class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keywordtype">size_t</span> get_size&lt;FooVector&gt;(FooVector <span class="keyword">const</span> &amp;x)</div><div class="line">        { <span class="keywordflow">return</span> x.num_entries; }</div><div class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keywordtype">size_t</span> get_size&lt;FooVector const&gt;(FooVector <span class="keyword">const</span> &amp;x)</div><div class="line">        { <span class="keywordflow">return</span> x.num_entries; }</div><div class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">auto</span> get_data&lt;FooVector&gt;(FooVector &amp;x)</div><div class="line">        { <span class="keywordflow">return</span> x.pointer; }</div><div class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">auto</span> get_data&lt;FooVector const&gt;(FooVector <span class="keyword">const</span> &amp;x)</div><div class="line">        { <span class="keywordflow">return</span> x.pointer; }</div><div class="line">    <span class="comment">// optional specialization that changes the size</span></div><div class="line">    <span class="comment">// template&lt;&gt; void set_size&lt;FooVector&gt;(size_t new_size, FooVector &amp;x){}</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="example__gauss__seidel_8cpp.html#a78a394181a2ec486cda247b5ab57ed40">main</a>(<span class="keywordtype">void</span>){</div><div class="line">    FooVector x(3);</div><div class="line">    x.pointer[0] = 0;</div><div class="line">    x.pointer[1] = 1;</div><div class="line">    x.pointer[2] = 2;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;norm computed by HALA: &quot;</span> &lt;&lt; <a class="code" href="group__HALABLAS1.html#ga48f8d9b686ef4a9cdb69897e3f22bbe5">hala::norm2</a>(x) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;      expected answer: &quot;</span> &lt;&lt; std::sqrt(5.0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The simple example above is using specializations of the functions, which is easy enough since <b>FooVector</b> can only have scalar type <b>double</b>. However, if the custom vector class is a template, specializing the functions for every possible parameter can be tedious and partial specialization of structs is a much easier approach.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="hala_8hpp.html">hala.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// extension of FooVector to other types</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>FooVector{</div><div class="line">    FooVector(<span class="keywordtype">size_t</span> allocate_size) :</div><div class="line">        pointer(new T[allocate_size]), num_entries(allocate_size){}</div><div class="line">    ~FooVector(){ <span class="keyword">delete</span>[] pointer; }</div><div class="line">    T *pointer;</div><div class="line">    <span class="keywordtype">size_t</span> num_entries;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacehala.html">hala</a>{</div><div class="line">    <span class="comment">// specializations needed to use template FooVector in HALA templates</span></div><div class="line">    <span class="comment">// note that some specializations require both const and non-const FooVector</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>define_type&lt;FooVector&lt;T&gt;&gt;{</div><div class="line">        <span class="keyword">using</span> value_type = std::remove_cv_t&lt;T&gt;;</div><div class="line">    };</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>define_type&lt;FooVector&lt;T&gt; const&gt;{</div><div class="line">        <span class="keyword">using</span> value_type = std::remove_cv_t&lt;T&gt;;</div><div class="line">    };</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>define_size&lt;FooVector&lt;T&gt;&gt;{</div><div class="line">        <span class="keyword">static</span> <span class="keyword">auto</span> size(FooVector&lt;T&gt; <span class="keyword">const</span> &amp;x){ <span class="keywordflow">return</span> x.num_entries; }</div><div class="line">    };</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>define_size&lt;FooVector&lt;T&gt; const&gt;{</div><div class="line">        <span class="keyword">static</span> <span class="keyword">auto</span> size(FooVector&lt;T&gt; <span class="keyword">const</span> &amp;x){ <span class="keywordflow">return</span> x.num_entries; }</div><div class="line">    };</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>define_data&lt;FooVector&lt;T&gt;&gt;{</div><div class="line">        <span class="keyword">static</span> <span class="keyword">auto</span> data(FooVector&lt;T&gt; &amp;x){ <span class="keywordflow">return</span> x.pointer; }</div><div class="line">    };</div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>define_data&lt;FooVector&lt;T&gt; const&gt;{</div><div class="line">        <span class="keyword">static</span> <span class="keyword">auto</span> data(FooVector&lt;T&gt; <span class="keyword">const</span> &amp;x){ <span class="keywordflow">return</span> x.pointer; }</div><div class="line">    };</div><div class="line">    <span class="comment">// optional resize struct</span></div><div class="line">    <span class="comment">// template&lt;typename T&gt; struct define_resize&lt;FooVector&lt;T&gt;&gt;{</span></div><div class="line">    <span class="comment">//     static void resize(size_t new_size, FooVector&lt;T&gt; &amp;x){</span></div><div class="line">    <span class="comment">//         delete[] x.pointer;</span></div><div class="line">    <span class="comment">//         x.points = new T[new_size];</span></div><div class="line">    <span class="comment">//         x.num_entries = new_size;</span></div><div class="line">    <span class="comment">//     }</span></div><div class="line">    <span class="comment">// };</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keywordtype">void</span> test(){</div><div class="line">    FooVector&lt;T&gt; x(3);</div><div class="line">    x.pointer[0] = 0;</div><div class="line">    x.pointer[1] = 1;</div><div class="line">    x.pointer[2] = 2;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;norm computed by HALA: &quot;</span> &lt;&lt; <a class="code" href="group__HALABLAS1.html#ga48f8d9b686ef4a9cdb69897e3f22bbe5">hala::norm2</a>(x) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;      expected answer: &quot;</span> &lt;&lt; std::sqrt(5.0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="example__gauss__seidel_8cpp.html#a78a394181a2ec486cda247b5ab57ed40">main</a>(<span class="keywordtype">void</span>){</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Test with T = float\n&quot;</span>;</div><div class="line">    test&lt;float&gt;();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\nTest with T = double\n&quot;</span>;</div><div class="line">    test&lt;double&gt;();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>The two simple implementations of <b>FooVector</b> required specialization for the four types, size, resize, and data. However, if a vector already provides some of those methods in a manner consistent with std::vector, then only the missing cases have to be handled. For example, the std::valarray container satisfies the first three cases, but lacks the <b></b>.data() method. Thus, only the <b>define_data</b> struct requires a specialization and HALA already includes the necessary code. Similarly, if we redefine <b>FooVector</b> we can remove the need to specialize several of the structs:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="hala_8hpp.html">hala.hpp</a>&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// extension of FooVector to other types</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>FooVector{</div><div class="line">    <span class="keyword">using</span> value_type = T;</div><div class="line">    FooVector(<span class="keywordtype">size_t</span> allocate_size) :</div><div class="line">        pointer(new T[allocate_size]), num_entries(allocate_size){}</div><div class="line">    ~FooVector(){ <span class="keyword">delete</span> pointer; }</div><div class="line">    T* data(){ <span class="keywordflow">return</span> pointer; }</div><div class="line">    T <span class="keyword">const</span>* data()<span class="keyword"> const</span>{ <span class="keywordflow">return</span> pointer; }</div><div class="line">    <span class="keywordtype">size_t</span> size()<span class="keyword"> const</span>{ <span class="keywordflow">return</span> num_entries; }</div><div class="line">    T *pointer;</div><div class="line">    <span class="keywordtype">size_t</span> num_entries;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacehala.html">hala</a>{</div><div class="line">    <span class="comment">// define_type, define_size, and define_data will automatically</span></div><div class="line">    <span class="comment">// pick up the corresponding methods of \b FooVector&lt;T&gt;</span></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>define_resize&lt;FooVector&lt;T&gt;&gt;{</div><div class="line">        <span class="keyword">static</span> <span class="keywordtype">void</span> resize(<span class="keywordtype">size_t</span>, FooVector&lt;T&gt; &amp;){</div><div class="line">            <span class="comment">// even this is not necessary, by default HALA will trow</span></div><div class="line">            <span class="comment">// a runtime_error if a resize is attempted.</span></div><div class="line">        }</div><div class="line">    };</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keywordtype">void</span> test(){</div><div class="line">    FooVector&lt;T&gt; x(3);</div><div class="line">    x.pointer[0] = 0;</div><div class="line">    x.pointer[1] = 1;</div><div class="line">    x.pointer[2] = 2;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;norm computed by HALA: &quot;</span> &lt;&lt; <a class="code" href="group__HALABLAS1.html#ga48f8d9b686ef4a9cdb69897e3f22bbe5">hala::norm2</a>(x) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;      expected answer: &quot;</span> &lt;&lt; std::sqrt(5.0) &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="example__gauss__seidel_8cpp.html#a78a394181a2ec486cda247b5ab57ed40">main</a>(<span class="keywordtype">void</span>){</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Test with T = float\n&quot;</span>;</div><div class="line">    test&lt;float&gt;();</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\nTest with T = double\n&quot;</span>;</div><div class="line">    test&lt;double&gt;();</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> <h2 class="groupheader">Typedef Documentation</h2>
<a id="gab93c1d2ec9a0e8222f141d16c56a1b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab93c1d2ec9a0e8222f141d16c56a1b58">&#9670;&nbsp;</a></span>get_scalar_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLike &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__HALACUSTOM.html#gab93c1d2ec9a0e8222f141d16c56a1b58">hala::get_scalar_type</a> = typedef typename <a class="el" href="structhala_1_1define__type.html">define_type</a>&lt;std::remove_reference_t&lt;VectorLike&gt; &gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias to the scalar type of a vector-like class. </p>
<p>Helper template that accepts a vector-like class and aliases to the scalar type, e.g., double for std::vector&lt;double&gt;. </p>

</div>
</div>
<a id="gaeb090a328015649aed8ed8bb9b5e4980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb090a328015649aed8ed8bb9b5e4980">&#9670;&nbsp;</a></span>get_standard_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLike &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__HALACUSTOM.html#gaeb090a328015649aed8ed8bb9b5e4980">hala::get_standard_type</a> = typedef typename <a class="el" href="structhala_1_1define__standard__type.html">define_standard_type</a>&lt;typename <a class="el" href="structhala_1_1define__type.html">define_type</a>&lt;VectorLike&gt;::value_type&gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias to the standard equivalent for the scalar type of a vector-like class. </p>
<p>Helper template that accepts a vector-like class and aliases to the equivalent standard scalar type, e.g., if using a custom double precision complex type the template will alias to std::complex&lt;double&gt;. If the vector is already using one of the C++ standard types, this is equivalent to <a class="el" href="group__HALACUSTOM.html#gab93c1d2ec9a0e8222f141d16c56a1b58" title="Alias to the scalar type of a vector-like class. ">hala::get_scalar_type</a>.</p>
<p>The standard type can always be used in algebraic expressions since all arithmetic operators are overloaded. </p>

</div>
</div>
<a id="ga78609b70f45312e08e520b6ed736ff40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78609b70f45312e08e520b6ed736ff40">&#9670;&nbsp;</a></span>get_precision_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLike &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__HALACUSTOM.html#ga78609b70f45312e08e520b6ed736ff40">hala::get_precision_type</a> = typedef typename <a class="el" href="structhala_1_1define__standard__precision.html">define_standard_precision</a>&lt;typename <a class="el" href="structhala_1_1define__type.html">define_type</a>&lt;VectorLike&gt;::value_type&gt;::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias to the base precision type of a vector, e.g., <b>float</b> and <b>std::complex&lt;float&gt;</b> map to float. </p>
<p>Helper template that accepts a vector-like class and aliases to the equivalent precision or real scalar type, e.g., both float and std::complex&lt;float&gt; will alias to float. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacb23ab0a92ecead8007cf9aa8dc972db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb23ab0a92ecead8007cf9aa8dc972db">&#9670;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLike &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t hala::get_size </td>
          <td>(</td>
          <td class="paramtype">VectorLike const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of entries in the vector, if <b>VectorLike</b> does not have <b></b>.size() method, then the template must be specialized. </p>
<p>The function uses <b><a class="el" href="structhala_1_1define__size.html" title="Template that defines the size of the vector. ">hala::define_size</a></b> which in turn uses <b>VectorLike::size()</b>. If the <b>VectorLike</b> class doesn't have <b></b>.size(), then either this function or struct <b><b><a class="el" href="structhala_1_1define__size.html" title="Template that defines the size of the vector. ">hala::define_size</a></b> have</b> to be specialized. </p>

</div>
</div>
<a id="ga957f659d97426f04b2060bceb9d90fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga957f659d97426f04b2060bceb9d90fee">&#9670;&nbsp;</a></span>set_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLike &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hala::set_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorLike &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set new size for the <b>VectorLike</b>, called only if <b>get_size(x)</b> is not sufficient and it uses <b></b>.resize() method. </p>
<p>HALA will never call <b><a class="el" href="group__HALACUSTOM.html#ga957f659d97426f04b2060bceb9d90fee" title="Set new size for the VectorLike, called only if get_size(x) is not sufficient and it uses ...">set_size()</a></b> on a <b>VectorLike</b> that has sufficient size for the requested operation. If called, the included implementation will use the <b></b>.resize() method and will automatically work for any <b>VectorLike</b> class that implements the method similar to <b>std::vector</b> and <b>std::valarray</b>. This template must be specialized to use classes that do not have <b></b>.resize(). </p>

</div>
</div>
<a id="gaeee2b3b81522284482c1196d20ed0635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeee2b3b81522284482c1196d20ed0635">&#9670;&nbsp;</a></span>get_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorLike &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto hala::get_data </td>
          <td>(</td>
          <td class="paramtype">VectorLike &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a raw pointer to the internal contiguous array stored in the <b>VectorLike</b>. </p>
<p>The function uses the <b>data_extractor</b> struct and will automatically if the <b>VectorLike</b> has the <b></b>.data() method similar to <b>std::vector</b>, or if the <b>data_extractor</b> has been specialized for the specific <b>VectorLike</b>. Otherwise, this function has to be specialized to handle a user provide <b>VectorLike</b>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div> -->
</body>
</html>
