<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HALA: Handy Accelerated Linear Algebra v1.0: HALA Advanced Vector Extensions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hala.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
    <div class="doxygen">
            <a href="http://www.doxygen.org/index.html">
                <img class="footer" src="doxygen.png" alt="doxygen"/>
                </a> 1.8.13
    </div>
   <div id="projectname">HALA: Handy Accelerated Linear Algebra v1.0
   <!--         <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
 -->
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__HALAVEX.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">HALA Advanced Vector Extensions</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for HALA Advanced Vector Extensions:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__HALAVEX.png" border="0" alt="" usemap="#group____HALAVEX"/>
<map name="group____HALAVEX" id="group____HALAVEX">
<area shape="rect" id="node2" href="group__HALAALALLOC.html" title="Aligned Vector" alt="" coords="215,13,321,39"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__HALAALALLOC"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALAALALLOC.html">Aligned Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1bind__pack.html">hala::bind_pack&lt; T, R, alignment, &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds a memory slice to an address, constructor reads from the address, destructor writes back.  <a href="structhala_1_1bind__pack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structhala_1_1mmpack.html">hala::mmpack&lt; T, R &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the aligned memory used by intrinsic methods.  <a href="structhala_1_1mmpack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf92953ace32fcf72b0851b9334306432"><td class="memTemplParams" colspan="2"><a id="gaf92953ace32fcf72b0851b9334306432"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf92953ace32fcf72b0851b9334306432"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#gaf92953ace32fcf72b0851b9334306432">hala::mmpack_sse</a> = <a class="el" href="structhala_1_1mmpack.html">mmpack</a>&lt; T, <a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea64192ca465194480a4621d6905dac5b7">regtype::sse</a> &gt;</td></tr>
<tr class="memdesc:gaf92953ace32fcf72b0851b9334306432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut alias to <b>mmpack&lt;T</b>, <b>sse&gt;</b>. <br /></td></tr>
<tr class="separator:gaf92953ace32fcf72b0851b9334306432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga963b24f8519b434eaa131621d8f188a1"><td class="memTemplParams" colspan="2"><a id="ga963b24f8519b434eaa131621d8f188a1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga963b24f8519b434eaa131621d8f188a1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga963b24f8519b434eaa131621d8f188a1">hala::mmpack_avx</a> = <a class="el" href="structhala_1_1mmpack.html">mmpack</a>&lt; T, <a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea73758c37e4499f20ac5f995a144abba6">regtype::avx</a> &gt;</td></tr>
<tr class="memdesc:ga963b24f8519b434eaa131621d8f188a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut alias to <b>mmpack&lt;T</b>, <b>avx&gt;</b>. <br /></td></tr>
<tr class="separator:ga963b24f8519b434eaa131621d8f188a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23936923329b992d6d248f906c005bac"><td class="memTemplParams" colspan="2"><a id="ga23936923329b992d6d248f906c005bac"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga23936923329b992d6d248f906c005bac"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga23936923329b992d6d248f906c005bac">hala::mmpack_avx512</a> = <a class="el" href="structhala_1_1mmpack.html">mmpack</a>&lt; T, <a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea01ed71f991f565d98b82f76ac36e0628">regtype::avx512</a> &gt;</td></tr>
<tr class="memdesc:ga23936923329b992d6d248f906c005bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut alias to <b>mmpack&lt;T</b>, <b>avx512&gt;</b>. <br /></td></tr>
<tr class="separator:ga23936923329b992d6d248f906c005bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5cf9392711eaa1cd0f3ba628585d4bee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga5cf9392711eaa1cd0f3ba628585d4bee">hala::regtype</a> { <a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea334c4a4c42fdb79d7ebc3e73b517e6f8">hala::regtype::none</a>, 
<a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea64192ca465194480a4621d6905dac5b7">hala::regtype::sse</a>, 
<a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea73758c37e4499f20ac5f995a144abba6">hala::regtype::avx</a>, 
<a class="el" href="group__HALAVEX.html#gga5cf9392711eaa1cd0f3ba628585d4beea01ed71f991f565d98b82f76ac36e0628">hala::regtype::avx512</a>
 }<tr class="memdesc:ga5cf9392711eaa1cd0f3ba628585d4bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the type of register to use for vectorization.  <a href="group__HALAVEX.html#ga5cf9392711eaa1cd0f3ba628585d4bee">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga5cf9392711eaa1cd0f3ba628585d4bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga14f5262dde3f5ac172846b78f6549876"><td class="memTemplParams" colspan="2">template&lt;regtype R = default_regtype, typename T &gt; </td></tr>
<tr class="memitem:ga14f5262dde3f5ac172846b78f6549876"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhala_1_1bind__pack.html">bind_pack</a>&lt; T, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga14f5262dde3f5ac172846b78f6549876">hala::mmbind</a> (T *address)</td></tr>
<tr class="memdesc:ga14f5262dde3f5ac172846b78f6549876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the address to a <a class="el" href="structhala_1_1bind__pack.html" title="Binds a memory slice to an address, constructor reads from the address, destructor writes back...">hala::bind_pack</a>, multiple overloads are provided.  <a href="group__HALAVEX.html#ga14f5262dde3f5ac172846b78f6549876">More...</a><br /></td></tr>
<tr class="separator:ga14f5262dde3f5ac172846b78f6549876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cf5950d80ce3fade6aad23d8879ac99"><td class="memTemplParams" colspan="2"><a id="ga2cf5950d80ce3fade6aad23d8879ac99"></a>
template&lt;typename T , regtype R&gt; </td></tr>
<tr class="memitem:ga2cf5950d80ce3fade6aad23d8879ac99"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga2cf5950d80ce3fade6aad23d8879ac99">hala::operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structhala_1_1mmpack.html">mmpack</a>&lt; T, R &gt; &amp;s)</td></tr>
<tr class="memdesc:ga2cf5950d80ce3fade6aad23d8879ac99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs all entries of the vector to the stream. <br /></td></tr>
<tr class="separator:ga2cf5950d80ce3fade6aad23d8879ac99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeff34187b76d7df81181126329c462c3"><td class="memTemplParams" colspan="2"><a id="gaeff34187b76d7df81181126329c462c3"></a>
template&lt;typename T , regtype R = default_regtype&gt; </td></tr>
<tr class="memitem:gaeff34187b76d7df81181126329c462c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhala_1_1mmpack.html">mmpack</a>&lt; T, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#gaeff34187b76d7df81181126329c462c3">hala::mmzero</a> ()</td></tr>
<tr class="memdesc:gaeff34187b76d7df81181126329c462c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a slice filled with zeros. <br /></td></tr>
<tr class="separator:gaeff34187b76d7df81181126329c462c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c95da1acd7a0b8e27a8db06391f61a8"><td class="memTemplParams" colspan="2">template&lt;regtype R = default_regtype, typename T &gt; </td></tr>
<tr class="memitem:ga5c95da1acd7a0b8e27a8db06391f61a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structhala_1_1mmpack.html">mmpack</a>&lt; T, R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga5c95da1acd7a0b8e27a8db06391f61a8">hala::mmload</a> (T const *a)</td></tr>
<tr class="memdesc:ga5c95da1acd7a0b8e27a8db06391f61a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a slice filled with the data from <b>a</b>, multiple modes are supported.  <a href="group__HALAVEX.html#ga5c95da1acd7a0b8e27a8db06391f61a8">More...</a><br /></td></tr>
<tr class="separator:ga5c95da1acd7a0b8e27a8db06391f61a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga5d9da2ddaf6fd95898e64516d3a0e743"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="group__HALAVEX.html#ga5cf9392711eaa1cd0f3ba628585d4bee">regtype</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga5d9da2ddaf6fd95898e64516d3a0e743">hala::default_regtype</a> = <a class="el" href="namespacehala.html#a1e650c4e0fd090f77d7a5f34b75724a4">get_default_regtype</a>()</td></tr>
<tr class="memdesc:ga5d9da2ddaf6fd95898e64516d3a0e743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default register type for vectorization, different for each system.  <a href="group__HALAVEX.html#ga5d9da2ddaf6fd95898e64516d3a0e743">More...</a><br /></td></tr>
<tr class="separator:ga5d9da2ddaf6fd95898e64516d3a0e743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae94acb9514813ca67a7517f20ecc090e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structhala_1_1define__unaligned.html">define_unaligned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#gae94acb9514813ca67a7517f20ecc090e">hala::unaligned</a></td></tr>
<tr class="memdesc:gae94acb9514813ca67a7517f20ecc090e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for expressive calls to hala::vex when reading/writing from/to unaligned memory.  <a href="group__HALAVEX.html#gae94acb9514813ca67a7517f20ecc090e">More...</a><br /></td></tr>
<tr class="separator:gae94acb9514813ca67a7517f20ecc090e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaebcc7db0dc6bf8da3ac3ae45847984e"><td class="memItemLeft" align="right" valign="top"><a id="gaaebcc7db0dc6bf8da3ac3ae45847984e"></a>
constexpr <a class="el" href="structhala_1_1define__aligned.html">define_aligned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#gaaebcc7db0dc6bf8da3ac3ae45847984e">hala::aligned</a></td></tr>
<tr class="memdesc:gaaebcc7db0dc6bf8da3ac3ae45847984e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for expressive calls to hala::vex when reading/writing from/to unaligned memory, see <a class="el" href="group__HALAVEX.html#gae94acb9514813ca67a7517f20ecc090e" title="Allows for expressive calls to hala::vex when reading/writing from/to unaligned memory. ">hala::unaligned</a>. <br /></td></tr>
<tr class="separator:gaaebcc7db0dc6bf8da3ac3ae45847984e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2023aad27a4f5dbaece48b2c57bd90"><td class="memItemLeft" align="right" valign="top"><a id="ga7a2023aad27a4f5dbaece48b2c57bd90"></a>
constexpr <a class="el" href="structhala_1_1define__single.html">define_single</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__HALAVEX.html#ga7a2023aad27a4f5dbaece48b2c57bd90">hala::single</a></td></tr>
<tr class="memdesc:ga7a2023aad27a4f5dbaece48b2c57bd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows for expressive calls to hala::vex when reading/writing a single entry from an array. <br /></td></tr>
<tr class="separator:ga7a2023aad27a4f5dbaece48b2c57bd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="section user"><dt>SSE and AVX</dt><dd></dd></dl>
<p>SSE and AVX refer to special register standards supported on many CPUs that allow for multiple floating point operations at once. The use of the registers can dramatically improve performance and while compilers strive to utilize the full potential of the CPU vectorization, they often fall short. Manual vectorization is doable, i.e., process a long vector in strides of 2/4/8/16 entries at a time, but the implementation is cumbersome at best. Gaining access to the intrinsic capabilities requires heavy use of C, C-style functions, and C macros, especially when dealing with complex numbers.</p>
<p>HALA provides a wrapper to the vector types and methods that uses C++ templates and operator overloads, which significantly improves readability and accessibility. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga5cf9392711eaa1cd0f3ba628585d4bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cf9392711eaa1cd0f3ba628585d4bee">&#9670;&nbsp;</a></span>regtype</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__HALAVEX.html#ga5cf9392711eaa1cd0f3ba628585d4bee">hala::regtype</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the type of register to use for vectorization. </p>
<p>Each options requires compatible compiler flags:</p><ul>
<li><b>sse</b> requires HALA_ENABLE_SSE and the -msse2 and -mss3 flags</li>
<li><b>avx</b> requires HALA_ENABLE_AVX and the -mavx flag</li>
<li><b>avx512</b> requires HALA_ENABLE_AVX512 and the -mavx512f flag</li>
</ul>
<p>In addition, using HALA_ENABLE_FMA and the -mfma flag will enable extra templates for the sse and avx register modes (the fma instructions for avx512 are included by the -mavx512f flag). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga5cf9392711eaa1cd0f3ba628585d4beea334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"><p>No vectorization, i.e., generate code equivalent to the serial code. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5cf9392711eaa1cd0f3ba628585d4beea64192ca465194480a4621d6905dac5b7"></a>sse&#160;</td><td class="fielddoc"><p>Using the 128 bit SSE registers. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5cf9392711eaa1cd0f3ba628585d4beea73758c37e4499f20ac5f995a144abba6"></a>avx&#160;</td><td class="fielddoc"><p>Using the 256 bit AVX registers. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga5cf9392711eaa1cd0f3ba628585d4beea01ed71f991f565d98b82f76ac36e0628"></a>avx512&#160;</td><td class="fielddoc"><p>Using the 512 bit AVX-512 registers. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga14f5262dde3f5ac172846b78f6549876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14f5262dde3f5ac172846b78f6549876">&#9670;&nbsp;</a></span>mmbind()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;regtype R = default_regtype, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhala_1_1bind__pack.html">bind_pack</a>&lt;T, R&gt; hala::mmbind </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind the address to a <a class="el" href="structhala_1_1bind__pack.html" title="Binds a memory slice to an address, constructor reads from the address, destructor writes back...">hala::bind_pack</a>, multiple overloads are provided. </p>
<p>Creates a binding between a <a class="el" href="structhala_1_1mmpack.html" title="Wrapper for the aligned memory used by intrinsic methods. ">hala::mmpack</a> and the specified address. Overloads are provided to handle different alignment modes and aligned iterators, but neither the <b>address</b> nor the iterator can be const since the <a class="el" href="structhala_1_1bind__pack.html" title="Binds a memory slice to an address, constructor reads from the address, destructor writes back...">hala::bind_pack</a> destructor will write to the address.</p>
<p>Overloads: </p><div class="fragment"><div class="line">T *pntr = ...;                <span class="comment">// pointer</span></div><div class="line"><span class="keyword">auto</span> iter = <a class="code" href="group__HALAALALLOC.html#gad4e05fbd87f05b4cfd4886b3895d6ce5">hala::mmbegin</a>(x); <span class="comment">// non-const aligned iterator</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> mmb = <a class="code" href="group__HALAVEX.html#ga14f5262dde3f5ac172846b78f6549876">hala::mmbind</a>(pntr);            <span class="comment">// use default alignment</span></div><div class="line"><span class="keyword">auto</span> mmb = <a class="code" href="group__HALAVEX.html#ga14f5262dde3f5ac172846b78f6549876">hala::mmbind</a>(pntr, <a class="code" href="group__HALAVEX.html#gaaebcc7db0dc6bf8da3ac3ae45847984e">aligned</a>);   <span class="comment">// assume aligned read/write</span></div><div class="line"><span class="keyword">auto</span> mmb = <a class="code" href="group__HALAVEX.html#ga14f5262dde3f5ac172846b78f6549876">hala::mmbind</a>(pntr, <a class="code" href="group__HALAVEX.html#gae94acb9514813ca67a7517f20ecc090e">unaligned</a>); <span class="comment">// assume unaligned read/write</span></div><div class="line"><span class="keyword">auto</span> mmb = <a class="code" href="group__HALAVEX.html#ga14f5262dde3f5ac172846b78f6549876">hala::mmbind</a>(iter);            <span class="comment">// read/write from/to hala::aligned_iterator</span></div></div><!-- fragment --><p> In all cases, <b>mmb</b> will be an instance of <a class="el" href="structhala_1_1bind__pack.html" title="Binds a memory slice to an address, constructor reads from the address, destructor writes back...">hala::bind_pack</a> with the specified type and register type. </p>

</div>
</div>
<a id="ga5c95da1acd7a0b8e27a8db06391f61a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c95da1acd7a0b8e27a8db06391f61a8">&#9670;&nbsp;</a></span>mmload()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;regtype R = default_regtype, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhala_1_1mmpack.html">mmpack</a>&lt;T, R&gt; hala::mmload </td>
          <td>(</td>
          <td class="paramtype">T const *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a slice filled with the data from <b>a</b>, multiple modes are supported. </p>
<p>Creates a pack of entries using the data in <b>a</b>. Overloads are provided to handle pointers, values, and iterators, and to manually specify the alignment.</p>
<p>Overloads: </p><div class="fragment"><div class="line">T <span class="keyword">const</span> *pntr = ...;          <span class="comment">// pointer</span></div><div class="line">T <span class="keyword">const</span> value = ...;          <span class="comment">// value</span></div><div class="line"><span class="keyword">auto</span> iter = <a class="code" href="group__HALAALALLOC.html#gad4e05fbd87f05b4cfd4886b3895d6ce5">hala::mmbegin</a>(x); <span class="comment">// aligned iterator</span></div><div class="line"></div><div class="line"><span class="keyword">auto</span> mmx = <a class="code" href="group__HALAVEX.html#ga5c95da1acd7a0b8e27a8db06391f61a8">hala::mmload</a>(pntr);            <span class="comment">// use default alignment</span></div><div class="line"><span class="keyword">auto</span> mmx = <a class="code" href="group__HALAVEX.html#ga5c95da1acd7a0b8e27a8db06391f61a8">hala::mmload</a>(pntr, <a class="code" href="group__HALAVEX.html#gaaebcc7db0dc6bf8da3ac3ae45847984e">aligned</a>);   <span class="comment">// assume aligned read</span></div><div class="line"><span class="keyword">auto</span> mmx = <a class="code" href="group__HALAVEX.html#ga5c95da1acd7a0b8e27a8db06391f61a8">hala::mmload</a>(pntr, <a class="code" href="group__HALAVEX.html#gae94acb9514813ca67a7517f20ecc090e">unaligned</a>); <span class="comment">// assume unaligned read</span></div><div class="line"><span class="keyword">auto</span> mmx = <a class="code" href="group__HALAVEX.html#ga5c95da1acd7a0b8e27a8db06391f61a8">hala::mmload</a>(pntr, <a class="code" href="group__HALAVEX.html#ga7a2023aad27a4f5dbaece48b2c57bd90">single</a>);    <span class="comment">// set all pack entries to the pntr[0]</span></div><div class="line"><span class="keyword">auto</span> mmx = <a class="code" href="group__HALAVEX.html#ga5c95da1acd7a0b8e27a8db06391f61a8">hala::mmload</a>(value);           <span class="comment">// set all pack entries to the value</span></div><div class="line"><span class="keyword">auto</span> mmx = <a class="code" href="group__HALAVEX.html#ga5c95da1acd7a0b8e27a8db06391f61a8">hala::mmload</a>(iter);            <span class="comment">// read from a hala::aligned_iterator</span></div></div><!-- fragment --><p> In all cases, <b>mmx</b> will be an instance of <a class="el" href="structhala_1_1mmpack.html" title="Wrapper for the aligned memory used by intrinsic methods. ">hala::mmpack</a> with the specified type and register type. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga5d9da2ddaf6fd95898e64516d3a0e743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d9da2ddaf6fd95898e64516d3a0e743">&#9670;&nbsp;</a></span>default_regtype</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="group__HALAVEX.html#ga5cf9392711eaa1cd0f3ba628585d4bee">regtype</a> hala::default_regtype = <a class="el" href="namespacehala.html#a1e650c4e0fd090f77d7a5f34b75724a4">get_default_regtype</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default register type for vectorization, different for each system. </p>
<p>By default, HALA will use the widest available register, which is determined form the compiler macros that are in turn controlled by the compiler options, e.g., -mtune=native. </p>

</div>
</div>
<a id="gae94acb9514813ca67a7517f20ecc090e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae94acb9514813ca67a7517f20ecc090e">&#9670;&nbsp;</a></span>unaligned</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structhala_1_1define__unaligned.html">define_unaligned</a> hala::unaligned</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows for expressive calls to hala::vex when reading/writing from/to unaligned memory. </p>
<p>Example: </p><div class="fragment"><div class="line">hala::vex::mmpack&lt;float&gt; v1(x); <span class="comment">// using default behavior based on known compiler features</span></div><div class="line">hala::vex::mmpack&lt;float&gt; v2(y, <a class="code" href="group__HALAVEX.html#gae94acb9514813ca67a7517f20ecc090e">unaligned</a>); <span class="comment">// y is known to have improper alignment</span></div><div class="line">hala::vex::mmpack&lt;float&gt; v3(z, <a class="code" href="group__HALAVEX.html#gaaebcc7db0dc6bf8da3ac3ae45847984e">aligned</a>);   <span class="comment">// z is known to have proper alignment</span></div></div><!-- fragment --><p>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<!-- <div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
<!--  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div> -->
</body>
</html>
